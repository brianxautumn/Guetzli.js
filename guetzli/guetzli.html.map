{"version":3,"file":"guetzli.html","sources":["..\\guetzli/idct.cc","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\algorithm","..\\guetzli/dct_double.cc","..\\guetzli/gamma_correct.cc","..\\guetzli/preprocess_downsample.cc","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\vector","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\__bit_reference","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\math.h","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\memory","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\new","..\\guetzli/quantize.cc","..\\guetzli/quantize.h","..\\guetzli/output_image.cc","..\\guetzli/output_image.h","..\\guetzli/jpeg_data.cc","..\\guetzli/color_transform.h","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\string","..\\guetzli/score.cc","..\\guetzli/butteraugli_comparator.cc","..\\guetzli/comparator.h","../third_party/butteraugli\\butteraugli/butteraugli.h","../third_party/butteraugli\\butteraugli/butteraugli.cc","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\iterator","..\\guetzli/debug_print.cc","..\\guetzli/jpeg_data_decoder.cc","..\\guetzli/fdct.cc","..\\guetzli/jpeg_data_encoder.cc","..\\guetzli/jpeg_data.h","..\\guetzli/jpeg_huffman_decode.cc","..\\guetzli/jpeg_huffman_decode.h","..\\guetzli/jpeg_data_reader.cc","..\\guetzli/entropy_encode.cc","..\\guetzli/entropy_encode.h","..\\guetzli/jpeg_data_writer.cc","..\\guetzli/jpeg_data_writer.h","..\\guetzli/fast_log.h","..\\guetzli/processor.cc","..\\guetzli/processor.h","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\map","..\\guetzli/stats.h","..\\guetzli/quality.cc","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\array","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\type_traits","../third_party\\lodepng/lodepng.cpp","../third_party\\lodepng/lodepng.h","guetzli_emscripten.cc","..\\guetzli/butteraugli_comparator.h","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\__split_buffer","..\\guetzli/jpeg_bit_writer.h","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\utility","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\set","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\__tree","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\tuple","C:\\Program Files\\Emscripten\\emscripten\\tag-1.37.8\\system\\include\\libcxx\\__functional_base"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+IA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;;;;;;;;;;;;;;;;AAUA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;ACsiBA;AAAA;AAAA;ADtiBA;AAAA;AADA;AAAA;AACA;AAAA;AAAA;ACsiBA;AAAA;AAAA;ADtiBA;AAAA;AADA;AAAA;AAAA;AACA;AAAA;AAAA;ACsiBA;AAAA;AAAA;ADtiBA;AAAA;AADA;AAAA;AAAA;AACA;AAAA;AAAA;ACsiBA;AAAA;AAAA;ADtiBA;AAAA;AADA;AAAA;AAAA;AACA;AAAA;AAAA;ACsiBA;AAAA;AAAA;ADtiBA;AAAA;AADA;AAAA;AAAA;AACA;AAAA;AAAA;ACsiBA;AAAA;AAAA;ADtiBA;AAAA;AADA;AAAA;AAAA;AACA;AAAA;AAAA;ACsiBA;AAAA;AAAA;ADtiBA;AAAA;AADA;AAAA;AAAA;AACA;AAAA;AAAA;ACsiBA;AAAA;AAAA;ADtiBA;AAAA;AADA;AAAA;AAAA;AALA;AAAA;;;;;;;AASA;;;;;;;;;;;;;;;;AArHA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAC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PwyCA;AOxyCA;AAAA;;;AAFA;AACA;AACA;AAHA;;;;;;;;AAlBA;;;AAIA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAMA;AAAA;AP2yCA;AAAA;AO3yCA;AAAA;AAAA;AACA;AAAA;AP0yCA;AO1yCA;AAAA;AACA;APyyCA;AOzyCA;AAAA;AACA;APwyCA;AOxyCA;AAAA;;;AAFA;AACA;AACA;AAHA;;;;;;;;AAlBA;;;AAIA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAMA;AAAA;AP2yCA;AAAA;AO3yCA;AAAA;AAAA;AACA;AAAA;AP0yCA;AO1yCA;AAAA;AACA;APyyCA;AOzyCA;AAAA;AACA;APwyCA;AOxyCA;AAAA;;;AAFA;AACA;AACA;AAHA;;;;;;;;AAlBA;;;AAIA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAMA;AAAA;AP2yCA;AAAA;AO3yCA;AAAA;AAAA;AACA;AAAA;AP0yCA;AO1yCA;AAAA;AACA;APyyCA;AOzyCA;AAAA;AACA;APwyCA;AOxyCA;AAAA;;;AAFA;AACA;AACA;AAHA;;;;;;;;AAlBA;;;AAIA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAMA;AAAA;AP2yCA;AAAA;AO3yCA;AAAA;AAAA;AACA;AAAA;AP0yCA;AO1yCA;AAAA;AACA;APyyCA;AOzyCA;AAAA;AACA;APwyCA;AOxyCA;AAAA;;;AAFA;AACA;AACA;AAHA;;;;;;;;AAlBA;;;AAIA;AAAA;AAAA;;;;AAE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AAAA;AAAA;AAAA;AAAA;AADA;AAAA;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;;;;;;;;AAVA;AAAA;;AAAA;;;;;;;AAkBA;;;;;;;AAyFA;AoBjEA;ApBkEA;AoBlEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AoBpEA;ApBoEA;AAEA;;;;;AAIA;AAAA;;AAAA;AAAA;;AAAA;;;AACA;;;;;;;AAOA;AoBlFA;ApBmFA;AoBnFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AoBrFA;ApBqFA;AAEA;;;;;AAIA;AAAA;;AAAA;AAAA;;AAAA;;;AACA;;;;;;;AAMA;AoBlGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AoBpGA;ApBoGA;AAEA;;;;;AAIA;AAAA;;AAAA;AAAA;;AAAA;;;AACA;;;;;;;;;;;AA2CA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;AA0BA;AAAA;AAAA;AAAA;;;;;AAGA;;AACA;;;;AAEA;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;AAOA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAYA;;AATA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAEA;;;;;;;;;;;;AAvCA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AA2FA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAzHA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AAuGA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AAAA;AACA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AACA;AAAA;AAFA;AAAA;;;;;;;AAIA;;;;;;;;;;AAxOA;AAAA;AqBo8HA;AACA;AACA;ArBt8HA;AAAA;AqBo8HA;AACA;AACA;ArBt8HA;AAAA;AqBo8HA;AACA;AACA;ArBt8HA;AAAA;AqBo8HA;AACA;AACA;ArBt8HA;AAAA;AqBo8HA;AACA;AACA;ArBt8HA;AAAA;AqBo8HA;AACA;AACA;ArBt8HA;AAAA;AqBo8HA;AACA;AACA;ArBt8HA;AAAA;AqBo8HA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BA;AAAA;AgBkdA;AADA;AAAA;AhBmWA;AApzBA;AAAA;AgBidA;AACA;AAAA;AhBkWA;AApzBA;AAAA;AgBkdA;AAGA;AAAA;AAAA;;AAwCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvCA;AAAA;AAEA;AAAA;;AADA;;;AAEA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;AhB0VA;AAAA;AgBrVA;AhBqVA;AAAA;AgBrVA;AAAA;AhBqVA;AgBpVA;AhBoVA;AgBpVA;AAAA;AADA;AAAA;AADA;AhBsVA;AAAA;AgBjVA;AhBiVA;AAAA;AgBjVA;AAAA;AhBiVA;AgBhVA;AhBgVA;AgBhVA;AAAA;AADA;AAAA;AADA;AhBkVA;AAAA;AgB7UA;AhB6UA;AAAA;AgB7UA;AAAA;AhB6UA;AgB5UA;AhB4UA;AgB5UA;AAAA;AADA;AAAA;AADA;;;;AhB8UA;AAAA;AgBzUA;AhByUA;AAAA;AgBzUA;AAAA;AhByUA;AgBxUA;AhBwUA;AgBxUA;AAAA;AADA;;;AADA;AAAA;AhB0UA;AAAA;AAAA;AgBrVA;AhBqVA;AAAA;AAAA;AgBrVA;AAAA;AhBqVA;AgBpVA;AhBoVA;AgBpVA;AAAA;AADA;AAAA;AADA;AhBsVA;AAAA;AAAA;AgBjVA;AhBiVA;AAAA;AAAA;AgBjVA;AAAA;AhBiVA;AgBhVA;AhBgVA;AgBhVA;AAAA;AADA;AAAA;AADA;AhBkVA;AAAA;AAAA;AgB7UA;AhB6UA;AAAA;AAAA;AgB7UA;AAAA;AhB6UA;AgB5UA;AhB4UA;AgB5UA;AAAA;AADA;AAAA;AADA;;;;AhB8UA;AAAA;AAAA;AgBzUA;AhByUA;AAAA;AAAA;AgBzUA;AAAA;AhByUA;AgBxUA;AhBwUA;AgBxUA;AAAA;AADA;;;AADA;AAAA;AhB0UA;AAAA;AAAA;AgBrVA;AhBqVA;AAAA;AAAA;AgBrVA;AAAA;AhBqVA;AgBpVA;AhBoVA;AgBpVA;AAAA;AADA;AAAA;AADA;AhBsVA;AAAA;AAAA;AgBjVA;AhBiVA;AAAA;AAAA;AgBjVA;AAAA;AhBiVA;AgBhVA;AhBgVA;AgBhVA;AAAA;AADA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","sourcesContent":["/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Integer implementation of the Inverse Discrete Cosine Transform (IDCT).\r\n\r\n#include \"guetzli/idct.h\"\r\n\r\n#include <algorithm>\r\n#include <math.h>\r\n\r\nnamespace guetzli {\r\n\r\n// kIDCTMatrix[8*x+u] = alpha(u)*cos((2*x+1)*u*M_PI/16)*sqrt(2), with fixed 13\r\n// bit precision, where alpha(0) = 1/sqrt(2) and alpha(u) = 1 for u > 0.\r\n// Some coefficients are off by +-1 to mimick libjpeg's behaviour.\r\nstatic const int kIDCTMatrix[kDCTBlockSize] = {\r\n  8192,  11363,  10703,   9633,   8192,   6437,   4433,   2260,\r\n  8192,   9633,   4433,  -2259,  -8192, -11362, -10704,  -6436,\r\n  8192,   6437,  -4433, -11362,  -8192,   2261,  10704,   9633,\r\n  8192,   2260, -10703,  -6436,   8192,   9633,  -4433, -11363,\r\n  8192,  -2260, -10703,   6436,   8192,  -9633,  -4433,  11363,\r\n  8192,  -6437,  -4433,  11362,  -8192,  -2261,  10704,  -9633,\r\n  8192,  -9633,   4433,   2259,  -8192,  11362, -10704,   6436,\r\n  8192, -11363,  10703,  -9633,   8192,  -6437,   4433,  -2260,\r\n};\r\n\r\n// Computes out[x] = sum{kIDCTMatrix[8*x+u]*in[u*stride]; for u in [0..7]}\r\ninline void Compute1dIDCT(const coeff_t* in, const int stride, int out[8]) {\r\n  int tmp0, tmp1, tmp2, tmp3, tmp4;\r\n\r\n  tmp1 = kIDCTMatrix[0] * in[0];\r\n  out[0] = out[1] = out[2] = out[3] = out[4] = out[5] = out[6] = out[7] = tmp1;\r\n\r\n  tmp0 = in[stride];\r\n  tmp1 = kIDCTMatrix[ 1] * tmp0;\r\n  tmp2 = kIDCTMatrix[ 9] * tmp0;\r\n  tmp3 = kIDCTMatrix[17] * tmp0;\r\n  tmp4 = kIDCTMatrix[25] * tmp0;\r\n  out[0] += tmp1;\r\n  out[1] += tmp2;\r\n  out[2] += tmp3;\r\n  out[3] += tmp4;\r\n  out[4] -= tmp4;\r\n  out[5] -= tmp3;\r\n  out[6] -= tmp2;\r\n  out[7] -= tmp1;\r\n\r\n  tmp0 = in[2 * stride];\r\n  tmp1 = kIDCTMatrix[ 2] * tmp0;\r\n  tmp2 = kIDCTMatrix[10] * tmp0;\r\n  out[0] += tmp1;\r\n  out[1] += tmp2;\r\n  out[2] -= tmp2;\r\n  out[3] -= tmp1;\r\n  out[4] -= tmp1;\r\n  out[5] -= tmp2;\r\n  out[6] += tmp2;\r\n  out[7] += tmp1;\r\n\r\n  tmp0 = in[3 * stride];\r\n  tmp1 = kIDCTMatrix[ 3] * tmp0;\r\n  tmp2 = kIDCTMatrix[11] * tmp0;\r\n  tmp3 = kIDCTMatrix[19] * tmp0;\r\n  tmp4 = kIDCTMatrix[27] * tmp0;\r\n  out[0] += tmp1;\r\n  out[1] += tmp2;\r\n  out[2] += tmp3;\r\n  out[3] += tmp4;\r\n  out[4] -= tmp4;\r\n  out[5] -= tmp3;\r\n  out[6] -= tmp2;\r\n  out[7] -= tmp1;\r\n\r\n  tmp0 = in[4 * stride];\r\n  tmp1 = kIDCTMatrix[ 4] * tmp0;\r\n  out[0] += tmp1;\r\n  out[1] -= tmp1;\r\n  out[2] -= tmp1;\r\n  out[3] += tmp1;\r\n  out[4] += tmp1;\r\n  out[5] -= tmp1;\r\n  out[6] -= tmp1;\r\n  out[7] += tmp1;\r\n\r\n  tmp0 = in[5 * stride];\r\n  tmp1 = kIDCTMatrix[ 5] * tmp0;\r\n  tmp2 = kIDCTMatrix[13] * tmp0;\r\n  tmp3 = kIDCTMatrix[21] * tmp0;\r\n  tmp4 = kIDCTMatrix[29] * tmp0;\r\n  out[0] += tmp1;\r\n  out[1] += tmp2;\r\n  out[2] += tmp3;\r\n  out[3] += tmp4;\r\n  out[4] -= tmp4;\r\n  out[5] -= tmp3;\r\n  out[6] -= tmp2;\r\n  out[7] -= tmp1;\r\n\r\n  tmp0 = in[6 * stride];\r\n  tmp1 = kIDCTMatrix[ 6] * tmp0;\r\n  tmp2 = kIDCTMatrix[14] * tmp0;\r\n  out[0] += tmp1;\r\n  out[1] += tmp2;\r\n  out[2] -= tmp2;\r\n  out[3] -= tmp1;\r\n  out[4] -= tmp1;\r\n  out[5] -= tmp2;\r\n  out[6] += tmp2;\r\n  out[7] += tmp1;\r\n\r\n  tmp0 = in[7 * stride];\r\n  tmp1 = kIDCTMatrix[ 7] * tmp0;\r\n  tmp2 = kIDCTMatrix[15] * tmp0;\r\n  tmp3 = kIDCTMatrix[23] * tmp0;\r\n  tmp4 = kIDCTMatrix[31] * tmp0;\r\n  out[0] += tmp1;\r\n  out[1] += tmp2;\r\n  out[2] += tmp3;\r\n  out[3] += tmp4;\r\n  out[4] -= tmp4;\r\n  out[5] -= tmp3;\r\n  out[6] -= tmp2;\r\n  out[7] -= tmp1;\r\n}\r\n\r\nvoid ComputeBlockIDCT(const coeff_t* block, uint8_t* out) {\r\n  coeff_t colidcts[kDCTBlockSize];\r\n  const int kColScale = 11;\r\n  const int kColRound = 1 << (kColScale - 1);\r\n  for (int x = 0; x < 8; ++x) {\r\n    int colbuf[8] = { 0 };\r\n    Compute1dIDCT(&block[x], 8, colbuf);\r\n    for (int y = 0; y < 8; ++y) {\r\n      colidcts[8 * y + x] = (colbuf[y] + kColRound) >> kColScale;\r\n    }\r\n  }\r\n  const int kRowScale = 18;\r\n  const int kRowRound = 257 << (kRowScale - 1);  // includes offset by 128\r\n  for (int y = 0; y < 8; ++y) {\r\n    const int rowidx = 8 * y;\r\n    int rowbuf[8] = { 0 };\r\n    Compute1dIDCT(&colidcts[rowidx], 1, rowbuf);\r\n    for (int x = 0; x < 8; ++x) {\r\n      out[rowidx + x] =\r\n          std::max(0, std::min(255, (rowbuf[x] + kRowRound) >> kRowScale));\r\n    }\r\n  }\r\n}\r\n\r\n}  // namespace guetzli\r\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, \n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, \n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi );               // C++17\n\ntemplate<class T, class Compare>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi, Compare comp ); // C++17\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);   // constexpr in C++14\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);   // constexpr in C++14\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility> // needed to provide swap_ranges.\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            _LIBCPP_ASSERT(!__comp_(__y, __x), \"Comparator does not induce a strict weak ordering\");\n        return __r;\n    }\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return _LIBCPP_EXPLICIT_MOVE(__f);  // explicitly moved for (emulated) C++03\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1, \n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, \n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, \n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred, \n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, \n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2, \n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\npair<_ForwardIterator1, _ForwardIterator1>\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return make_pair(__first1, __first1);  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return make_pair(__first1, __m1);\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return make_pair(__last1, __last1);\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 \npair<_RandomAccessIterator1, _RandomAccessIterator1>\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    const _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return make_pair(__first1, __first1);\n    const _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return make_pair(__last1, __last1);\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n#if !_LIBCPP_UNROLL_LOOPS\n        while (true)\n        {\n            if (__first1 == __s)\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        for (_D1 __loop_unroll = (__s - __first1) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (__pred(*__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            ++__first1;\n        }\n        switch (__s - __first1)\n        {\n        case 3:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 2:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 1:\n            if (__pred(*__first1, *__first2))\n                break;\n        case 0:\n            return make_pair(__last1, __last1);\n        }\n    __phase2:\n#endif  // !_LIBCPP_UNROLL_LOOPS\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n#if !_LIBCPP_UNROLL_LOOPS\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return make_pair(__first1, __first1 + __len2);\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        ++__m2;\n        ++__m1;\n        for (_D2 __loop_unroll = (__last2 - __m2) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (!__pred(*__m1, *__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            ++__m1;\n            ++__m2;\n        }\n        switch (__last2 - __m2)\n        {\n        case 3:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 2:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 1:\n            if (!__pred(*__m1, *__m2))\n                break;\n        case 0:\n            return make_pair(__first1, __first1 + __len2);\n        }\n    __continue:\n        ++__first1;\n#endif  // !_LIBCPP_UNROLL_LOOPS\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category())\n            .first;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __convert_to_integral(__count), __value_, __pred,\n           typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __convert_to_integral(__count),\n                           __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __convert_to_integral(__n), __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        _VSTD::iter_swap(__first, __last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            _VSTD::iter_swap(__first, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n// clamp\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)\n{\n    _LIBCPP_ASSERT(!__comp(__hi, __lo), \"Bad bounds passed to std::clamp\");\n    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;\n\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)\n{\n    return _VSTD::clamp(__v, __lo, __hi, __less<_Tp>());\n}\n#endif\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result(*__first, *__first);\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n    \n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(*__first, __prev)) {\n            if ( __comp(*__first, __result.first)) __result.first  = *__first;\n            if (!__comp(__prev, __result.second))  __result.second = __prev;\n            }\n        else {\n            if ( __comp(__prev, __result.first))    __result.first  = __prev;\n            if (!__comp(*__first, __result.second)) __result.second = *__first;\n            }\n                \n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    if ( __first == __last )\n        return true;\n    ++__first;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2,\n          class _OutputIterator>\nvoid __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2,\n                          _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            _VSTD::move(__first1, __last1, __result);\n            return;\n        }\n\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    // __first2 through __last2 are already in the right spot.\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __half_inplace_merge(_Rv(__p), _Rv(__buff), \n                             _RBi(__middle), _RBi(__first),\n                             _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n            return __buffered_inplace_merge<_Compare>\n                   (__first, __middle, __last, __comp, __len1, __len2, __buff);\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, (void) --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);\n\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, (void) ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/dct_double.h\"\r\n\r\n#include <algorithm>\r\n#include <cmath>\r\n\r\nnamespace guetzli {\r\n\r\nnamespace {\r\n\r\n// kDCTMatrix[8*u+x] = 0.5*alpha(u)*cos((2*x+1)*u*M_PI/16),\r\n// where alpha(0) = 1/sqrt(2) and alpha(u) = 1 for u > 0.\r\nstatic const double kDCTMatrix[64] = {\r\n  0.3535533906,  0.3535533906,  0.3535533906,  0.3535533906,\r\n  0.3535533906,  0.3535533906,  0.3535533906,  0.3535533906,\r\n  0.4903926402,  0.4157348062,  0.2777851165,  0.0975451610,\r\n -0.0975451610, -0.2777851165, -0.4157348062, -0.4903926402,\r\n  0.4619397663,  0.1913417162, -0.1913417162, -0.4619397663,\r\n -0.4619397663, -0.1913417162,  0.1913417162,  0.4619397663,\r\n  0.4157348062, -0.0975451610, -0.4903926402, -0.2777851165,\r\n  0.2777851165,  0.4903926402,  0.0975451610, -0.4157348062,\r\n  0.3535533906, -0.3535533906, -0.3535533906,  0.3535533906,\r\n  0.3535533906, -0.3535533906, -0.3535533906,  0.3535533906,\r\n  0.2777851165, -0.4903926402,  0.0975451610,  0.4157348062,\r\n -0.4157348062, -0.0975451610,  0.4903926402, -0.2777851165,\r\n  0.1913417162, -0.4619397663,  0.4619397663, -0.1913417162,\r\n -0.1913417162,  0.4619397663, -0.4619397663,  0.1913417162,\r\n  0.0975451610, -0.2777851165,  0.4157348062, -0.4903926402,\r\n  0.4903926402, -0.4157348062,  0.2777851165, -0.0975451610,\r\n};\r\n\r\nvoid DCT1d(const double* in, int stride, double* out) {\r\n  for (int x = 0; x < 8; ++x) {\r\n    out[x * stride] = 0.0;\r\n    for (int u = 0; u < 8; ++u) {\r\n      out[x * stride] += kDCTMatrix[8 * x + u] * in[u * stride];\r\n    }\r\n  }\r\n}\r\n\r\nvoid IDCT1d(const double* in, int stride, double* out) {\r\n  for (int x = 0; x < 8; ++x) {\r\n    out[x * stride] = 0.0;\r\n    for (int u = 0; u < 8; ++u) {\r\n      out[x * stride] += kDCTMatrix[8 * u + x] * in[u * stride];\r\n    }\r\n  }\r\n}\r\n\r\ntypedef void (*Transform1d)(const double* in, int stride, double* out);\r\n\r\nvoid TransformBlock(double block[64], Transform1d f) {\r\n  double tmp[64];\r\n  for (int x = 0; x < 8; ++x) {\r\n    f(&block[x], 8, &tmp[x]);\r\n  }\r\n  for (int y = 0; y < 8; ++y) {\r\n    f(&tmp[8 * y], 1, &block[8 * y]);\r\n  }\r\n}\r\n\r\n}  // namespace\r\n\r\nvoid ComputeBlockDCTDouble(double block[64]) {\r\n  TransformBlock(block, DCT1d);\r\n}\r\n\r\nvoid ComputeBlockIDCTDouble(double block[64]) {\r\n  TransformBlock(block, IDCT1d);\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/gamma_correct.h\"\r\n\r\n#include <cmath>\r\n\r\nnamespace guetzli {\r\n\r\nconst double* NewSrgb8ToLinearTable() {\r\n  double* table = new double[256];\r\n  int i = 0;\r\n  for (; i < 11; ++i) {\r\n    table[i] = i / 12.92;\r\n  }\r\n  for (; i < 256; ++i) {\r\n    table[i] = 255.0 * std::pow(((i / 255.0) + 0.055) / 1.055, 2.4);\r\n  }\r\n  return table;\r\n}\r\n\r\nconst double* Srgb8ToLinearTable() {\r\n  static const double* const kSrgb8ToLinearTable = NewSrgb8ToLinearTable();\r\n  return kSrgb8ToLinearTable;\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/preprocess_downsample.h\"\r\n\r\n#include <algorithm>\r\n#include <assert.h>\r\n#include <string.h>\r\n#include <cmath>\r\n\r\nusing std::size_t;\r\n\r\nnamespace {\r\n\r\n// convolve with size*size kernel\r\nstd::vector<float> Convolve2D(const std::vector<float>& image, int w, int h,\r\n                              const double* kernel, int size) {\r\n  auto result = image;\r\n  int size2 = size / 2;\r\n  for (int i = 0; i < image.size(); i++) {\r\n    int x = i % w;\r\n    int y = i / w;\r\n    // Avoid non-normalized results at boundary by skipping edges.\r\n    if (x < size2 || x + size - size2 - 1 >= w\r\n        || y < size2 || y + size - size2 - 1 >= h) {\r\n      continue;\r\n    }\r\n    float v = 0;\r\n    for (int j = 0; j < size * size; j++) {\r\n      int x2 = x + j % size - size2;\r\n      int y2 = y + j / size - size2;\r\n      v += kernel[j] * image[y2 * w + x2];\r\n    }\r\n    result[i] = v;\r\n  }\r\n  return result;\r\n}\r\n\r\n// convolve horizontally and vertically with 1D kernel\r\nstd::vector<float> Convolve2X(const std::vector<float>& image, int w, int h,\r\n                              const double* kernel, int size, double mul) {\r\n  auto temp = image;\r\n  int size2 = size / 2;\r\n  for (int i = 0; i < image.size(); i++) {\r\n    int x = i % w;\r\n    int y = i / w;\r\n    // Avoid non-normalized results at boundary by skipping edges.\r\n    if (x < size2 || x + size - size2 - 1 >= w) continue;\r\n    float v = 0;\r\n    for (int j = 0; j < size; j++) {\r\n      int x2 = x + j - size2;\r\n      v += kernel[j] * image[y * w + x2];\r\n    }\r\n    temp[i] = v * mul;\r\n  }\r\n  auto result = temp;\r\n  for (int i = 0; i < temp.size(); i++) {\r\n    int x = i % w;\r\n    int y = i / w;\r\n    // Avoid non-normalized results at boundary by skipping edges.\r\n    if (y < size2 || y + size - size2 - 1 >= h) continue;\r\n    float v = 0;\r\n    for (int j = 0; j < size; j++) {\r\n      int y2 = y + j - size2;\r\n      v += kernel[j] * temp[y2 * w + x];\r\n    }\r\n    result[i] = v * mul;\r\n  }\r\n  return result;\r\n}\r\n\r\ndouble Normal(double x, double sigma) {\r\n  static const double kInvSqrt2Pi = 0.3989422804014327;\r\n  return std::exp(-x * x / (2 * sigma * sigma)) * kInvSqrt2Pi / sigma;\r\n}\r\n\r\nstd::vector<float> Sharpen(const std::vector<float>& image, int w, int h,\r\n                           float sigma, float amount) {\r\n  // This is only made for small sigma, e.g. 1.3.\r\n  std::vector<double> kernel(5);\r\n  for (int i = 0; i < kernel.size(); i++) {\r\n    kernel[i] = Normal(1.0 * i - kernel.size() / 2, sigma);\r\n  }\r\n\r\n  double sum = 0;\r\n  for (int i = 0; i < kernel.size(); i++) sum += kernel[i];\r\n  const double mul = 1.0 / sum;\r\n\r\n  std::vector<float> result =\r\n      Convolve2X(image, w, h, kernel.data(), kernel.size(), mul);\r\n  for (size_t i = 0; i < image.size(); i++) {\r\n    result[i] = image[i] + (image[i] - result[i]) * amount;\r\n  }\r\n  return result;\r\n}\r\n\r\nvoid Erode(int w, int h, std::vector<bool>* image) {\r\n  std::vector<bool> temp = *image;\r\n  for (int y = 1; y + 1 < h; y++) {\r\n    for (int x = 1; x + 1 < w; x++) {\r\n      size_t index = y * w + x;\r\n      if (!(temp[index] && temp[index - 1] && temp[index + 1]\r\n          && temp[index - w] && temp[index + w])) {\r\n        (*image)[index] = 0;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid Dilate(int w, int h, std::vector<bool>* image) {\r\n  std::vector<bool> temp = *image;\r\n  for (int y = 1; y + 1 < h; y++) {\r\n    for (int x = 1; x + 1 < w; x++) {\r\n      size_t index = y * w + x;\r\n      if (temp[index] || temp[index - 1] || temp[index + 1]\r\n          || temp[index - w] || temp[index + w]) {\r\n        (*image)[index] = 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nstd::vector<float> Blur(const std::vector<float>& image, int w, int h) {\r\n    // This is only made for small sigma, e.g. 1.3.\r\n    static const double kSigma = 1.3;\r\n    std::vector<double> kernel(5);\r\n    for (int i = 0; i < kernel.size(); i++) {\r\n      kernel[i] = Normal(1.0 * i - kernel.size() / 2, kSigma);\r\n    }\r\n\r\n    double sum = 0;\r\n    for (int i = 0; i < kernel.size(); i++) sum += kernel[i];\r\n    const double mul = 1.0 / sum;\r\n\r\n    return Convolve2X(image, w, h, kernel.data(), kernel.size(), mul);\r\n}\r\n\r\n}  // namespace\r\n\r\nnamespace guetzli {\r\n\r\n// Do the sharpening to the v channel, but only in areas where it will help\r\n// channel should be 2 for v sharpening, or 1 for less effective u sharpening\r\nstd::vector<std::vector<float>> PreProcessChannel(\r\n    int w, int h, int channel, float sigma, float amount, bool blur,\r\n    bool sharpen, const std::vector<std::vector<float>>& image) {\r\n  if (!blur && !sharpen) return image;\r\n\r\n  // Bring in range 0.0-1.0 for Y, -0.5 - 0.5 for U and V\r\n  auto yuv = image;\r\n  for (int i = 0; i < yuv[0].size(); i++) {\r\n    yuv[0][i] /= 255.0;\r\n    yuv[1][i] = yuv[1][i] / 255.0 - 0.5;\r\n    yuv[2][i] = yuv[2][i] / 255.0 - 0.5;\r\n  }\r\n\r\n  // Map of areas where the image is not too bright to apply the effect.\r\n  std::vector<bool> darkmap(image[0].size(), false);\r\n  for (int y = 0; y < h; y++) {\r\n    for (int x = 0; x < w; x++) {\r\n      size_t index = y * w + x;\r\n      float y = yuv[0][index];\r\n      float u = yuv[1][index];\r\n      float v = yuv[2][index];\r\n\r\n      float r = y + 1.402 * v;\r\n      float g = y - 0.34414 * u - 0.71414 * v;\r\n      float b = y + 1.772 * u;\r\n\r\n      // Parameters tuned to avoid sharpening in too bright areas, where the\r\n      // effect makes it worse instead of better.\r\n      if (channel == 2 && g < 0.85 && b < 0.85 && r < 0.9) {\r\n        darkmap[index] = true;\r\n      }\r\n      if (channel == 1 && r < 0.85 && g < 0.85 && b < 0.9) {\r\n        darkmap[index] = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  Erode(w, h, &darkmap);\r\n  Erode(w, h, &darkmap);\r\n  Erode(w, h, &darkmap);\r\n\r\n  // Map of areas where the image is red enough (blue in case of u channel).\r\n  std::vector<bool> redmap(image[0].size(), false);\r\n  for (int y = 0; y < h; y++) {\r\n    for (int x = 0; x < w; x++) {\r\n      size_t index = y * w + x;\r\n      float u = yuv[1][index];\r\n      float v = yuv[2][index];\r\n\r\n      // Parameters tuned to allow only colors on which sharpening is useful.\r\n      if (channel == 2 && 2.116 * v > -0.34414 * u + 0.2\r\n          && 1.402 * v > 1.772 * u + 0.2) {\r\n        redmap[index] = true;\r\n      }\r\n      if (channel == 1 && v < 1.263 * u - 0.1 && u > -0.33741 * v) {\r\n        redmap[index] = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  Dilate(w, h, &redmap);\r\n  Dilate(w, h, &redmap);\r\n  Dilate(w, h, &redmap);\r\n\r\n  // Map of areas where to allow sharpening by combining red and dark areas\r\n  std::vector<bool> sharpenmap(image[0].size(), 0);\r\n  for (int y = 0; y < h; y++) {\r\n    for (int x = 0; x < w; x++) {\r\n      size_t index = y * w + x;\r\n      sharpenmap[index] = redmap[index] && darkmap[index];\r\n    }\r\n  }\r\n\r\n  // Threshold for where considered an edge.\r\n  const double threshold = (channel == 2 ? 0.02 : 1.0) * 127.5;\r\n\r\n  static const double kEdgeMatrix[9] = {\r\n    0, -1, 0,\r\n    -1, 4, -1,\r\n    0, -1, 0\r\n  };\r\n\r\n  // Map of areas where to allow blurring, only where it is not too sharp\r\n  std::vector<bool> blurmap(image[0].size(), false);\r\n  std::vector<float> edge = Convolve2D(yuv[channel], w, h, kEdgeMatrix, 3);\r\n  for (int y = 0; y < h; y++) {\r\n    for (int x = 0; x < w; x++) {\r\n      size_t index = y * w + x;\r\n      float u = yuv[1][index];\r\n      float v = yuv[2][index];\r\n      if (sharpenmap[index]) continue;\r\n      if (!darkmap[index]) continue;\r\n      if (fabs(edge[index]) < threshold && v < -0.162 * u) {\r\n        blurmap[index] = true;\r\n      }\r\n    }\r\n  }\r\n  Erode(w, h, &blurmap);\r\n  Erode(w, h, &blurmap);\r\n\r\n  // Choose sharpened, blurred or original per pixel\r\n  std::vector<float> sharpened = Sharpen(yuv[channel], w, h, sigma, amount);\r\n  std::vector<float> blurred = Blur(yuv[channel], w, h);\r\n  for (int y = 0; y < h; y++) {\r\n    for (int x = 0; x < w; x++) {\r\n      size_t index = y * w + x;\r\n\r\n      if (sharpenmap[index] > 0) {\r\n        if (sharpen) yuv[channel][index] = sharpened[index];\r\n      } else if (blurmap[index] > 0) {\r\n        if (blur) yuv[channel][index] = blurred[index];\r\n      }\r\n    }\r\n  }\r\n\r\n  // Bring back to range 0-255\r\n  for (int i = 0; i < yuv[0].size(); i++) {\r\n    yuv[0][i] *= 255.0;\r\n    yuv[1][i] = (yuv[1][i] + 0.5) * 255.0;\r\n    yuv[2][i] = (yuv[2][i] + 0.5) * 255.0;\r\n  }\r\n  return yuv;\r\n}\r\n\r\nnamespace {\r\n\r\ninline float Clip(float val) {\r\n  return std::max(0.0f, std::min(255.0f, val));\r\n}\r\n\r\ninline float RGBToY(float r, float g, float b) {\r\n  return 0.299f * r + 0.587f * g + 0.114f * b;\r\n}\r\n\r\ninline float RGBToU(float r, float g, float b) {\r\n  return -0.16874f * r - 0.33126f * g + 0.5f * b + 128.0;\r\n}\r\n\r\ninline float RGBToV(float r, float g, float b) {\r\n  return 0.5f * r - 0.41869f * g - 0.08131f * b + 128.0;\r\n}\r\n\r\ninline float YUVToR(float y, float u, float v) {\r\n  return y + 1.402 * (v - 128.0);\r\n}\r\n\r\ninline float YUVToG(float y, float u, float v) {\r\n  return y - 0.344136 * (u - 128.0) - 0.714136 * (v - 128.0);\r\n}\r\n\r\ninline float YUVToB(float y, float u, float v) {\r\n  return y + 1.772 * (u - 128.0);\r\n}\r\n\r\n// TODO(user) Use SRGB->linear conversion and a lookup-table.\r\ninline float GammaToLinear(float x) {\r\n  return std::pow(x / 255.0, 2.2);\r\n}\r\n\r\n// TODO(user) Use linear->SRGB conversion and a lookup-table.\r\ninline float LinearToGamma(float x) {\r\n  return 255.0 * std::pow(x, 1.0 / 2.2);\r\n}\r\n\r\nstd::vector<float> LinearlyAveragedLuma(const std::vector<float>& rgb) {\r\n  assert(rgb.size() % 3 == 0);\r\n  std::vector<float> y(rgb.size() / 3);\r\n  for (int i = 0, p = 0; p < rgb.size(); ++i, p += 3) {\r\n    y[i] = LinearToGamma(RGBToY(GammaToLinear(rgb[p + 0]),\r\n                                GammaToLinear(rgb[p + 1]),\r\n                                GammaToLinear(rgb[p + 2])));\r\n  }\r\n  return y;\r\n}\r\n\r\nstd::vector<float> LinearlyDownsample2x2(const std::vector<float>& rgb_in,\r\n                                         const int width, const int height) {\r\n  assert(rgb_in.size() == 3 * width * height);\r\n  int w = (width + 1) / 2;\r\n  int h = (height + 1) / 2;\r\n  std::vector<float> rgb_out(3 * w * h);\r\n  for (int y = 0, p = 0; y < h; ++y) {\r\n    for (int x = 0; x < w; ++x) {\r\n      for (int i = 0; i < 3; ++i, ++p) {\r\n        rgb_out[p] = 0.0;\r\n        for (int iy = 0; iy < 2; ++iy) {\r\n          for (int ix = 0; ix < 2; ++ix) {\r\n            int yy = std::min(height - 1, 2 * y + iy);\r\n            int xx = std::min(width - 1, 2 * x + ix);\r\n            rgb_out[p] += GammaToLinear(rgb_in[3 * (yy * width + xx) + i]);\r\n          }\r\n        }\r\n        rgb_out[p] = LinearToGamma(0.25 * rgb_out[p]);\r\n      }\r\n    }\r\n  }\r\n  return rgb_out;\r\n}\r\n\r\nstd::vector<std::vector<float> > RGBToYUV(const std::vector<float>& rgb) {\r\n  std::vector<std::vector<float> > yuv(3, std::vector<float>(rgb.size() / 3));\r\n  for (int i = 0, p = 0; p < rgb.size(); ++i, p += 3) {\r\n    const float r = rgb[p + 0];\r\n    const float g = rgb[p + 1];\r\n    const float b = rgb[p + 2];\r\n    yuv[0][i] = RGBToY(r, g, b);\r\n    yuv[1][i] = RGBToU(r, g, b);\r\n    yuv[2][i] = RGBToV(r, g, b);\r\n  }\r\n  return yuv;\r\n}\r\n\r\nstd::vector<float> YUVToRGB(const std::vector<std::vector<float> >& yuv) {\r\n  std::vector<float> rgb(3 * yuv[0].size());\r\n  for (int i = 0, p = 0; p < rgb.size(); ++i, p += 3) {\r\n    const float y = yuv[0][i];\r\n    const float u = yuv[1][i];\r\n    const float v = yuv[2][i];\r\n    rgb[p + 0] = Clip(YUVToR(y, u, v));\r\n    rgb[p + 1] = Clip(YUVToG(y, u, v));\r\n    rgb[p + 2] = Clip(YUVToB(y, u, v));\r\n  }\r\n  return rgb;\r\n}\r\n\r\n// Upsamples img_in with a box-filter, and returns an image with output\r\n// dimensions width x height.\r\nstd::vector<float> Upsample2x2(const std::vector<float>& img_in,\r\n                               const int width, const int height) {\r\n  int w = (width + 1) / 2;\r\n  int h = (height + 1) / 2;\r\n  assert(img_in.size() == w * h);\r\n  std::vector<float> img_out(width * height);\r\n  for (int y = 0, p = 0; y < h; ++y) {\r\n    for (int x = 0; x < w; ++x, ++p) {\r\n      for (int iy = 0; iy < 2; ++iy) {\r\n        for (int ix = 0; ix < 2; ++ix) {\r\n          int yy = std::min(height - 1, 2 * y + iy);\r\n          int xx = std::min(width - 1, 2 * x + ix);\r\n          img_out[yy * width + xx] = img_in[p];\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return img_out;\r\n}\r\n\r\n// Apply the \"fancy upsample\" filter used by libjpeg.\r\nstd::vector<float> Blur(const std::vector<float>& img,\r\n                        const int width, const int height) {\r\n  std::vector<float> img_out(width * height);\r\n  for (int y0 = 0; y0 < height; y0 += 2) {\r\n    for (int x0 = 0; x0 < width; x0 += 2) {\r\n      for (int iy = 0; iy < 2 && y0 + iy < height; ++iy) {\r\n        for (int ix = 0; ix < 2 && x0 + ix < width; ++ix) {\r\n          int dy = 4 * iy - 2;\r\n          int dx = 4 * ix - 2;\r\n          int x1 = std::min(width - 1, std::max(0, x0 + dx));\r\n          int y1 = std::min(height - 1, std::max(0, y0 + dy));\r\n          img_out[(y0 + iy) * width + x0 + ix] =\r\n              (9.0 * img[y0 * width + x0] +\r\n               3.0 * img[y0 * width + x1] +\r\n               3.0 * img[y1 * width + x0] +\r\n               1.0 * img[y1 * width + x1]) / 16.0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return img_out;\r\n}\r\n\r\nstd::vector<float> YUV420ToRGB(const std::vector<std::vector<float> >& yuv420,\r\n                               const int width, const int height) {\r\n  std::vector<std::vector<float> > yuv;\r\n  yuv.push_back(yuv420[0]);\r\n  std::vector<float> u = Upsample2x2(yuv420[1], width, height);\r\n  std::vector<float> v = Upsample2x2(yuv420[2], width, height);\r\n  yuv.push_back(Blur(u, width, height));\r\n  yuv.push_back(Blur(v, width, height));\r\n  return YUVToRGB(yuv);\r\n}\r\n\r\nvoid UpdateGuess(const std::vector<float>& target,\r\n                 const std::vector<float>& reconstructed,\r\n                 std::vector<float>* guess) {\r\n  assert(reconstructed.size() == guess->size());\r\n  assert(target.size() == guess->size());\r\n  for (int i = 0; i < guess->size(); ++i) {\r\n    // TODO(user): Evaluate using a decaying constant here.\r\n    (*guess)[i] = Clip((*guess)[i] - (reconstructed[i] - target[i]));\r\n  }\r\n}\r\n\r\n}  // namespace\r\n\r\nstd::vector<std::vector<float> > RGBToYUV420(\r\n    const std::vector<uint8_t>& rgb_in, const int width, const int height) {\r\n  std::vector<float> rgbf(rgb_in.size());\r\n  for (int i = 0; i < rgb_in.size(); ++i) {\r\n    rgbf[i] = static_cast<float>(rgb_in[i]);\r\n  }\r\n  std::vector<float> y_target = LinearlyAveragedLuma(rgbf);\r\n  std::vector<std::vector<float> > yuv_target =\r\n      RGBToYUV(LinearlyDownsample2x2(rgbf, width, height));\r\n  std::vector<std::vector<float> > yuv_guess = yuv_target;\r\n  yuv_guess[0] = Upsample2x2(yuv_guess[0], width, height);\r\n  // TODO(user): Stop early if the error is small enough.\r\n  for (int iter = 0; iter < 20; ++iter) {\r\n    std::vector<float> rgb_rec = YUV420ToRGB(yuv_guess, width, height);\r\n    std::vector<float> y_rec = LinearlyAveragedLuma(rgb_rec);\r\n    std::vector<std::vector<float> > yuv_rec =\r\n        RGBToYUV(LinearlyDownsample2x2(rgb_rec, width, height));\r\n    UpdateGuess(y_target, y_rec, &yuv_guess[0]);\r\n    UpdateGuess(yuv_target[1], yuv_rec[1], &yuv_guess[1]);\r\n    UpdateGuess(yuv_target[2], yuv_rec[2], &yuv_guess[2]);\r\n  }\r\n  yuv_guess[1] = Upsample2x2(yuv_guess[1], width, height);\r\n  yuv_guess[2] = Upsample2x2(yuv_guess[2], width, height);\r\n  return yuv_guess;\r\n}\r\n\r\n}  // namespace guetzli\r\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> void emplace_back(Args&&... args);  // C++14\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declaration of vector\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"vector\");\n#else\n    assert(!\"vector length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"vector\");\n#else\n    assert(!\"vector out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator /* = allocator<_Tp> */>\nclass _LIBCPP_TYPE_VIS_ONLY vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void emplace_back(_Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n    void __annotate_contiguous_container\n    (const void *__beg, const void *__end, const void *__old_mid, const void *__new_mid) const\n    {\n#ifndef _LIBCPP_HAS_NO_ASAN\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n#endif\n    }\n\n    void __annotate_new(size_type __current_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n    void __annotate_delete() const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __old_size(__v.size() + __n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__old_size);\n      }\n      bool __commit;\n      const vector &__v;\n      size_type __old_size;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      inline __RAII_IncreaseAnnotator(const vector &, size_type __n = 1) {}\n      inline void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<size_type>::max() / 2);  // end() >= begin(), always\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    __RAII_IncreaseAnnotator __annotator(*this, __n);\n    __alloc_traits::__construct_range_forward(__a, __first, __last, this->__end_);\n    __annotator.__done();\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __new_size = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__new_size <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (__new_size > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last, __new_size - size());\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(__new_size));\n        __construct_at_end(__first, __last, __new_size);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline\nvoid\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    iterator __r = __make_iter(__p);\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    iterator __r = __make_iter(__p);\n    if (__first != __last)\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            value_type __tmp(_VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n        __annotator.__done();\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                difference_type __diff = this->__end_ - __p;\n                _VSTD::advance(__m, __diff);\n                __construct_at_end(__m, __last, __n - __diff);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY void emplace_back(_Args&&... __args)\n        { push_back ( value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n    static void swap(reference __x, reference __y) _NOEXCEPT { _VSTD::swap(__x, __y); }\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TYPE_VIS_ONLY hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    difference_type __n = _VSTD::distance(__first, __last);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___BIT_REFERENCE\n#define _LIBCPP___BIT_REFERENCE\n\n#include <__config>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;\ntemplate <class _Cp> class __bit_const_reference;\n\ntemplate <class _Tp>\nstruct __has_storage_type\n{\n    static const bool value = false;\n};\n\ntemplate <class _Cp, bool = __has_storage_type<_Cp>::value>\nclass __bit_reference\n{\n    typedef typename _Cp::__storage_type    __storage_type;\n    typedef typename _Cp::__storage_pointer __storage_pointer;\n\n    __storage_pointer __seg_;\n    __storage_type    __mask_;\n\n#if defined(__clang__) || defined(__IBMCPP__) || defined(_LIBCPP_MSVC)\n    friend typename _Cp::__self;\n#else\n    friend class _Cp::__self;\n#endif\n    friend class __bit_const_reference<_Cp>;\n    friend class __bit_iterator<_Cp, false>;\npublic:\n    _LIBCPP_INLINE_VISIBILITY operator bool() const _NOEXCEPT\n        {return static_cast<bool>(*__seg_ & __mask_);}\n    _LIBCPP_INLINE_VISIBILITY bool operator ~() const _NOEXCEPT\n        {return !static_cast<bool>(*this);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_reference& operator=(bool __x) _NOEXCEPT\n    {\n        if (__x)\n            *__seg_ |= __mask_;\n        else\n            *__seg_ &= ~__mask_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_reference& operator=(const __bit_reference& __x) _NOEXCEPT\n        {return operator=(static_cast<bool>(__x));}\n\n    _LIBCPP_INLINE_VISIBILITY void flip() _NOEXCEPT {*__seg_ ^= __mask_;}\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator<_Cp, false> operator&() const _NOEXCEPT\n        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_reference(__storage_pointer __s, __storage_type __m) _NOEXCEPT\n        : __seg_(__s), __mask_(__m) {}\n};\n\ntemplate <class _Cp>\nclass __bit_reference<_Cp, false>\n{\n};\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) _NOEXCEPT\n{\n    bool __t = __x;\n    __x = __y;\n    __y = __t;\n}\n\ntemplate <class _Cp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) _NOEXCEPT\n{\n    bool __t = __x;\n    __x = __y;\n    __y = __t;\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__bit_reference<_Cp> __x, bool& __y) _NOEXCEPT\n{\n    bool __t = __x;\n    __x = __y;\n    __y = __t;\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(bool& __x, __bit_reference<_Cp> __y) _NOEXCEPT\n{\n    bool __t = __x;\n    __x = __y;\n    __y = __t;\n}\n\ntemplate <class _Cp>\nclass __bit_const_reference\n{\n    typedef typename _Cp::__storage_type          __storage_type;\n    typedef typename _Cp::__const_storage_pointer __storage_pointer;\n\n    __storage_pointer        __seg_;\n    __storage_type __mask_;\n\n#if defined(__clang__) || defined(__IBMCPP__) || defined(_LIBCPP_MSVC)\n    friend typename _Cp::__self;\n#else\n    friend class _Cp::__self;\n#endif\n    friend class __bit_iterator<_Cp, true>;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_const_reference(const __bit_reference<_Cp>& __x) _NOEXCEPT\n        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR operator bool() const _NOEXCEPT\n        {return static_cast<bool>(*__seg_ & __mask_);}\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator<_Cp, true> operator&() const _NOEXCEPT\n        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR\n    __bit_const_reference(__storage_pointer __s, __storage_type __m) _NOEXCEPT\n        : __seg_(__s), __mask_(__m) {}\n\n    __bit_const_reference& operator=(const __bit_const_reference& __x);\n};\n\n// find\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, _IsConst>\n__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _It;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        __storage_type __b = *__first.__seg_ & __m;\n        if (__b)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));\n        if (__n == __dn)\n            return __first + __n;\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)\n        if (*__first.__seg_)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(*__first.__seg_)));\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__first.__seg_ & __m;\n        if (__b)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));\n    }\n    return _It(__first.__seg_, static_cast<unsigned>(__n));\n}\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, _IsConst>\n__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _It;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        __storage_type __b = ~*__first.__seg_ & __m;\n        if (__b)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));\n        if (__n == __dn)\n            return __first + __n;\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)\n    {\n        __storage_type __b = ~*__first.__seg_;\n        if (__b)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));\n    }\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = ~*__first.__seg_ & __m;\n        if (__b)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));\n    }\n    return _It(__first.__seg_, static_cast<unsigned>(__n));\n}\n\ntemplate <class _Cp, bool _IsConst, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<_Cp, _IsConst>\nfind(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)\n{\n    if (static_cast<bool>(__value_))\n        return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));\n    return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));\n}\n\n// count\n\ntemplate <class _Cp, bool _IsConst>\ntypename __bit_iterator<_Cp, _IsConst>::difference_type\n__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _It;\n    typedef typename _It::__storage_type __storage_type;\n    typedef typename _It::difference_type difference_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    difference_type __r = 0;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        __r = _VSTD::__pop_count(*__first.__seg_ & __m);\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)\n        __r += _VSTD::__pop_count(*__first.__seg_);\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __r += _VSTD::__pop_count(*__first.__seg_ & __m);\n    }\n    return __r;\n}\n\ntemplate <class _Cp, bool _IsConst>\ntypename __bit_iterator<_Cp, _IsConst>::difference_type\n__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _It;\n    typedef typename _It::__storage_type __storage_type;\n    typedef typename _It::difference_type difference_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    difference_type __r = 0;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        __r = _VSTD::__pop_count(~*__first.__seg_ & __m);\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)\n        __r += _VSTD::__pop_count(~*__first.__seg_);\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __r += _VSTD::__pop_count(~*__first.__seg_ & __m);\n    }\n    return __r;\n}\n\ntemplate <class _Cp, bool _IsConst, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bit_iterator<_Cp, _IsConst>::difference_type\ncount(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)\n{\n    if (static_cast<bool>(__value_))\n        return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));\n    return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));\n}\n\n// fill_n\n\ntemplate <class _Cp>\nvoid\n__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, false> _It;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        *__first.__seg_ &= ~__m;\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    __storage_type __nw = __n / __bits_per_word;\n    _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));\n    __n -= __nw * __bits_per_word;\n    // do last partial word\n    if (__n > 0)\n    {\n        __first.__seg_ += __nw;\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        *__first.__seg_ &= ~__m;\n    }\n}\n\ntemplate <class _Cp>\nvoid\n__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, false> _It;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        *__first.__seg_ |= __m;\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    __storage_type __nw = __n / __bits_per_word;\n    _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));\n    __n -= __nw * __bits_per_word;\n    // do last partial word\n    if (__n > 0)\n    {\n        __first.__seg_ += __nw;\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        *__first.__seg_ |= __m;\n    }\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)\n{\n    if (__n > 0)\n    {\n        if (__value_)\n            __fill_n_true(__first, __n);\n        else\n            __fill_n_false(__first, __n);\n    }\n}\n\n// fill\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)\n{\n    _VSTD::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);\n}\n\n// copy\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, false>\n__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,\n                                                     __bit_iterator<_Cp, false> __result)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _In;\n    typedef  typename _In::difference_type difference_type;\n    typedef typename _In::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _In::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first.__ctz_ != 0)\n        {\n            unsigned __clz = __bits_per_word - __first.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));\n            __storage_type __b = *__first.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b;\n            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);\n            ++__first.__seg_;\n            // __first.__ctz_ = 0;\n        }\n        // __first.__ctz_ == 0;\n        // do middle words\n        __storage_type __nw = __n / __bits_per_word;\n        _VSTD::memmove(_VSTD::__to_raw_pointer(__result.__seg_),\n                       _VSTD::__to_raw_pointer(__first.__seg_),\n                       __nw * sizeof(__storage_type));\n        __n -= __nw * __bits_per_word;\n        __result.__seg_ += __nw;\n        // do last word\n        if (__n > 0)\n        {\n            __first.__seg_ += __nw;\n            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            __storage_type __b = *__first.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b;\n            __result.__ctz_ = static_cast<unsigned>(__n);\n        }\n    }\n    return __result;\n}\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, false>\n__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,\n                                                       __bit_iterator<_Cp, false> __result)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _In;\n    typedef  typename _In::difference_type difference_type;\n    typedef typename _In::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _In::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first.__ctz_ != 0)\n        {\n            unsigned __clz_f = __bits_per_word - __first.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz_f), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n            __storage_type __b = *__first.__seg_ & __m;\n            unsigned __clz_r = __bits_per_word - __result.__ctz_;\n            __storage_type __ddn = _VSTD::min<__storage_type>(__dn, __clz_r);\n            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));\n            *__result.__seg_ &= ~__m;\n            if (__result.__ctz_ > __first.__ctz_)\n                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);\n            else\n                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);\n            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_)  % __bits_per_word);\n            __dn -= __ddn;\n            if (__dn > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __dn);\n                *__result.__seg_ &= ~__m;\n                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);\n                __result.__ctz_ = static_cast<unsigned>(__dn);\n            }\n            ++__first.__seg_;\n            // __first.__ctz_ = 0;\n        }\n        // __first.__ctz_ == 0;\n        // do middle words\n        unsigned __clz_r = __bits_per_word - __result.__ctz_;\n        __storage_type __m = ~__storage_type(0) << __result.__ctz_;\n        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)\n        {\n            __storage_type __b = *__first.__seg_;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b << __result.__ctz_;\n            ++__result.__seg_;\n            *__result.__seg_ &= __m;\n            *__result.__seg_ |= __b >> __clz_r;\n        }\n        // do last word\n        if (__n > 0)\n        {\n            __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            __storage_type __b = *__first.__seg_ & __m;\n            __storage_type __dn = _VSTD::min(__n, static_cast<difference_type>(__clz_r));\n            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b << __result.__ctz_;\n            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);\n            __n -= __dn;\n            if (__n > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __n);\n                *__result.__seg_ &= ~__m;\n                *__result.__seg_ |= __b >> __dn;\n                __result.__ctz_ = static_cast<unsigned>(__n);\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _Cp, bool _IsConst>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<_Cp, false>\ncopy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)\n{\n    if (__first.__ctz_ == __result.__ctz_)\n        return __copy_aligned(__first, __last, __result);\n    return __copy_unaligned(__first, __last, __result);\n}\n\n// copy_backward\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, false>\n__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,\n                                                     __bit_iterator<_Cp, false> __result)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _In;\n    typedef  typename _In::difference_type difference_type;\n    typedef typename _In::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _In::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__last.__ctz_ != 0)\n        {\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__last.__ctz_), __n);\n            __n -= __dn;\n            unsigned __clz = __bits_per_word - __last.__ctz_;\n            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);\n            __storage_type __b = *__last.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b;\n            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +\n                                                       __result.__ctz_)  % __bits_per_word);\n            // __last.__ctz_ = 0\n         }\n        // __last.__ctz_ == 0 || __n == 0\n        // __result.__ctz_ == 0 || __n == 0\n        // do middle words\n        __storage_type __nw = __n / __bits_per_word;\n        __result.__seg_ -= __nw;\n        __last.__seg_ -= __nw;\n        _VSTD::memmove(_VSTD::__to_raw_pointer(__result.__seg_),\n                       _VSTD::__to_raw_pointer(__last.__seg_),\n                       __nw * sizeof(__storage_type));\n        __n -= __nw * __bits_per_word;\n        // do last word\n        if (__n > 0)\n        {\n            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);\n            __storage_type __b = *--__last.__seg_ & __m;\n            *--__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b;\n            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));\n        }\n    }\n    return __result;\n}\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, false>\n__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,\n                                                       __bit_iterator<_Cp, false> __result)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _In;\n    typedef  typename _In::difference_type difference_type;\n    typedef typename _In::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _In::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__last.__ctz_ != 0)\n        {\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__last.__ctz_), __n);\n            __n -= __dn;\n            unsigned __clz_l = __bits_per_word - __last.__ctz_;\n            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);\n            __storage_type __b = *__last.__seg_ & __m;\n            unsigned __clz_r = __bits_per_word - __result.__ctz_;\n            __storage_type __ddn = _VSTD::min(__dn, static_cast<difference_type>(__result.__ctz_));\n            if (__ddn > 0)\n            {\n                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);\n                *__result.__seg_ &= ~__m;\n                if (__result.__ctz_ > __last.__ctz_)\n                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);\n                else\n                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);\n                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +\n                                                         __result.__ctz_)  % __bits_per_word);\n                __dn -= __ddn;\n            }\n            if (__dn > 0)\n            {\n                // __result.__ctz_ == 0\n                --__result.__seg_;\n                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));\n                __m = ~__storage_type(0) << __result.__ctz_;\n                *__result.__seg_ &= ~__m;\n                __last.__ctz_ -= __dn + __ddn;\n                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);\n            }\n            // __last.__ctz_ = 0\n         }\n        // __last.__ctz_ == 0 || __n == 0\n        // __result.__ctz_ != 0 || __n == 0\n        // do middle words\n        unsigned __clz_r = __bits_per_word - __result.__ctz_;\n        __storage_type __m = ~__storage_type(0) >> __clz_r;\n        for (; __n >= __bits_per_word; __n -= __bits_per_word)\n        {\n            __storage_type __b = *--__last.__seg_;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b >> __clz_r;\n            *--__result.__seg_ &= __m;\n            *__result.__seg_ |= __b << __result.__ctz_;\n        }\n        // do last word\n        if (__n > 0)\n        {\n            __m = ~__storage_type(0) << (__bits_per_word - __n);\n            __storage_type __b = *--__last.__seg_ & __m;\n            __clz_r = __bits_per_word - __result.__ctz_;\n            __storage_type __dn = _VSTD::min(__n, static_cast<difference_type>(__result.__ctz_));\n            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);\n            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +\n                                                     __result.__ctz_)  % __bits_per_word);\n            __n -= __dn;\n            if (__n > 0)\n            {\n                // __result.__ctz_ == 0\n                --__result.__seg_;\n                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));\n                __m = ~__storage_type(0) << __result.__ctz_;\n                *__result.__seg_ &= ~__m;\n                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _Cp, bool _IsConst>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<_Cp, false>\ncopy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)\n{\n    if (__last.__ctz_ == __result.__ctz_)\n        return __copy_backward_aligned(__first, __last, __result);\n    return __copy_backward_unaligned(__first, __last, __result);\n}\n\n// move\n\ntemplate <class _Cp, bool _IsConst>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<_Cp, false>\nmove(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)\n{\n    return _VSTD::copy(__first, __last, __result);\n}\n\n// move_backward\n\ntemplate <class _Cp, bool _IsConst>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<_Cp, false>\nmove_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)\n{\n    return _VSTD::copy_backward(__first, __last, __result);\n}\n\n// swap_ranges\n\ntemplate <class __C1, class __C2>\n__bit_iterator<__C2, false>\n__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,\n                      __bit_iterator<__C2, false> __result)\n{\n    typedef __bit_iterator<__C1, false> _I1;\n    typedef  typename _I1::difference_type difference_type;\n    typedef typename _I1::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _I1::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first.__ctz_ != 0)\n        {\n            unsigned __clz = __bits_per_word - __first.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));\n            __storage_type __b1 = *__first.__seg_ & __m;\n            *__first.__seg_ &= ~__m;\n            __storage_type __b2 = *__result.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b1;\n            *__first.__seg_  |= __b2;\n            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);\n            ++__first.__seg_;\n            // __first.__ctz_ = 0;\n        }\n        // __first.__ctz_ == 0;\n        // do middle words\n        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)\n            swap(*__first.__seg_, *__result.__seg_);\n        // do last word\n        if (__n > 0)\n        {\n            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            __storage_type __b1 = *__first.__seg_ & __m;\n            *__first.__seg_ &= ~__m;\n            __storage_type __b2 = *__result.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b1;\n            *__first.__seg_  |= __b2;\n            __result.__ctz_ = static_cast<unsigned>(__n);\n        }\n    }\n    return __result;\n}\n\ntemplate <class __C1, class __C2>\n__bit_iterator<__C2, false>\n__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,\n                        __bit_iterator<__C2, false> __result)\n{\n    typedef __bit_iterator<__C1, false> _I1;\n    typedef  typename _I1::difference_type difference_type;\n    typedef typename _I1::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _I1::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first.__ctz_ != 0)\n        {\n            unsigned __clz_f = __bits_per_word - __first.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz_f), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n            __storage_type __b1 = *__first.__seg_ & __m;\n            *__first.__seg_ &= ~__m;\n            unsigned __clz_r = __bits_per_word - __result.__ctz_;\n            __storage_type __ddn = _VSTD::min<__storage_type>(__dn, __clz_r);\n            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));\n            __storage_type __b2 = *__result.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            if (__result.__ctz_ > __first.__ctz_)\n            {\n                unsigned __s = __result.__ctz_ - __first.__ctz_;\n                *__result.__seg_ |= __b1 << __s;\n                *__first.__seg_  |= __b2 >> __s;\n            }\n            else\n            {\n                unsigned __s = __first.__ctz_ - __result.__ctz_;\n                *__result.__seg_ |= __b1 >> __s;\n                *__first.__seg_  |= __b2 << __s;\n            }\n            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_)  % __bits_per_word);\n            __dn -= __ddn;\n            if (__dn > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __dn);\n                __b2 = *__result.__seg_ & __m;\n                *__result.__seg_ &= ~__m;\n                unsigned __s = __first.__ctz_ + __ddn;\n                *__result.__seg_ |= __b1 >> __s;\n                *__first.__seg_  |= __b2 << __s;\n                __result.__ctz_ = static_cast<unsigned>(__dn);\n            }\n            ++__first.__seg_;\n            // __first.__ctz_ = 0;\n        }\n        // __first.__ctz_ == 0;\n        // do middle words\n        __storage_type __m = ~__storage_type(0) << __result.__ctz_;\n        unsigned __clz_r = __bits_per_word - __result.__ctz_;\n        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)\n        {\n            __storage_type __b1 = *__first.__seg_;\n            __storage_type __b2 = *__result.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b1 << __result.__ctz_;\n            *__first.__seg_  = __b2 >> __result.__ctz_;\n            ++__result.__seg_;\n            __b2 = *__result.__seg_ & ~__m;\n            *__result.__seg_ &= __m;\n            *__result.__seg_ |= __b1 >> __clz_r;\n            *__first.__seg_  |= __b2 << __clz_r;\n        }\n        // do last word\n        if (__n > 0)\n        {\n            __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            __storage_type __b1 = *__first.__seg_ & __m;\n            *__first.__seg_ &= ~__m;\n            __storage_type __dn = _VSTD::min<__storage_type>(__n, __clz_r);\n            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));\n            __storage_type __b2 = *__result.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b1 << __result.__ctz_;\n            *__first.__seg_  |= __b2 >> __result.__ctz_;\n            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);\n            __n -= __dn;\n            if (__n > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __n);\n                __b2 = *__result.__seg_ & __m;\n                *__result.__seg_ &= ~__m;\n                *__result.__seg_ |= __b1 >> __dn;\n                *__first.__seg_  |= __b2 << __dn;\n                __result.__ctz_ = static_cast<unsigned>(__n);\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class __C1, class __C2>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<__C2, false>\nswap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,\n            __bit_iterator<__C2, false> __first2)\n{\n    if (__first1.__ctz_ == __first2.__ctz_)\n        return __swap_ranges_aligned(__first1, __last1, __first2);\n    return __swap_ranges_unaligned(__first1, __last1, __first2);\n}\n\n// rotate\n\ntemplate <class _Cp>\nstruct __bit_array\n{\n    typedef typename _Cp::difference_type difference_type;\n    typedef typename _Cp::__storage_type  __storage_type;\n    typedef typename _Cp::__storage_pointer __storage_pointer;\n    typedef typename _Cp::iterator        iterator;\n    static const unsigned __bits_per_word = _Cp::__bits_per_word;\n    static const unsigned _Np = 4;\n\n    difference_type __size_;\n    __storage_type __word_[_Np];\n\n    _LIBCPP_INLINE_VISIBILITY static difference_type capacity()\n        {return static_cast<difference_type>(_Np * __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY explicit __bit_array(difference_type __s) : __size_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY iterator begin()\n    {\n        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);\n    }\n    _LIBCPP_INLINE_VISIBILITY iterator end()\n    {\n        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,\n                                                  static_cast<unsigned>(__size_ % __bits_per_word));\n    }\n};\n\ntemplate <class _Cp>\n__bit_iterator<_Cp, false>\nrotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)\n{\n    typedef __bit_iterator<_Cp, false> _I1;\n    typedef  typename _I1::difference_type difference_type;\n    difference_type __d1 = __middle - __first;\n    difference_type __d2 = __last - __middle;\n    _I1 __r = __first + __d2;\n    while (__d1 != 0 && __d2 != 0)\n    {\n        if (__d1 <= __d2)\n        {\n            if (__d1 <= __bit_array<_Cp>::capacity())\n            {\n                __bit_array<_Cp> __b(__d1);\n                _VSTD::copy(__first, __middle, __b.begin());\n                _VSTD::copy(__b.begin(), __b.end(), _VSTD::copy(__middle, __last, __first));\n                break;\n            }\n            else\n            {\n                __bit_iterator<_Cp, false> __mp = _VSTD::swap_ranges(__first, __middle, __middle);\n                __first = __middle;\n                __middle = __mp;\n                __d2 -= __d1;\n            }\n        }\n        else\n        {\n            if (__d2 <= __bit_array<_Cp>::capacity())\n            {\n                __bit_array<_Cp> __b(__d2);\n                _VSTD::copy(__middle, __last, __b.begin());\n                _VSTD::copy_backward(__b.begin(), __b.end(), _VSTD::copy_backward(__first, __middle, __last));\n                break;\n            }\n            else\n            {\n                __bit_iterator<_Cp, false> __mp = __first + __d2;\n                _VSTD::swap_ranges(__first, __mp, __middle);\n                __first = __mp;\n                __d1 -= __d2;\n            }\n        }\n    }\n    return __r;\n}\n\n// equal\n\ntemplate <class _Cp, bool _IC1, bool _IC2>\nbool\n__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,\n                  __bit_iterator<_Cp, _IC2> __first2)\n{\n    typedef __bit_iterator<_Cp, _IC1> _It;\n    typedef  typename _It::difference_type difference_type;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    difference_type __n = __last1 - __first1;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first1.__ctz_ != 0)\n        {\n            unsigned __clz_f = __bits_per_word - __first1.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz_f), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n            __storage_type __b = *__first1.__seg_ & __m;\n            unsigned __clz_r = __bits_per_word - __first2.__ctz_;\n            __storage_type __ddn = _VSTD::min<__storage_type>(__dn, __clz_r);\n            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));\n            if (__first2.__ctz_ > __first1.__ctz_)\n            {\n                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))\n                    return false;\n            }\n            else\n            {\n                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))\n                    return false;\n            }\n            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;\n            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_)  % __bits_per_word);\n            __dn -= __ddn;\n            if (__dn > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __dn);\n                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))\n                    return false;\n                __first2.__ctz_ = static_cast<unsigned>(__dn);\n            }\n            ++__first1.__seg_;\n            // __first1.__ctz_ = 0;\n        }\n        // __first1.__ctz_ == 0;\n        // do middle words\n        unsigned __clz_r = __bits_per_word - __first2.__ctz_;\n        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;\n        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)\n        {\n            __storage_type __b = *__first1.__seg_;\n            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))\n                return false;\n            ++__first2.__seg_;\n            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))\n                return false;\n        }\n        // do last word\n        if (__n > 0)\n        {\n            __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            __storage_type __b = *__first1.__seg_ & __m;\n            __storage_type __dn = _VSTD::min(__n, static_cast<difference_type>(__clz_r));\n            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));\n            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))\n                return false;\n            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;\n            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_)  % __bits_per_word);\n            __n -= __dn;\n            if (__n > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __n);\n                if ((*__first2.__seg_ & __m) != (__b >> __dn))\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n\ntemplate <class _Cp, bool _IC1, bool _IC2>\nbool\n__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,\n                __bit_iterator<_Cp, _IC2> __first2)\n{\n    typedef __bit_iterator<_Cp, _IC1> _It;\n    typedef  typename _It::difference_type difference_type;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    difference_type __n = __last1 - __first1;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first1.__ctz_ != 0)\n        {\n            unsigned __clz = __bits_per_word - __first1.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));\n            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))\n                return false;\n            ++__first2.__seg_;\n            ++__first1.__seg_;\n            // __first1.__ctz_ = 0;\n            // __first2.__ctz_ = 0;\n        }\n        // __first1.__ctz_ == 0;\n        // __first2.__ctz_ == 0;\n        // do middle words\n        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)\n            if (*__first2.__seg_ != *__first1.__seg_)\n                return false;\n        // do last word\n        if (__n > 0)\n        {\n            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))\n                return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _Cp, bool _IC1, bool _IC2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)\n{\n    if (__first1.__ctz_ == __first2.__ctz_)\n        return __equal_aligned(__first1, __last1, __first2);\n    return __equal_unaligned(__first1, __last1, __first2);\n}\n\ntemplate <class _Cp, bool _IsConst,\n          typename _Cp::__storage_type>\nclass __bit_iterator\n{\npublic:\n    typedef typename _Cp::difference_type                                                          difference_type;\n    typedef bool                                                                                  value_type;\n    typedef __bit_iterator                                                                        pointer;\n    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;\n    typedef random_access_iterator_tag                                                            iterator_category;\n\nprivate:\n    typedef typename _Cp::__storage_type                                           __storage_type;\n    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,\n                                           typename _Cp::__storage_pointer>::type  __storage_pointer;\n    static const unsigned __bits_per_word = _Cp::__bits_per_word;\n\n    __storage_pointer __seg_;\n    unsigned          __ctz_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __seg_(nullptr), __ctz_(0)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_iterator(const __bit_iterator<_Cp, false>& __it) _NOEXCEPT\n        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n        {return reference(__seg_, __storage_type(1) << __ctz_);}\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator++()\n    {\n        if (__ctz_ != __bits_per_word-1)\n            ++__ctz_;\n        else\n        {\n            __ctz_ = 0;\n            ++__seg_;\n        }\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator++(int)\n    {\n        __bit_iterator __tmp = *this;\n        ++(*this);\n        return __tmp;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator--()\n    {\n        if (__ctz_ != 0)\n            --__ctz_;\n        else\n        {\n            __ctz_ = __bits_per_word - 1;\n            --__seg_;\n        }\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator--(int)\n    {\n        __bit_iterator __tmp = *this;\n        --(*this);\n        return __tmp;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator+=(difference_type __n)\n    {\n        if (__n >= 0)\n            __seg_ += (__n + __ctz_) / __bits_per_word;\n        else\n            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)\n                    / static_cast<difference_type>(__bits_per_word);\n        __n &= (__bits_per_word - 1);\n        __ctz_ = static_cast<unsigned>((__n + __ctz_)  % __bits_per_word);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator-=(difference_type __n)\n    {\n        return *this += -__n;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator+(difference_type __n) const\n    {\n        __bit_iterator __t(*this);\n        __t += __n;\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator-(difference_type __n) const\n    {\n        __bit_iterator __t(*this);\n        __t -= __n;\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator[](difference_type __n) const {return *(*this + __n);}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return !(__x == __y);}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return __y < __x;}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return !(__y < __x);}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return !(__x < __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_iterator(__storage_pointer __s, unsigned __ctz) _NOEXCEPT\n        : __seg_(__s), __ctz_(__ctz) {}\n\n#if defined(__clang__) || defined(__IBMCPP__) || defined(_LIBCPP_MSVC)\n    friend typename _Cp::__self;\n#else\n    friend class _Cp::__self;\n#endif\n    friend class __bit_reference<_Cp>;\n    friend class __bit_const_reference<_Cp>;\n    friend class __bit_iterator<_Cp, true>;\n    template <class _Dp> friend struct __bit_array;\n    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);\n    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,\n                                                                                  __bit_iterator<_Dp, _IC> __last,\n                                                                                  __bit_iterator<_Dp, false> __result);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,\n                                                                                    __bit_iterator<_Dp, _IC> __last,\n                                                                                    __bit_iterator<_Dp, false> __result);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,\n                                                                        __bit_iterator<_Dp, _IC> __last,\n                                                                        __bit_iterator<_Dp, false> __result);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,\n                                                                                           __bit_iterator<_Dp, _IC> __last,\n                                                                                           __bit_iterator<_Dp, false> __result);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,\n                                                                                             __bit_iterator<_Dp, _IC> __last,\n                                                                                             __bit_iterator<_Dp, false> __result);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,\n                                                                                 __bit_iterator<_Dp, _IC> __last,\n                                                                                 __bit_iterator<_Dp, false> __result);\n    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,\n                                                                                           __bit_iterator<__C1, false>,\n                                                                                           __bit_iterator<__C2, false>);\n    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,\n                                                                                             __bit_iterator<__C1, false>,\n                                                                                             __bit_iterator<__C2, false>);\n    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,\n                                                                                 __bit_iterator<__C1, false>,\n                                                                                 __bit_iterator<__C2, false>);\n    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,\n                                                                __bit_iterator<_Dp, false>,\n                                                                __bit_iterator<_Dp, false>);\n    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,\n                                                    __bit_iterator<_Dp, _IC1>,\n                                                    __bit_iterator<_Dp, _IC2>);\n    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,\n                                                      __bit_iterator<_Dp, _IC1>,\n                                                      __bit_iterator<_Dp, _IC2>);\n    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,\n                                                                __bit_iterator<_Dp, _IC1>,\n                                                                __bit_iterator<_Dp, _IC2>);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,\n                                                                          typename _Dp::size_type);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,\n                                                                           typename _Dp::size_type);\n    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type\n                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);\n    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type\n                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___BIT_REFERENCE\n","// -*- C++ -*-\n//===---------------------------- math.h ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MATH_H\n#define _LIBCPP_MATH_H\n\n/*\n    math.h synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <math.h>\n\n#ifdef __cplusplus\n\n// We support including .h headers inside 'extern \"C\"' contexts, so switch\n// back to C++ linkage before including these C++ headers.\nextern \"C++\" {\n\n#include <type_traits>\n\n#ifdef _LIBCPP_MSVCRT\n#include \"support/win32/math_win32.h\"\n#endif\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n#ifndef __sun__\n\n// abs\n\n#if !defined(_AIX)\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif // !defined(_AIX)\n\n// acos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return acos((double)__lcpp_x);}\n\n// asin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return asin((double)__lcpp_x);}\n\n// atan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return atan((double)__lcpp_x);}\n\n// atan2\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ceil((double)__lcpp_x);}\n\n// cos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return cos((double)__lcpp_x);}\n\n// cosh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return cosh((double)__lcpp_x);}\n\n// exp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return expl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return exp((double)__lcpp_x);}\n\n// fabs\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return fabs((double)__lcpp_x);}\n\n// floor\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return floor((double)__lcpp_x);}\n\n// fmod\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// frexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return log((double)__lcpp_x);}\n\n// log10\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return log10((double)__lcpp_x);}\n\n// modf\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return sin((double)__lcpp_x);}\n\n// sinh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return sinh((double)__lcpp_x);}\n\n// sqrt\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return sqrtl(__lcpp_x);}\n#endif\n\n#endif // __sun__\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return sqrt((double)__lcpp_x);}\n#ifndef __sun__\n\n// tan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return tan((double)__lcpp_x);}\n\n// tanh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return tanh((double)__lcpp_x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return acosh((double)__lcpp_x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return asinh((double)__lcpp_x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return atanh((double)__lcpp_x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return cbrt((double)__lcpp_x);}\n#endif\n\n// copysign\n\n#if !defined(_VC_CRT_MAJOR_VERSION) || (_VC_CRT_MAJOR_VERSION < 12)\ninline _LIBCPP_INLINE_VISIBILITY float copysign(float __lcpp_x,\n                                                float __lcpp_y) _NOEXCEPT {\n  return copysignf(__lcpp_x, __lcpp_y);\n}\ninline _LIBCPP_INLINE_VISIBILITY long double\ncopysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {\n  return copysignl(__lcpp_x, __lcpp_y);\n}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return erf((double)__lcpp_x);}\n\n// erfc\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return erfc((double)__lcpp_x);}\n\n// exp2\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return exp2((double)__lcpp_x);}\n\n// expm1\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return expm1((double)__lcpp_x);}\n\n// fdim\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value &&\n    std::is_arithmetic<_A3>::value,\n    std::__promote<_A1, _A2, _A3>\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value &&\n                     std::is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ilogb((double)__lcpp_x);}\n\n// lgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return lgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return lgamma((double)__lcpp_x);}\n\n// llrint\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return llrint((double)__lcpp_x);}\n\n// llround\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return llround((double)__lcpp_x);}\n\n// log1p\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return log1p((double)__lcpp_x);}\n\n// log2\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return log2((double)__lcpp_x);}\n\n// logb\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return logb((double)__lcpp_x);}\n\n// lrint\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return lrint((double)__lcpp_x);}\n\n// lround\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return lround((double)__lcpp_x);}\n\n// nan\n\n// nearbyint\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return nearbyint((double)__lcpp_x);}\n\n// nextafter\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return rint((double)__lcpp_x);}\n\n// round\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return round((double)__lcpp_x);}\n\n// scalbln\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return tgamma((double)__lcpp_x);}\n\n// trunc\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return trunc((double)__lcpp_x);}\n\n#endif // !_LIBCPP_MSVCRT\n#endif // __sun__\n\n} // extern \"C++\"\n\n#endif // __cplusplus\n\n#endif  // _LIBCPP_MATH_H\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n#include <__undef___deallocate>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <__functional_base>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_always_equal* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            throw bad_alloc();\n#else\n            assert(!\"allocator<T>::allocate::bad_alloc\");\n#endif\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            throw bad_alloc();\n#else\n            assert(!\"allocator<const T>::allocate::bad_alloc\");\n#endif\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; } \n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n                                       && !__libcpp_is_final<_T1>::value,\n                                bool = is_empty<_T2>::value\n                                       && !__libcpp_is_final<_T2>::value\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_(), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __first_(), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_() {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete void type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        !is_array<_Up>::value &&\n        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n        is_assignable<deleter_type&, _Ep&>::value,\n        unique_ptr&\n    >::type\n    operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t = nullptr) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n            {\n                __e->__weak_this_.__ptr_ = const_cast<_Yp*>(static_cast<const _Yp*>(__e));\n                __e->__weak_this_.__cntrl_ = __cntrl_;\n                __cntrl_->__add_weak();\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const volatile void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n        __enable_weak_this(__r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n        __enable_weak_this(__r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,  weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only\n// enabled with clang.\n#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2, \n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool, \n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n\n#include <__undef___deallocate>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n_LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_WIN32) && !defined(cxx_EXPORTS)\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS_ONLY\n#else\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS\n#endif\n\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#if defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309)\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#if defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309)\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/quantize.h\"\r\n\r\nnamespace guetzli {\r\n\r\nbool QuantizeBlock(coeff_t block[kDCTBlockSize],\r\n                   const int q[kDCTBlockSize]) {\r\n  bool changed = false;\r\n  for (int k = 0; k < kDCTBlockSize; ++k) {\r\n    coeff_t coeff = Quantize(block[k], q[k]);\r\n    changed = changed || (coeff != block[k]);\r\n    block[k] = coeff;\r\n  }\r\n  return changed;\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#ifndef GUETZLI_QUANTIZE_H_\r\n#define GUETZLI_QUANTIZE_H_\r\n\r\n#include \"guetzli/jpeg_data.h\"\r\n\r\nnamespace guetzli {\r\n\r\ninline coeff_t Quantize(coeff_t raw_coeff, int quant) {\r\n  const int r = raw_coeff % quant;\r\n  const coeff_t delta =\r\n      2 * r > quant ? quant - r : (-2) * r > quant ? -quant - r : -r;\r\n  return raw_coeff + delta;\r\n}\r\n\r\nbool QuantizeBlock(coeff_t block[kDCTBlockSize], const int q[kDCTBlockSize]);\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_QUANTIZE_H_\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/output_image.h\"\r\n\r\n#include <algorithm>\r\n#include <assert.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <cmath>\r\n\r\n#include \"guetzli/idct.cc\"\r\n#include \"guetzli/color_transform.h\"\r\n#include \"guetzli/dct_double.cc\"\r\n#include \"guetzli/gamma_correct.cc\"\r\n#include \"guetzli/preprocess_downsample.cc\"\r\n#include \"guetzli/quantize.cc\"\r\n\r\nnamespace guetzli {\r\n\r\nOutputImageComponent::OutputImageComponent(int w, int h)\r\n    : width_(w), height_(h) {\r\n  Reset(1, 1);\r\n}\r\n\r\nvoid OutputImageComponent::Reset(int factor_x, int factor_y) {\r\n  factor_x_ = factor_x;\r\n  factor_y_ = factor_y;\r\n  width_in_blocks_ = (width_ + 8 * factor_x_ - 1) / (8 * factor_x_);\r\n  height_in_blocks_ = (height_ + 8 * factor_y_ - 1) / (8 * factor_y_);\r\n  num_blocks_ = width_in_blocks_ * height_in_blocks_;\r\n  coeffs_ = std::vector<coeff_t>(num_blocks_ * kDCTBlockSize);\r\n  pixels_ = std::vector<uint16_t>(width_ * height_, 128 << 4);\r\n  for (int i = 0; i < kDCTBlockSize; ++i) quant_[i] = 1;\r\n}\r\n\r\nbool OutputImageComponent::IsAllZero() const {\r\n  int numcoeffs = num_blocks_ * kDCTBlockSize;\r\n  for (int i = 0; i < numcoeffs; ++i) {\r\n    if (coeffs_[i] != 0) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nvoid OutputImageComponent::GetCoeffBlock(int block_x, int block_y,\r\n                                         coeff_t block[kDCTBlockSize]) const {\r\n  assert(block_x < width_in_blocks_);\r\n  assert(block_y < height_in_blocks_);\r\n  int offset = (block_y * width_in_blocks_ + block_x) * kDCTBlockSize;\r\n  memcpy(block, &coeffs_[offset], kDCTBlockSize * sizeof(coeffs_[0]));\r\n}\r\n\r\nvoid OutputImageComponent::ToPixels(int xmin, int ymin, int xsize, int ysize,\r\n                                    uint8_t* out, int stride) const {\r\n  assert(xmin >= 0);\r\n  assert(ymin >= 0);\r\n  assert(xmin < width_);\r\n  assert(ymin < height_);\r\n  const int yend1 = ymin + ysize;\r\n  const int yend0 = std::min(yend1, height_);\r\n  int y = ymin;\r\n  for (; y < yend0; ++y) {\r\n    const int xend1 = xmin + xsize;\r\n    const int xend0 = std::min(xend1, width_);\r\n    int x = xmin;\r\n    int px = y * width_ + xmin;\r\n    for (; x < xend0; ++x, ++px, out += stride) {\r\n      *out = static_cast<uint8_t>((pixels_[px] + 8 - (x & 1)) >> 4);\r\n    }\r\n    const int offset = -stride;\r\n    for (; x < xend1; ++x) {\r\n      *out = out[offset];\r\n      out += stride;\r\n    }\r\n  }\r\n  for (; y < yend1; ++y) {\r\n    const int offset = -stride * xsize;\r\n    for (int x = 0; x < xsize; ++x) {\r\n      *out = out[offset];\r\n      out += stride;\r\n    }\r\n  }\r\n}\r\n\r\nvoid OutputImageComponent::ToFloatPixels(float* out, int stride) const {\r\n  assert(factor_x_ == 1);\r\n  assert(factor_y_ == 1);\r\n  for (int block_y = 0; block_y < height_in_blocks_; ++block_y) {\r\n    for (int block_x = 0; block_x < width_in_blocks_; ++block_x) {\r\n      coeff_t block[kDCTBlockSize];\r\n      GetCoeffBlock(block_x, block_y, block);\r\n      double blockd[kDCTBlockSize];\r\n      for (int k = 0; k < kDCTBlockSize; ++k) {\r\n        blockd[k] = block[k];\r\n      }\r\n      ComputeBlockIDCTDouble(blockd);\r\n      for (int iy = 0; iy < 8; ++iy) {\r\n        for (int ix = 0; ix < 8; ++ix) {\r\n          int y = block_y * 8 + iy;\r\n          int x = block_x * 8 + ix;\r\n          if (y >= height_ || x >= width_) continue;\r\n          out[(y * width_ + x) * stride] = blockd[8 * iy + ix] + 128.0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid OutputImageComponent::SetCoeffBlock(int block_x, int block_y,\r\n                                         const coeff_t block[kDCTBlockSize]) {\r\n  assert(block_x < width_in_blocks_);\r\n  assert(block_y < height_in_blocks_);\r\n  int offset = (block_y * width_in_blocks_ + block_x) * kDCTBlockSize;\r\n  memcpy(&coeffs_[offset], block, kDCTBlockSize * sizeof(coeffs_[0]));\r\n  uint8_t idct[kDCTBlockSize];\r\n  ComputeBlockIDCT(&coeffs_[offset], idct);\r\n  UpdatePixelsForBlock(block_x, block_y, idct);\r\n}\r\n\r\nvoid OutputImageComponent::UpdatePixelsForBlock(\r\n    int block_x, int block_y, const uint8_t idct[kDCTBlockSize]) {\r\n  if (factor_x_ == 1 && factor_y_ == 1) {\r\n    for (int iy = 0; iy < 8; ++iy) {\r\n      for (int ix = 0; ix < 8; ++ix) {\r\n        int x = 8 * block_x + ix;\r\n        int y = 8 * block_y + iy;\r\n        if (x >= width_ || y >= height_) continue;\r\n        int p = y * width_ + x;\r\n        pixels_[p] = idct[8 * iy + ix] << 4;\r\n      }\r\n    }\r\n  } else if (factor_x_ == 2 && factor_y_ == 2) {\r\n    // Fill in the 10x10 pixel area in the subsampled image that will be the\r\n    // basis of the upsampling. This area is enough to hold the 3x3 kernel of\r\n    // the fancy upsampler around each pixel.\r\n    static const int kSubsampledEdgeSize = 10;\r\n    uint16_t subsampled[kSubsampledEdgeSize * kSubsampledEdgeSize];\r\n    for (int j = 0; j < kSubsampledEdgeSize; ++j) {\r\n      // The order we fill in the rows is:\r\n      //   8 rows intersecting the block, row below, row above\r\n      const int y0 = block_y * 16 + (j < 9 ? j * 2 : -2);\r\n      for (int i = 0; i < kSubsampledEdgeSize; ++i) {\r\n        // The order we fill in each row is:\r\n        //   8 pixels within the block, left edge, right edge\r\n        const int ix = ((j < 9 ? (j + 1) * kSubsampledEdgeSize : 0) +\r\n                        (i < 9 ? i + 1 : 0));\r\n        const int x0 = block_x * 16 + (i < 9 ? i * 2 : -2);\r\n        if (x0 < 0) {\r\n          subsampled[ix] = subsampled[ix + 1];\r\n        } else if (y0 < 0) {\r\n          subsampled[ix] = subsampled[ix + kSubsampledEdgeSize];\r\n        } else if (x0 >= width_) {\r\n          subsampled[ix] = subsampled[ix - 1];\r\n        } else if (y0 >= height_) {\r\n          subsampled[ix] = subsampled[ix - kSubsampledEdgeSize];\r\n        } else if (i < 8 && j < 8) {\r\n          subsampled[ix] = idct[j * 8 + i] << 4;\r\n        } else {\r\n          // Reconstruct the subsampled pixels around the edge of the current\r\n          // block by computing the inverse of the fancy upsampler.\r\n          const int y1 = std::max(y0 - 1, 0);\r\n          const int x1 = std::max(x0 - 1, 0);\r\n          subsampled[ix] = (pixels_[y0 * width_ + x0] * 9 +\r\n                            pixels_[y1 * width_ + x1] +\r\n                            pixels_[y0 * width_ + x1] * -3 +\r\n                            pixels_[y1 * width_ + x0] * -3) >> 2;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Determine area to update.\r\n    int xmin = std::max(block_x * 16 - 1, 0);\r\n    int xmax = std::min(block_x * 16 + 16, width_ - 1);\r\n    int ymin = std::max(block_y * 16 - 1, 0);\r\n    int ymax = std::min(block_y * 16 + 16, height_ - 1);\r\n\r\n    // Apply the fancy upsampler on the subsampled block.\r\n    for (int y = ymin; y <= ymax; ++y) {\r\n      const int y0 = ((y & ~1) / 2 - block_y * 8 + 1) * kSubsampledEdgeSize;\r\n      const int dy = ((y & 1) * 2 - 1) * kSubsampledEdgeSize;\r\n      uint16_t* rowptr = &pixels_[y * width_];\r\n      for (int x = xmin; x <= xmax; ++x) {\r\n        const int x0 = (x & ~1) / 2 - block_x * 8 + 1;\r\n        const int dx = (x & 1) * 2 - 1;\r\n        const int ix = x0 + y0;\r\n        rowptr[x] = (subsampled[ix] * 9 + subsampled[ix + dy] * 3 +\r\n                     subsampled[ix + dx] * 3 + subsampled[ix + dx + dy]) >> 4;\r\n      }\r\n    }\r\n  } else {\r\n    printf(\"Sampling ratio not supported: factor_x = %d factor_y = %d\\n\",\r\n           factor_x_, factor_y_);\r\n    exit(1);\r\n  }\r\n}\r\n\r\nvoid OutputImageComponent::CopyFromJpegComponent(const JPEGComponent& comp,\r\n                                                 int factor_x, int factor_y,\r\n                                                 const int* quant) {\r\n  Reset(factor_x, factor_y);\r\n  assert(width_in_blocks_ <= comp.width_in_blocks);\r\n  assert(height_in_blocks_ <= comp.height_in_blocks);\r\n  const size_t src_row_size = comp.width_in_blocks * kDCTBlockSize;\r\n  for (int block_y = 0; block_y < height_in_blocks_; ++block_y) {\r\n    const coeff_t* src_coeffs = &comp.coeffs[block_y * src_row_size];\r\n    for (int block_x = 0; block_x < width_in_blocks_; ++block_x) {\r\n      coeff_t block[kDCTBlockSize];\r\n      for (int i = 0; i < kDCTBlockSize; ++i) {\r\n        block[i] = src_coeffs[i] * quant[i];\r\n      }\r\n      SetCoeffBlock(block_x, block_y, block);\r\n      src_coeffs += kDCTBlockSize;\r\n    }\r\n  }\r\n  memcpy(quant_, quant, sizeof(quant_));\r\n}\r\n\r\nvoid OutputImageComponent::ApplyGlobalQuantization(const int q[kDCTBlockSize]) {\r\n  for (int block_y = 0; block_y < height_in_blocks_; ++block_y) {\r\n    for (int block_x = 0; block_x < width_in_blocks_; ++block_x) {\r\n      coeff_t block[kDCTBlockSize];\r\n      GetCoeffBlock(block_x, block_y, block);\r\n      if (QuantizeBlock(block, q)) {\r\n        SetCoeffBlock(block_x, block_y, block);\r\n      }\r\n    }\r\n  }\r\n  memcpy(quant_, q, sizeof(quant_));\r\n}\r\n\r\nOutputImage::OutputImage(int w, int h)\r\n    : width_(w),\r\n      height_(h),\r\n      components_(3, OutputImageComponent(w, h)) {}\r\n\r\nvoid OutputImage::CopyFromJpegData(const JPEGData& jpg) {\r\n  for (int i = 0; i < jpg.components.size(); ++i) {\r\n    const JPEGComponent& comp = jpg.components[i];\r\n    assert(jpg.max_h_samp_factor % comp.h_samp_factor == 0);\r\n    assert(jpg.max_v_samp_factor % comp.v_samp_factor == 0);\r\n    int factor_x = jpg.max_h_samp_factor / comp.h_samp_factor;\r\n    int factor_y = jpg.max_v_samp_factor / comp.v_samp_factor;\r\n    assert(comp.quant_idx < jpg.quant.size());\r\n    components_[i].CopyFromJpegComponent(comp, factor_x, factor_y,\r\n                                         &jpg.quant[comp.quant_idx].values[0]);\r\n  }\r\n}\r\n\r\nnamespace {\r\n\r\nvoid SetDownsampledCoefficients(const std::vector<float>& pixels,\r\n                                int factor_x, int factor_y,\r\n                                OutputImageComponent* comp) {\r\n  assert(pixels.size() == comp->width() * comp->height());\r\n  comp->Reset(factor_x, factor_y);\r\n  for (int block_y = 0; block_y < comp->height_in_blocks(); ++block_y) {\r\n    for (int block_x = 0; block_x < comp->width_in_blocks(); ++block_x) {\r\n      double blockd[kDCTBlockSize];\r\n      int x0 = 8 * block_x * factor_x;\r\n      int y0 = 8 * block_y * factor_y;\r\n      assert(x0 < comp->width());\r\n      assert(y0 < comp->height());\r\n      for (int iy = 0; iy < 8; ++iy) {\r\n        for (int ix = 0; ix < 8; ++ix) {\r\n          float avg = 0.0;\r\n          for (int j = 0; j < factor_y; ++j) {\r\n            for (int i = 0; i < factor_x; ++i) {\r\n              int x = std::min(x0 + ix * factor_x + i, comp->width() - 1);\r\n              int y = std::min(y0 + iy * factor_y + j, comp->height() - 1);\r\n              avg += pixels[y * comp->width() + x];\r\n            }\r\n          }\r\n          avg /= factor_x * factor_y;\r\n          blockd[iy * 8 + ix] = avg;\r\n        }\r\n      }\r\n      ComputeBlockDCTDouble(blockd);\r\n      blockd[0] -= 1024.0;\r\n      coeff_t block[kDCTBlockSize];\r\n      for (int k = 0; k < kDCTBlockSize; ++k) {\r\n        block[k] = static_cast<coeff_t>(std::round(blockd[k]));\r\n      }\r\n      comp->SetCoeffBlock(block_x, block_y, block);\r\n    }\r\n  }\r\n}\r\n\r\n}  // namespace\r\n\r\nvoid OutputImage::Downsample(const DownsampleConfig& cfg) {\r\n  if (components_[1].IsAllZero() && components_[2].IsAllZero()) {\r\n    // If the image is already grayscale, nothing to do.\r\n    return;\r\n  }\r\n  if (cfg.use_silver_screen &&\r\n      cfg.u_factor_x == 2 && cfg.u_factor_y == 2 &&\r\n      cfg.v_factor_x == 2 && cfg.v_factor_y == 2) {\r\n    std::vector<uint8_t> rgb = ToSRGB();\r\n    std::vector<std::vector<float> > yuv = RGBToYUV420(rgb, width_, height_);\r\n    SetDownsampledCoefficients(yuv[0], 1, 1, &components_[0]);\r\n    SetDownsampledCoefficients(yuv[1], 2, 2, &components_[1]);\r\n    SetDownsampledCoefficients(yuv[2], 2, 2, &components_[2]);\r\n    return;\r\n  }\r\n  // Get the floating-point precision YUV array represented by the set of\r\n  // DCT coefficients.\r\n  std::vector<std::vector<float> > yuv(3, std::vector<float>(width_ * height_));\r\n  for (int c = 0; c < 3; ++c) {\r\n    components_[c].ToFloatPixels(&yuv[c][0], 1);\r\n  }\r\n\r\n  yuv = PreProcessChannel(width_, height_, 2, 1.3, 0.5,\r\n                          cfg.u_sharpen, cfg.u_blur, yuv);\r\n  yuv = PreProcessChannel(width_, height_, 1, 1.3, 0.5,\r\n                          cfg.v_sharpen, cfg.v_blur, yuv);\r\n\r\n  // Do the actual downsampling (averaging) and forward-DCT.\r\n  if (cfg.u_factor_x != 1 || cfg.u_factor_y != 1) {\r\n    SetDownsampledCoefficients(yuv[1], cfg.u_factor_x, cfg.u_factor_y,\r\n                               &components_[1]);\r\n  }\r\n  if (cfg.v_factor_x != 1 || cfg.v_factor_y != 1) {\r\n    SetDownsampledCoefficients(yuv[2], cfg.v_factor_x, cfg.v_factor_y,\r\n                               &components_[2]);\r\n  }\r\n}\r\n\r\nvoid OutputImage::ApplyGlobalQuantization(const int q[3][kDCTBlockSize]) {\r\n  for (int c = 0; c < 3; ++c) {\r\n    components_[c].ApplyGlobalQuantization(&q[c][0]);\r\n  }\r\n}\r\n\r\nvoid OutputImage::SaveToJpegData(JPEGData* jpg) const {\r\n  assert(components_[0].factor_x() == 1);\r\n  assert(components_[0].factor_y() == 1);\r\n  jpg->width = width_;\r\n  jpg->height = height_;\r\n  jpg->max_h_samp_factor = 1;\r\n  jpg->max_v_samp_factor = 1;\r\n  jpg->MCU_cols = components_[0].width_in_blocks();\r\n  jpg->MCU_rows = components_[0].height_in_blocks();\r\n  int ncomp = components_[1].IsAllZero() && components_[2].IsAllZero() ? 1 : 3;\r\n  for (int i = 1; i < ncomp; ++i) {\r\n    jpg->max_h_samp_factor = std::max(jpg->max_h_samp_factor,\r\n                                      components_[i].factor_x());\r\n    jpg->max_v_samp_factor = std::max(jpg->max_h_samp_factor,\r\n                                      components_[i].factor_y());\r\n    jpg->MCU_cols = std::min(jpg->MCU_cols, components_[i].width_in_blocks());\r\n    jpg->MCU_rows = std::min(jpg->MCU_rows, components_[i].height_in_blocks());\r\n  }\r\n  jpg->components.resize(ncomp);\r\n  int q[3][kDCTBlockSize];\r\n  for (int c = 0; c < 3; ++c) {\r\n    memcpy(&q[c][0], components_[c].quant(), kDCTBlockSize * sizeof(q[0][0]));\r\n  }\r\n  for (int c = 0; c < ncomp; ++c) {\r\n    JPEGComponent* comp = &jpg->components[c];\r\n    assert(jpg->max_h_samp_factor % components_[c].factor_x() == 0);\r\n    assert(jpg->max_v_samp_factor % components_[c].factor_y() == 0);\r\n    comp->id = c;\r\n    comp->h_samp_factor = jpg->max_h_samp_factor / components_[c].factor_x();\r\n    comp->v_samp_factor = jpg->max_v_samp_factor / components_[c].factor_y();\r\n    comp->width_in_blocks = jpg->MCU_cols * comp->h_samp_factor;\r\n    comp->height_in_blocks = jpg->MCU_rows * comp->v_samp_factor;\r\n    comp->num_blocks = comp->width_in_blocks * comp->height_in_blocks;\r\n    comp->coeffs.resize(kDCTBlockSize * comp->num_blocks);\r\n\r\n    int last_dc = 0;\r\n    const coeff_t* src_coeffs = components_[c].coeffs();\r\n    coeff_t* dest_coeffs = &comp->coeffs[0];\r\n    for (int block_y = 0; block_y < comp->height_in_blocks; ++block_y) {\r\n      for (int block_x = 0; block_x < comp->width_in_blocks; ++block_x) {\r\n        if (block_y >= components_[c].height_in_blocks() ||\r\n            block_x >= components_[c].width_in_blocks()) {\r\n          dest_coeffs[0] = last_dc;\r\n          for (int k = 1; k < kDCTBlockSize; ++k) {\r\n            dest_coeffs[k] = 0;\r\n          }\r\n        } else {\r\n          for (int k = 0; k < kDCTBlockSize; ++k) {\r\n            const int quant = q[c][k];\r\n            int coeff = src_coeffs[k];\r\n            assert(coeff % quant == 0);\r\n            dest_coeffs[k] = coeff / quant;\r\n          }\r\n          src_coeffs += kDCTBlockSize;\r\n        }\r\n        last_dc = dest_coeffs[0];\r\n        dest_coeffs += kDCTBlockSize;\r\n      }\r\n    }\r\n  }\r\n  SaveQuantTables(q, jpg);\r\n}\r\n\r\nstd::vector<uint8_t> OutputImage::ToSRGB(int xmin, int ymin,\r\n                                         int xsize, int ysize) const {\r\n  std::vector<uint8_t> rgb(xsize * ysize * 3);\r\n  for (int c = 0; c < 3; ++c) {\r\n    components_[c].ToPixels(xmin, ymin, xsize, ysize, &rgb[c], 3);\r\n  }\r\n  for (int p = 0; p < rgb.size(); p += 3) {\r\n    ColorTransformYCbCrToRGB(&rgb[p]);\r\n  }\r\n  return rgb;\r\n}\r\n\r\nstd::vector<uint8_t> OutputImage::ToSRGB() const {\r\n  return ToSRGB(0, 0, width_, height_);\r\n}\r\n\r\nvoid OutputImage::ToLinearRGB(int xmin, int ymin, int xsize, int ysize,\r\n                              std::vector<std::vector<float> >* rgb) const {\r\n  const double* lut = Srgb8ToLinearTable();\r\n  std::vector<uint8_t> rgb_pixels = ToSRGB(xmin, ymin, xsize, ysize);\r\n  for (int p = 0; p < xsize * ysize; ++p) {\r\n    for (int i = 0; i < 3; ++i) {\r\n      (*rgb)[i][p] = lut[rgb_pixels[3 * p + i]];\r\n    }\r\n  }\r\n}\r\n\r\nvoid OutputImage::ToLinearRGB(std::vector<std::vector<float> >* rgb) const {\r\n  ToLinearRGB(0, 0, width_, height_, rgb);\r\n}\r\n\r\nstd::string OutputImage::FrameTypeStr() const {\r\n  char buf[128];\r\n  int len = snprintf(buf, sizeof(buf), \"f%d%d%d%d%d%d\",\r\n                     component(0).factor_x(), component(0).factor_y(),\r\n                     component(1).factor_x(), component(1).factor_y(),\r\n                     component(2).factor_x(), component(2).factor_y());\r\n  return std::string(buf, len);\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#ifndef GUETZLI_OUTPUT_IMAGE_H_\r\n#define GUETZLI_OUTPUT_IMAGE_H_\r\n\r\n#include <stdint.h>\r\n#include <vector>\r\n\r\n#include \"guetzli/jpeg_data.h\"\r\n\r\nnamespace guetzli {\r\n\r\nclass OutputImageComponent {\r\n public:\r\n  OutputImageComponent(int w, int h);\r\n\r\n  void Reset(int factor_x, int factor_y);\r\n\r\n  int width() const { return width_; }\r\n  int height() const { return height_; }\r\n  int factor_x() const { return factor_x_; }\r\n  int factor_y() const { return factor_y_; }\r\n  int width_in_blocks() const { return width_in_blocks_; }\r\n  int height_in_blocks() const { return height_in_blocks_; }\r\n  const coeff_t* coeffs() const { return &coeffs_[0]; }\r\n  const int* quant() const { return &quant_[0]; }\r\n  bool IsAllZero() const;\r\n\r\n  // Fills in block[] with the 8x8 coefficient block with block coordinates\r\n  // (block_x, block_y).\r\n  // NOTE: If the component is 2x2 subsampled, this corresponds to the 16x16\r\n  // pixel area with upper-left corner (16 * block_x, 16 * block_y).\r\n  void GetCoeffBlock(int block_x, int block_y,\r\n                     coeff_t block[kDCTBlockSize]) const;\r\n\r\n  // Fills in out[] array with the 8-bit pixel view of this component cropped\r\n  // to the specified window. The window's upper-left corner, (xmin, ymin) must\r\n  // be within the image, but the window may extend past the image. In that\r\n  // case the edge pixels are duplicated.\r\n  void ToPixels(int xmin, int ymin, int xsize, int ysize,\r\n                uint8_t* out, int stride) const;\r\n\r\n  // Fills in out[] array with the floating-point precision pixel view of the\r\n  // component.\r\n  // REQUIRES: factor_x() == 1 and factor_y() == 1.\r\n  void ToFloatPixels(float* out, int stride) const;\r\n\r\n  // Sets the 8x8 coefficient block with block coordinates (block_x, block_y)\r\n  // to block[].\r\n  // NOTE: If the component is 2x2 subsampled, this corresponds to the 16x16\r\n  // pixel area with upper-left corner (16 * block_x, 16 * block_y).\r\n  // REQUIRES: block[k] % quant()[k] == 0 for each coefficient index k.\r\n  void SetCoeffBlock(int block_x, int block_y,\r\n                     const coeff_t block[kDCTBlockSize]);\r\n\r\n  // Requires that comp is not downsampled.\r\n  void CopyFromJpegComponent(const JPEGComponent& comp,\r\n                             int factor_x, int factor_y,\r\n                             const int* quant);\r\n\r\n  void ApplyGlobalQuantization(const int q[kDCTBlockSize]);\r\n\r\n private:\r\n  void UpdatePixelsForBlock(int block_x, int block_y,\r\n                            const uint8_t idct[kDCTBlockSize]);\r\n\r\n  const int width_;\r\n  const int height_;\r\n  int factor_x_;\r\n  int factor_y_;\r\n  int width_in_blocks_;\r\n  int height_in_blocks_;\r\n  int num_blocks_;\r\n  std::vector<coeff_t> coeffs_;\r\n  std::vector<uint16_t> pixels_;\r\n  // Same as last argument of ApplyGlobalQuantization() (default is all 1s).\r\n  int quant_[kDCTBlockSize];\r\n};\r\n\r\nclass OutputImage {\r\n public:\r\n  OutputImage(int w, int h);\r\n\r\n  int width() const { return width_; }\r\n  int height() const { return height_; }\r\n\r\n  OutputImageComponent& component(int c) { return components_[c]; }\r\n  const OutputImageComponent& component(int c) const { return components_[c]; }\r\n\r\n  // Requires that jpg is in YUV444 format.\r\n  void CopyFromJpegData(const JPEGData& jpg);\r\n\r\n  void ApplyGlobalQuantization(const int q[3][kDCTBlockSize]);\r\n\r\n  // If sharpen or blur are enabled, preprocesses image before downsampling U or\r\n  // V to improve butteraugli score and/or reduce file size.\r\n  // u_sharpen: sharpen the u channel in red areas to improve score (not as\r\n  // effective as v_sharpen, blue is not so important)\r\n  // u_blur: blur the u channel in some areas to reduce file size\r\n  // v_sharpen: sharpen the v channel in red areas to improve score\r\n  // v_blur: blur the v channel in some areas to reduce file size\r\n  struct DownsampleConfig {\r\n    // Default is YUV420.\r\n    DownsampleConfig() : u_factor_x(2), u_factor_y(2),\r\n                         v_factor_x(2), v_factor_y(2),\r\n                         u_sharpen(true), u_blur(true),\r\n                         v_sharpen(true), v_blur(true),\r\n                         use_silver_screen(false) {}\r\n    int u_factor_x;\r\n    int u_factor_y;\r\n    int v_factor_x;\r\n    int v_factor_y;\r\n    bool u_sharpen;\r\n    bool u_blur;\r\n    bool v_sharpen;\r\n    bool v_blur;\r\n    bool use_silver_screen;\r\n  };\r\n\r\n  void Downsample(const DownsampleConfig& cfg);\r\n\r\n  void SaveToJpegData(JPEGData* jpg) const;\r\n\r\n  std::vector<uint8_t> ToSRGB() const;\r\n\r\n  std::vector<uint8_t> ToSRGB(int xmin, int ymin, int xsize, int ysize) const;\r\n\r\n  void ToLinearRGB(std::vector<std::vector<float> >* rgb) const;\r\n\r\n  void ToLinearRGB(int xmin, int ymin, int xsize, int ysize,\r\n                   std::vector<std::vector<float> >* rgb) const;\r\n\r\n  std::string FrameTypeStr() const;\r\n\r\n private:\r\n  const int width_;\r\n  const int height_;\r\n  std::vector<OutputImageComponent> components_;\r\n};\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_OUTPUT_IMAGE_H_\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/jpeg_data.h\"\r\n\r\n#include <assert.h>\r\n#include <string.h>\r\n\r\nnamespace guetzli {\r\n\r\nbool JPEGData::Is420() const {\r\n  return (components.size() == 3 &&\r\n          max_h_samp_factor == 2 &&\r\n          max_v_samp_factor == 2 &&\r\n          components[0].h_samp_factor == 2 &&\r\n          components[0].v_samp_factor == 2 &&\r\n          components[1].h_samp_factor == 1 &&\r\n          components[1].v_samp_factor == 1 &&\r\n          components[2].h_samp_factor == 1 &&\r\n          components[2].v_samp_factor == 1);\r\n}\r\n\r\nbool JPEGData::Is444() const {\r\n  return (components.size() == 3 &&\r\n          max_h_samp_factor == 1 &&\r\n          max_v_samp_factor == 1 &&\r\n          components[0].h_samp_factor == 1 &&\r\n          components[0].v_samp_factor == 1 &&\r\n          components[1].h_samp_factor == 1 &&\r\n          components[1].v_samp_factor == 1 &&\r\n          components[2].h_samp_factor == 1 &&\r\n          components[2].v_samp_factor == 1);\r\n}\r\n\r\nvoid InitJPEGDataForYUV444(int w, int h, JPEGData* jpg) {\r\n  jpg->width = w;\r\n  jpg->height = h;\r\n  jpg->max_h_samp_factor = 1;\r\n  jpg->max_v_samp_factor = 1;\r\n  jpg->MCU_rows = (h + 7) >> 3;\r\n  jpg->MCU_cols = (w + 7) >> 3;\r\n  jpg->quant.resize(3);\r\n  jpg->components.resize(3);\r\n  for (int i = 0; i < 3; ++i) {\r\n    JPEGComponent* c = &jpg->components[i];\r\n    c->id = i;\r\n    c->h_samp_factor = 1;\r\n    c->v_samp_factor = 1;\r\n    c->quant_idx = i;\r\n    c->width_in_blocks = jpg->MCU_cols;\r\n    c->height_in_blocks = jpg->MCU_rows;\r\n    c->num_blocks = c->width_in_blocks * c->height_in_blocks;\r\n    c->coeffs.resize(c->num_blocks * kDCTBlockSize);\r\n  }\r\n}\r\n\r\nvoid SaveQuantTables(const int q[3][kDCTBlockSize], JPEGData* jpg) {\r\n  const size_t kTableSize = kDCTBlockSize * sizeof(q[0][0]);\r\n  jpg->quant.clear();\r\n  int num_tables = 0;\r\n  for (int i = 0; i < jpg->components.size(); ++i) {\r\n    JPEGComponent* comp = &jpg->components[i];\r\n    // Check if we have this quant table already.\r\n    bool found = false;\r\n    for (int j = 0; j < num_tables; ++j) {\r\n      if (memcmp(&q[i][0], &jpg->quant[j].values[0], kTableSize) == 0) {\r\n        comp->quant_idx = j;\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!found) {\r\n      JPEGQuantTable table;\r\n      memcpy(&table.values[0], &q[i][0], kTableSize);\r\n      table.precision = 0;\r\n      for (int k = 0; k < kDCTBlockSize; ++k) {\r\n        assert(table.values[k] >= 0);\r\n        assert(table.values[k] < (1 << 16));\r\n        if (table.values[k] > 0xff) {\r\n          table.precision = 1;\r\n        }\r\n      }\r\n      table.index = num_tables;\r\n      comp->quant_idx = num_tables;\r\n      jpg->quant.push_back(table);\r\n      ++num_tables;\r\n    }\r\n  }\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#ifndef GUETZLI_COLOR_TRANSFORM_H_\r\n#define GUETZLI_COLOR_TRANSFORM_H_\r\n\r\nnamespace guetzli {\r\n\r\nstatic const int kCrToRedTable[256] = {\r\n  -179, -178, -177, -175, -174, -172, -171, -170, -168, -167, -165, -164,\r\n  -163, -161, -160, -158, -157, -156, -154, -153, -151, -150, -149, -147,\r\n  -146, -144, -143, -142, -140, -139, -137, -136, -135, -133, -132, -130,\r\n  -129, -128, -126, -125, -123, -122, -121, -119, -118, -116, -115, -114,\r\n  -112, -111, -109, -108, -107, -105, -104, -102, -101, -100,  -98,  -97,\r\n   -95,  -94,  -93,  -91,  -90,  -88,  -87,  -86,  -84,  -83,  -81,  -80,\r\n   -79,  -77,  -76,  -74,  -73,  -72,  -70,  -69,  -67,  -66,  -64,  -63,\r\n   -62,  -60,  -59,  -57,  -56,  -55,  -53,  -52,  -50,  -49,  -48,  -46,\r\n   -45,  -43,  -42,  -41,  -39,  -38,  -36,  -35,  -34,  -32,  -31,  -29,\r\n   -28,  -27,  -25,  -24,  -22,  -21,  -20,  -18,  -17,  -15,  -14,  -13,\r\n   -11,  -10,   -8,   -7,   -6,   -4,   -3,   -1,    0,    1,    3,    4,\r\n     6,    7,    8,   10,   11,   13,   14,   15,   17,   18,   20,   21,\r\n    22,   24,   25,   27,   28,   29,   31,   32,   34,   35,   36,   38,\r\n    39,   41,   42,   43,   45,   46,   48,   49,   50,   52,   53,   55,\r\n    56,   57,   59,   60,   62,   63,   64,   66,   67,   69,   70,   72,\r\n    73,   74,   76,   77,   79,   80,   81,   83,   84,   86,   87,   88,\r\n    90,   91,   93,   94,   95,   97,   98,  100,  101,  102,  104,  105,\r\n   107,  108,  109,  111,  112,  114,  115,  116,  118,  119,  121,  122,\r\n   123,  125,  126,  128,  129,  130,  132,  133,  135,  136,  137,  139,\r\n   140,  142,  143,  144,  146,  147,  149,  150,  151,  153,  154,  156,\r\n   157,  158,  160,  161,  163,  164,  165,  167,  168,  170,  171,  172,\r\n   174,  175,  177,  178\r\n};\r\n\r\nstatic const int kCbToBlueTable[256] = {\r\n  -227, -225, -223, -222, -220, -218, -216, -214, -213, -211, -209, -207,\r\n  -206, -204, -202, -200, -198, -197, -195, -193, -191, -190, -188, -186,\r\n  -184, -183, -181, -179, -177, -175, -174, -172, -170, -168, -167, -165,\r\n  -163, -161, -159, -158, -156, -154, -152, -151, -149, -147, -145, -144,\r\n  -142, -140, -138, -136, -135, -133, -131, -129, -128, -126, -124, -122,\r\n  -120, -119, -117, -115, -113, -112, -110, -108, -106, -105, -103, -101,\r\n   -99,  -97,  -96,  -94,  -92,  -90,  -89,  -87,  -85,  -83,  -82,  -80,\r\n   -78,  -76,  -74,  -73,  -71,  -69,  -67,  -66,  -64,  -62,  -60,  -58,\r\n   -57,  -55,  -53,  -51,  -50,  -48,  -46,  -44,  -43,  -41,  -39,  -37,\r\n   -35,  -34,  -32,  -30,  -28,  -27,  -25,  -23,  -21,  -19,  -18,  -16,\r\n   -14,  -12,  -11,   -9,   -7,   -5,   -4,   -2,    0,    2,    4,    5,\r\n     7,    9,   11,   12,   14,   16,   18,   19,   21,   23,   25,   27,\r\n    28,   30,   32,   34,   35,   37,   39,   41,   43,   44,   46,   48,\r\n    50,   51,   53,   55,   57,   58,   60,   62,   64,   66,   67,   69,\r\n    71,   73,   74,   76,   78,   80,   82,   83,   85,   87,   89,   90,\r\n    92,   94,   96,   97,   99,  101,  103,  105,  106,  108,  110,  112,\r\n   113,  115,  117,  119,  120,  122,  124,  126,  128,  129,  131,  133,\r\n   135,  136,  138,  140,  142,  144,  145,  147,  149,  151,  152,  154,\r\n   156,  158,  159,  161,  163,  165,  167,  168,  170,  172,  174,  175,\r\n   177,  179,  181,  183,  184,  186,  188,  190,  191,  193,  195,  197,\r\n   198,  200,  202,  204,  206,  207,  209,  211,  213,  214,  216,  218,\r\n   220,  222,  223,  225,\r\n};\r\n\r\nstatic const int kCrToGreenTable[256] = {\r\n  5990656,  5943854,  5897052,  5850250,  5803448,  5756646,  5709844,  5663042,\r\n  5616240,  5569438,  5522636,  5475834,  5429032,  5382230,  5335428,  5288626,\r\n  5241824,  5195022,  5148220,  5101418,  5054616,  5007814,  4961012,  4914210,\r\n  4867408,  4820606,  4773804,  4727002,  4680200,  4633398,  4586596,  4539794,\r\n  4492992,  4446190,  4399388,  4352586,  4305784,  4258982,  4212180,  4165378,\r\n  4118576,  4071774,  4024972,  3978170,  3931368,  3884566,  3837764,  3790962,\r\n  3744160,  3697358,  3650556,  3603754,  3556952,  3510150,  3463348,  3416546,\r\n  3369744,  3322942,  3276140,  3229338,  3182536,  3135734,  3088932,  3042130,\r\n  2995328,  2948526,  2901724,  2854922,  2808120,  2761318,  2714516,  2667714,\r\n  2620912,  2574110,  2527308,  2480506,  2433704,  2386902,  2340100,  2293298,\r\n  2246496,  2199694,  2152892,  2106090,  2059288,  2012486,  1965684,  1918882,\r\n  1872080,  1825278,  1778476,  1731674,  1684872,  1638070,  1591268,  1544466,\r\n  1497664,  1450862,  1404060,  1357258,  1310456,  1263654,  1216852,  1170050,\r\n  1123248,  1076446,  1029644,   982842,   936040,   889238,   842436,   795634,\r\n   748832,   702030,   655228,   608426,   561624,   514822,   468020,   421218,\r\n   374416,   327614,   280812,   234010,   187208,   140406,    93604,    46802,\r\n        0,   -46802,   -93604,  -140406,  -187208,  -234010,  -280812,  -327614,\r\n  -374416,  -421218,  -468020,  -514822,  -561624,  -608426,  -655228,  -702030,\r\n  -748832,  -795634,  -842436,  -889238,  -936040,  -982842, -1029644, -1076446,\r\n -1123248, -1170050, -1216852, -1263654, -1310456, -1357258, -1404060, -1450862,\r\n -1497664, -1544466, -1591268, -1638070, -1684872, -1731674, -1778476, -1825278,\r\n -1872080, -1918882, -1965684, -2012486, -2059288, -2106090, -2152892, -2199694,\r\n -2246496, -2293298, -2340100, -2386902, -2433704, -2480506, -2527308, -2574110,\r\n -2620912, -2667714, -2714516, -2761318, -2808120, -2854922, -2901724, -2948526,\r\n -2995328, -3042130, -3088932, -3135734, -3182536, -3229338, -3276140, -3322942,\r\n -3369744, -3416546, -3463348, -3510150, -3556952, -3603754, -3650556, -3697358,\r\n -3744160, -3790962, -3837764, -3884566, -3931368, -3978170, -4024972, -4071774,\r\n -4118576, -4165378, -4212180, -4258982, -4305784, -4352586, -4399388, -4446190,\r\n -4492992, -4539794, -4586596, -4633398, -4680200, -4727002, -4773804, -4820606,\r\n -4867408, -4914210, -4961012, -5007814, -5054616, -5101418, -5148220, -5195022,\r\n -5241824, -5288626, -5335428, -5382230, -5429032, -5475834, -5522636, -5569438,\r\n -5616240, -5663042, -5709844, -5756646, -5803448, -5850250, -5897052, -5943854,\r\n};\r\n\r\nstatic const int kCbToGreenTable[256] = {\r\n  2919680,  2897126,  2874572,  2852018,  2829464,  2806910,  2784356,  2761802,\r\n  2739248,  2716694,  2694140,  2671586,  2649032,  2626478,  2603924,  2581370,\r\n  2558816,  2536262,  2513708,  2491154,  2468600,  2446046,  2423492,  2400938,\r\n  2378384,  2355830,  2333276,  2310722,  2288168,  2265614,  2243060,  2220506,\r\n  2197952,  2175398,  2152844,  2130290,  2107736,  2085182,  2062628,  2040074,\r\n  2017520,  1994966,  1972412,  1949858,  1927304,  1904750,  1882196,  1859642,\r\n  1837088,  1814534,  1791980,  1769426,  1746872,  1724318,  1701764,  1679210,\r\n  1656656,  1634102,  1611548,  1588994,  1566440,  1543886,  1521332,  1498778,\r\n  1476224,  1453670,  1431116,  1408562,  1386008,  1363454,  1340900,  1318346,\r\n  1295792,  1273238,  1250684,  1228130,  1205576,  1183022,  1160468,  1137914,\r\n  1115360,  1092806,  1070252,  1047698,  1025144,  1002590,   980036,   957482,\r\n   934928,   912374,   889820,   867266,   844712,   822158,   799604,   777050,\r\n   754496,   731942,   709388,   686834,   664280,   641726,   619172,   596618,\r\n   574064,   551510,   528956,   506402,   483848,   461294,   438740,   416186,\r\n   393632,   371078,   348524,   325970,   303416,   280862,   258308,   235754,\r\n   213200,   190646,   168092,   145538,   122984,   100430,    77876,    55322,\r\n    32768,    10214,   -12340,   -34894,   -57448,   -80002,  -102556,  -125110,\r\n  -147664,  -170218,  -192772,  -215326,  -237880,  -260434,  -282988,  -305542,\r\n  -328096,  -350650,  -373204,  -395758,  -418312,  -440866,  -463420,  -485974,\r\n  -508528,  -531082,  -553636,  -576190,  -598744,  -621298,  -643852,  -666406,\r\n  -688960,  -711514,  -734068,  -756622,  -779176,  -801730,  -824284,  -846838,\r\n  -869392,  -891946,  -914500,  -937054,  -959608,  -982162, -1004716, -1027270,\r\n -1049824, -1072378, -1094932, -1117486, -1140040, -1162594, -1185148, -1207702,\r\n -1230256, -1252810, -1275364, -1297918, -1320472, -1343026, -1365580, -1388134,\r\n -1410688, -1433242, -1455796, -1478350, -1500904, -1523458, -1546012, -1568566,\r\n -1591120, -1613674, -1636228, -1658782, -1681336, -1703890, -1726444, -1748998,\r\n -1771552, -1794106, -1816660, -1839214, -1861768, -1884322, -1906876, -1929430,\r\n -1951984, -1974538, -1997092, -2019646, -2042200, -2064754, -2087308, -2109862,\r\n -2132416, -2154970, -2177524, -2200078, -2222632, -2245186, -2267740, -2290294,\r\n -2312848, -2335402, -2357956, -2380510, -2403064, -2425618, -2448172, -2470726,\r\n -2493280, -2515834, -2538388, -2560942, -2583496, -2606050, -2628604, -2651158,\r\n -2673712, -2696266, -2718820, -2741374, -2763928, -2786482, -2809036, -2831590,\r\n};\r\n\r\nstatic const uint8_t kRangeLimitLut[4 * 256] = {\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\r\n  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,\r\n  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,\r\n  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,\r\n  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,\r\n  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,\r\n  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,\r\n  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\r\n 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,\r\n 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\r\n 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\r\n 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\r\n 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,\r\n 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,\r\n 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\r\n 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\r\n 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n};\r\n\r\nstatic const uint8_t* kRangeLimit = kRangeLimitLut + 384;\r\n\r\ninline void ColorTransformYCbCrToRGB(uint8_t* pixel) {\r\n  int y  = pixel[0];\r\n  int cb = pixel[1];\r\n  int cr = pixel[2];\r\n  pixel[0] = kRangeLimit[y + kCrToRedTable[cr]];\r\n  pixel[1] = kRangeLimit[y +\r\n                         ((kCrToGreenTable[cr] + kCbToGreenTable[cb]) >> 16)];\r\n  pixel[2] = kRangeLimit[y + kCbToBlueTable[cb]];\r\n}\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_COLOR_TRANSFORM_H_\r\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());             \n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n#include <cassert>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t           length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\nint\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\nsize_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\nconst _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? 0 : memcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s) {return strlen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return __n == 0 ? NULL : (const char_type*) memchr(__s, to_int_type(__a), __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? 0 : wmemcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s)\n        {return wcslen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return __n == 0 ? NULL : (const char_type*)wmemchr(__s, __a, __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t           length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline\nsize_t\nchar_traits<char16_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t           length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline\nsize_t\nchar_traits<char32_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz || __sz - __pos < __n)\n        return __npos;\n    if (__n == 0)\n        return __pos;\n    const _CharT* __r = \n        _VSTD::__search(__p + __pos, __p + __sz,\n                        __s, __s + __n, _Traits::eq,\n                        random_access_iterator_tag(), random_access_iterator_tag()).first;\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\nsize_t _LIBCPP_INLINE_VISIBILITY __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TYPE_VIS_ONLY __basic_string_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"basic_string\");\n#else\n    assert(!\"basic_string length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"basic_string\");\n#else\n    assert(!\"basic_string out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const allocator_type& __a = allocator_type());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const allocator_type& __a = allocator_type());\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos);\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        append(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        append(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    void __init(const value_type* __s, size_type __sz);\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value\n             || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)\n{\n\tbasic_string __temp (__first, __last, __alloc());\n\tappend(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n          && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer() + __sz;\n        for (; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n        traits_type::assign(*__p, value_type());\n        __set_size(__sz + __n);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value || \n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __str.size();\n    int __result = traits_type::compare(data(), __str.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    size_type __sz = __str.size();\n    if (__pos2 > __sz)\n        this->__throw_out_of_range();\n    return compare(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2,\n                                                                  __sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\n// operator!=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/score.h\"\r\n\r\n#include <cmath>\r\n\r\nnamespace guetzli {\r\n\r\ndouble ScoreJPEG(double butteraugli_distance, int size,\r\n                 double butteraugli_target) {\r\n  constexpr double kScale = 50;\r\n  constexpr double kMaxExponent = 10;\r\n  constexpr double kLargeSize = 1e30;\r\n  // TODO(user): The score should also depend on distance below target (and be\r\n  // smooth).\r\n  double diff = butteraugli_distance - butteraugli_target;\r\n  if (diff <= 0.0) {\r\n    return size;\r\n  } else {\r\n    double exponent = kScale * diff;\r\n    if (exponent > kMaxExponent) {\r\n      return kLargeSize * std::exp(kMaxExponent) * diff + size;\r\n    } else {\r\n      return std::exp(exponent) * size;\r\n    }\r\n  }\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/butteraugli_comparator.h\"\r\n\r\n#include <algorithm>\r\n\r\n#include \"guetzli/debug_print.h\"\r\n//#include \"guetzli/gamma_correct.cc\"\r\n#include \"guetzli/score.cc\"\r\n\r\nnamespace guetzli {\r\n\r\nnamespace {\r\nusing ::butteraugli::ConstRestrict;\r\nusing ::butteraugli::ImageF;\r\nusing ::butteraugli::CreatePlanes;\r\nusing ::butteraugli::PlanesFromPacked;\r\nusing ::butteraugli::PackedFromPlanes;\r\n\r\nstd::vector<ImageF> LinearRgb(const size_t xsize, const size_t ysize,\r\n                              const std::vector<uint8_t>& rgb) {\r\n  const double* lut = Srgb8ToLinearTable();\r\n  std::vector<ImageF> planes = CreatePlanes<float>(xsize, ysize, 3);\r\n  for (int c = 0; c < 3; ++c) {\r\n    for (size_t y = 0; y < ysize; ++y) {\r\n      ConstRestrict<const uint8_t*> row_in = &rgb[3 * xsize * y];\r\n      ConstRestrict<float*> row_out = planes[c].Row(y);\r\n      for (size_t x = 0; x < xsize; ++x) {\r\n        row_out[x] = lut[row_in[3 * x + c]];\r\n      }\r\n    }\r\n  }\r\n  return planes;\r\n}\r\n\r\n}  // namespace\r\n\r\nButteraugliComparator::ButteraugliComparator(const int width, const int height,\r\n                                             const std::vector<uint8_t>& rgb,\r\n                                             const float target_distance,\r\n                                             ProcessStats* stats)\r\n    : width_(width),\r\n      height_(height),\r\n      target_distance_(target_distance),\r\n      comparator_(width_, height_, kButteraugliStep),\r\n      distance_(0.0),\r\n      distmap_(width_, height_),\r\n      stats_(stats) {\r\n  rgb_linear_pregamma_ = LinearRgb(width, height, rgb);\r\n  const int block_w = (width_ + 7) / 8;\r\n  const int block_h = (height_ + 7) / 8;\r\n  const int nblocks = block_w * block_h;\r\n  per_block_pregamma_.resize(nblocks);\r\n  for (int block_y = 0, bx = 0; block_y < block_h; ++block_y) {\r\n    for (int block_x = 0; block_x < block_w; ++block_x, ++bx) {\r\n      per_block_pregamma_[bx].resize(3, std::vector<float>(kDCTBlockSize));\r\n      for (int iy = 0, i = 0; iy < 8; ++iy) {\r\n        for (int ix = 0; ix < 8; ++ix, ++i) {\r\n          int x = std::min(8 * block_x + ix, width_ - 1);\r\n          int y = std::min(8 * block_y + iy, height_ - 1);\r\n          for (int c = 0; c < 3; ++c) {\r\n            ConstRestrict<const float*> row_linear =\r\n                rgb_linear_pregamma_[c].Row(y);\r\n            per_block_pregamma_[bx][c][i] = row_linear[x];\r\n          }\r\n        }\r\n      }\r\n      ::butteraugli::OpsinDynamicsImage(8, 8, per_block_pregamma_[bx]);\r\n    }\r\n  }\r\n  std::vector<std::vector<float>> pregamma =\r\n      PackedFromPlanes(rgb_linear_pregamma_);\r\n  ::butteraugli::OpsinDynamicsImage(width_, height_, pregamma);\r\n  rgb_linear_pregamma_ = PlanesFromPacked(width_, height_, pregamma);\r\n  std::vector<std::vector<float> > dummy(3);\r\n  ::butteraugli::Mask(pregamma, pregamma, width_, height_,\r\n                      &mask_xyz_, &dummy);\r\n}\r\n\r\nvoid ButteraugliComparator::Compare(const OutputImage& img) {\r\n  std::vector<std::vector<float> > rgb(3, std::vector<float>(width_ * height_));\r\n  img.ToLinearRGB(&rgb);\r\n  ::butteraugli::OpsinDynamicsImage(width_, height_, rgb);\r\n  ImageF distmap;\r\n  const std::vector<ImageF> rgb_planes = PlanesFromPacked(width_, height_, rgb);\r\n  comparator_.DiffmapOpsinDynamicsImage(rgb_linear_pregamma_,\r\n                                        rgb_planes, distmap);\r\n  distmap_.resize(width_ * height_);\r\n  CopyToPacked(distmap, &distmap_);\r\n  distance_ = ::butteraugli::ButteraugliScoreFromDiffmap(distmap);\r\n  GUETZLI_LOG(stats_, \" BA[100.00%%] D[%6.4f]\", distance_);\r\n}\r\n\r\ndouble ButteraugliComparator::CompareBlock(\r\n    const OutputImage& img, int block_x, int block_y) const {\r\n  int xmin = 8 * block_x;\r\n  int ymin = 8 * block_y;\r\n  int block_ix = block_y * ((width_ + 7) / 8) + block_x;\r\n  const std::vector<std::vector<float> >& rgb0_c =\r\n      per_block_pregamma_[block_ix];\r\n\r\n  std::vector<std::vector<float> > rgb1_c(3, std::vector<float>(kDCTBlockSize));\r\n  img.ToLinearRGB(xmin, ymin, 8, 8, &rgb1_c);\r\n  ::butteraugli::OpsinDynamicsImage(8, 8, rgb1_c);\r\n\r\n  std::vector<std::vector<float> > rgb0 = rgb0_c;\r\n  std::vector<std::vector<float> > rgb1 = rgb1_c;\r\n\r\n  ::butteraugli::MaskHighIntensityChange(8, 8, rgb0_c, rgb1_c, rgb0, rgb1);\r\n\r\n  double b0[3 * kDCTBlockSize];\r\n  double b1[3 * kDCTBlockSize];\r\n  for (int c = 0; c < 3; ++c) {\r\n    for (int ix = 0; ix < kDCTBlockSize; ++ix) {\r\n      b0[c * kDCTBlockSize + ix] = rgb0[c][ix];\r\n      b1[c * kDCTBlockSize + ix] = rgb1[c][ix];\r\n    }\r\n  }\r\n  double diff_xyz_dc[3] = { 0.0 };\r\n  double diff_xyz_ac[3] = { 0.0 };\r\n  double diff_xyz_edge_dc[3] = { 0.0 };\r\n  ::butteraugli::ButteraugliBlockDiff(\r\n       b0, b1, diff_xyz_dc, diff_xyz_ac, diff_xyz_edge_dc);\r\n\r\n  double scale[3];\r\n  for (int c = 0; c < 3; ++c) {\r\n    scale[c] = mask_xyz_[c][ymin * width_ + xmin];\r\n  }\r\n\r\n  static const double kEdgeWeight = 0.05;\r\n\r\n  double diff = 0.0;\r\n  double diff_edge = 0.0;\r\n  for (int c = 0; c < 3; ++c) {\r\n    diff += diff_xyz_dc[c] * scale[c];\r\n    diff += diff_xyz_ac[c] * scale[c];\r\n    diff_edge += diff_xyz_edge_dc[c] * scale[c];\r\n  }\r\n  return sqrt((1 - kEdgeWeight) * diff + kEdgeWeight * diff_edge);\r\n}\r\n\r\nfloat ButteraugliComparator::BlockErrorLimit() const {\r\n  return target_distance_;\r\n}\r\n\r\nvoid ButteraugliComparator::ComputeBlockErrorAdjustmentWeights(\r\n      int direction,\r\n      int max_block_dist,\r\n      double target_mul,\r\n      int factor_x, int factor_y,\r\n      const std::vector<float>& distmap,\r\n      std::vector<float>* block_weight) {\r\n  const double target_distance = target_distance_ * target_mul;\r\n  const int sizex = 8 * factor_x;\r\n  const int sizey = 8 * factor_y;\r\n  const int block_width = (width_ + sizex - 1) / sizex;\r\n  const int block_height = (height_ + sizey - 1) / sizey;\r\n  std::vector<float> max_dist_per_block(block_width * block_height);\r\n  for (int block_y = 0; block_y < block_height; ++block_y) {\r\n    for (int block_x = 0; block_x < block_width; ++block_x) {\r\n      int block_ix = block_y * block_width + block_x;\r\n      int x_max = std::min(width_, sizex * (block_x + 1));\r\n      int y_max = std::min(height_, sizey * (block_y + 1));\r\n      float max_dist = 0.0;\r\n      for (int y = sizey * block_y; y < y_max; ++y) {\r\n        for (int x = sizex * block_x; x < x_max; ++x) {\r\n          max_dist = std::max(max_dist, distmap[y * width_ + x]);\r\n        }\r\n      }\r\n      max_dist_per_block[block_ix] = max_dist;\r\n    }\r\n  }\r\n  for (int block_y = 0; block_y < block_height; ++block_y) {\r\n    for (int block_x = 0; block_x < block_width; ++block_x) {\r\n      int block_ix = block_y * block_width + block_x;\r\n      float max_local_dist = target_distance;\r\n      int x_min = std::max(0, block_x - max_block_dist);\r\n      int y_min = std::max(0, block_y - max_block_dist);\r\n      int x_max = std::min(block_width, block_x + 1 + max_block_dist);\r\n      int y_max = std::min(block_height, block_y + 1 + max_block_dist);\r\n      for (int y = y_min; y < y_max; ++y) {\r\n        for (int x = x_min; x < x_max; ++x) {\r\n          max_local_dist =\r\n              std::max(max_local_dist, max_dist_per_block[y * block_width + x]);\r\n        }\r\n      }\r\n      if (direction > 0) {\r\n        if (max_dist_per_block[block_ix] <= target_distance &&\r\n            max_local_dist <= 1.1 * target_distance) {\r\n          (*block_weight)[block_ix] = 1.0;\r\n        }\r\n      } else {\r\n        constexpr double kLocalMaxWeight = 0.5;\r\n        if (max_dist_per_block[block_ix] <=\r\n            (1 - kLocalMaxWeight) * target_distance +\r\n            kLocalMaxWeight * max_local_dist) {\r\n          continue;\r\n        }\r\n        for (int y = y_min; y < y_max; ++y) {\r\n          for (int x = x_min; x < x_max; ++x) {\r\n            int d = std::max(std::abs(y - block_y), std::abs(x - block_x));\r\n            int ix = y * block_width + x;\r\n            (*block_weight)[ix] = std::max<float>(\r\n                (*block_weight)[ix], 1.0 / (d + 1.0));\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ndouble ButteraugliComparator::ScoreOutputSize(int size) const {\r\n  return ScoreJPEG(distance_, size, target_distance_);\r\n}\r\n\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#ifndef GUETZLI_COMPARATOR_H_\r\n#define GUETZLI_COMPARATOR_H_\r\n\r\n#include <vector>\r\n\r\n#include \"guetzli/output_image.h\"\r\n#include \"guetzli/stats.h\"\r\n\r\nnamespace guetzli {\r\n\r\n// Represents a baseline image, a comparison metric and an image acceptance\r\n// criteria based on this metric.\r\nclass Comparator {\r\n public:\r\n  Comparator() {}\r\n  virtual ~Comparator() {}\r\n\r\n  // Compares img with the baseline image and saves the resulting distance map\r\n  // inside the object. The provided image must have the same dimensions as the\r\n  // baseline image.\r\n  virtual void Compare(const OutputImage& img) = 0;\r\n\r\n  // Compares an 8x8 block of the baseline image with the same block of img and\r\n  // returns the resulting per-block distance. The interpretation of the\r\n  // returned distance depends on the comparator used.\r\n  virtual double CompareBlock(const OutputImage& img,\r\n                              int block_x, int block_y) const = 0;\r\n\r\n  // Returns the combined score of the output image in the last Compare() call\r\n  // (or the baseline image, if Compare() was not called yet), based on output\r\n  // size and the similarity metric.\r\n  virtual double ScoreOutputSize(int size) const = 0;\r\n\r\n  // Returns true if the argument of the last Compare() call (or the baseline\r\n  // image, if Compare() was not called yet) meets the image acceptance\r\n  // criteria. The target_mul modifies the acceptance criteria used in this call\r\n  // the following way:\r\n  //    = 1.0 : the original acceptance criteria is used,\r\n  //    < 1.0 : a more strict acceptance criteria is used,\r\n  //    > 1.0 : a less strict acceptance criteria is used.\r\n  virtual bool DistanceOK(double target_mul) const = 0;\r\n\r\n  // Returns the distance map between the baseline image and the image in the\r\n  // last Compare() call (or the baseline image, if Compare() was not called\r\n  // yet).\r\n  // The dimensions of the distance map are the same as the baseline image.\r\n  // The interpretation of the distance values depend on the comparator used.\r\n  virtual const std::vector<float> distmap() const = 0;\r\n\r\n  // Returns an aggregate distance or similarity value between the baseline\r\n  // image and the image in the last Compare() call (or the baseline image, if\r\n  // Compare() was not called yet).\r\n  // The interpretation of this aggregate value depends on the comparator used.\r\n  virtual float distmap_aggregate() const = 0;\r\n\r\n  // Returns a heuristic cutoff on block errors in the sense that we won't\r\n  // consider distortions where a block error is greater than this.\r\n  virtual float BlockErrorLimit() const = 0;\r\n  // Given the search direction (+1 for upwards and -1 for downwards) and the\r\n  // current distance map, fills in *block_weight image with the relative block\r\n  // error adjustment weights.\r\n  // The target_mul param has the same semantics as in DistanceOK().\r\n  // Note that this is essentially a static function in the sense that it does\r\n  // not depend on the last Compare() call.\r\n  virtual void ComputeBlockErrorAdjustmentWeights(\r\n      int direction, int max_block_dist, double target_mul, int factor_x,\r\n      int factor_y, const std::vector<float>& distmap,\r\n      std::vector<float>* block_weight) = 0;\r\n};\r\n\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_COMPARATOR_H_\r\n","// Copyright 2016 Google Inc. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// Disclaimer: This is not an official Google product.\r\n//\r\n// Author: Jyrki Alakuijala (jyrki.alakuijala@gmail.com)\r\n\r\n#ifndef BUTTERAUGLI_BUTTERAUGLI_H_\r\n#define BUTTERAUGLI_BUTTERAUGLI_H_\r\n\r\n#include <cassert>\r\n#include <cmath>\r\n#include <cstdint>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <memory>\r\n#include <vector>\r\n\r\n#ifndef PROFILER_ENABLED\r\n#define PROFILER_ENABLED 0\r\n#endif\r\n#if PROFILER_ENABLED\r\n#else\r\n#define PROFILER_FUNC\r\n#define PROFILER_ZONE(name)\r\n#endif\r\n\r\n#define BUTTERAUGLI_ENABLE_CHECKS 0\r\n\r\n// This is the main interface to butteraugli image similarity\r\n// analysis function.\r\n\r\nnamespace butteraugli {\r\n\r\ntemplate<typename T>\r\nclass Image;\r\n\r\nusing Image8 = Image<uint8_t>;\r\nusing ImageF = Image<float>;\r\nusing ImageD = Image<double>;\r\n\r\n// ButteraugliInterface defines the public interface for butteraugli.\r\n//\r\n// It calculates the difference between rgb0 and rgb1.\r\n//\r\n// rgb0 and rgb1 contain the images. rgb0[c][px] and rgb1[c][px] contains\r\n// the red image for c == 0, green for c == 1, blue for c == 2. Location index\r\n// px is calculated as y * xsize + x.\r\n//\r\n// Value of pixels of images rgb0 and rgb1 need to be represented as raw\r\n// intensity. Most image formats store gamma corrected intensity in pixel\r\n// values. This gamma correction has to be removed, by applying the following\r\n// function:\r\n// butteraugli_val = 255.0 * pow(png_val / 255.0, gamma);\r\n// A typical value of gamma is 2.2. It is usually stored in the image header.\r\n// Take care not to confuse that value with its inverse. The gamma value should\r\n// be always greater than one.\r\n// Butteraugli does not work as intended if the caller does not perform\r\n// gamma correction.\r\n//\r\n// diffmap will contain an image of the size xsize * ysize, containing\r\n// localized differences for values px (indexed with the px the same as rgb0\r\n// and rgb1). diffvalue will give a global score of similarity.\r\n//\r\n// A diffvalue smaller than kButteraugliGood indicates that images can be\r\n// observed as the same image.\r\n// diffvalue larger than kButteraugliBad indicates that a difference between\r\n// the images can be observed.\r\n// A diffvalue between kButteraugliGood and kButteraugliBad indicates that\r\n// a subtle difference can be observed between the images.\r\n//\r\n// Returns true on success.\r\n\r\nbool ButteraugliInterface(const std::vector<ImageF> &rgb0,\r\n                          const std::vector<ImageF> &rgb1,\r\n                          ImageF &diffmap,\r\n                          double &diffvalue);\r\n\r\nconst double kButteraugliQuantLow = 0.26;\r\nconst double kButteraugliQuantHigh = 1.454;\r\n\r\n// Converts the butteraugli score into fuzzy class values that are continuous\r\n// at the class boundary. The class boundary location is based on human\r\n// raters, but the slope is arbitrary. Particularly, it does not reflect\r\n// the expectation value of probabilities of the human raters. It is just\r\n// expected that a smoother class boundary will allow for higher-level\r\n// optimization algorithms to work faster.\r\n//\r\n// Returns 2.0 for a perfect match, and 1.0 for 'ok', 0.0 for bad. Because the\r\n// scoring is fuzzy, a butteraugli score of 0.96 would return a class of\r\n// around 1.9.\r\ndouble ButteraugliFuzzyClass(double score);\r\n\r\n// Input values should be in range 0 (bad) to 2 (good). Use\r\n// kButteraugliNormalization as normalization.\r\ndouble ButteraugliFuzzyInverse(double seek);\r\n\r\n// Returns a map which can be used for adaptive quantization. Values can\r\n// typically range from kButteraugliQuantLow to kButteraugliQuantHigh. Low\r\n// values require coarse quantization (e.g. near random noise), high values\r\n// require fine quantization (e.g. in smooth bright areas).\r\nbool ButteraugliAdaptiveQuantization(size_t xsize, size_t ysize,\r\n    const std::vector<std::vector<float> > &rgb, std::vector<float> &quant);\r\n\r\n// Implementation details, don't use anything below or your code will\r\n// break in the future.\r\n\r\n#ifdef _MSC_VER\r\n#define BUTTERAUGLI_RESTRICT\r\n#else\r\n#define BUTTERAUGLI_RESTRICT __restrict__\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#define BUTTERAUGLI_CACHE_ALIGNED_RETURN /* not supported */\r\n#else\r\n#define BUTTERAUGLI_CACHE_ALIGNED_RETURN __attribute__((assume_aligned(64)))\r\n#endif\r\n\r\n// Alias for unchangeable, non-aliased pointers. T is a pointer type,\r\n// possibly to a const type. Example: ConstRestrict<uint8_t*> ptr = nullptr.\r\n// The conventional syntax uint8_t* const RESTRICT is more confusing - it is\r\n// not immediately obvious that the pointee is non-const.\r\ntemplate <typename T>\r\nusing ConstRestrict = T const BUTTERAUGLI_RESTRICT;\r\n\r\n// Functions that depend on the cache line size.\r\nclass CacheAligned {\r\n public:\r\n  static constexpr size_t kPointerSize = sizeof(void *);\r\n  static constexpr size_t kCacheLineSize = 64;\r\n\r\n  // The aligned-return annotation is only allowed on function declarations.\r\n  static void *Allocate(const size_t bytes) BUTTERAUGLI_CACHE_ALIGNED_RETURN;\r\n  static void Free(void *aligned_pointer);\r\n};\r\n\r\ntemplate <typename T>\r\nusing CacheAlignedUniquePtrT = std::unique_ptr<T[], void (*)(void *)>;\r\n\r\nusing CacheAlignedUniquePtr = CacheAlignedUniquePtrT<uint8_t>;\r\n\r\ntemplate <typename T = uint8_t>\r\nstatic inline CacheAlignedUniquePtrT<T> Allocate(const size_t entries) {\r\n  return CacheAlignedUniquePtrT<T>(\r\n      static_cast<ConstRestrict<T *>>(\r\n          CacheAligned::Allocate(entries * sizeof(T))),\r\n      CacheAligned::Free);\r\n}\r\n\r\n// Returns the smallest integer not less than \"amount\" that is divisible by\r\n// \"multiple\", which must be a power of two.\r\ntemplate <size_t multiple>\r\nstatic inline size_t Align(const size_t amount) {\r\n  static_assert(multiple != 0 && ((multiple & (multiple - 1)) == 0),\r\n                \"Align<> argument must be a power of two\");\r\n  return (amount + multiple - 1) & ~(multiple - 1);\r\n}\r\n\r\n// Single channel, contiguous (cache-aligned) rows separated by padding.\r\n// T must be POD.\r\n//\r\n// Rationale: vectorization benefits from aligned operands - unaligned loads and\r\n// especially stores are expensive when the address crosses cache line\r\n// boundaries. Introducing padding after each row ensures the start of a row is\r\n// aligned, and that row loops can process entire vectors (writes to the padding\r\n// are allowed and ignored).\r\n//\r\n// We prefer a planar representation, where channels are stored as separate\r\n// 2D arrays, because that simplifies vectorization (repeating the same\r\n// operation on multiple adjacent components) without the complexity of a\r\n// hybrid layout (8 R, 8 G, 8 B, ...). In particular, clients can easily iterate\r\n// over all components in a row and Image requires no knowledge of the pixel\r\n// format beyond the component type \"T\". The downside is that we duplicate the\r\n// xsize/ysize members for each channel.\r\n//\r\n// This image layout could also be achieved with a vector and a row accessor\r\n// function, but a class wrapper with support for \"deleter\" allows wrapping\r\n// existing memory allocated by clients without copying the pixels. It also\r\n// provides convenient accessors for xsize/ysize, which shortens function\r\n// argument lists. Supports move-construction so it can be stored in containers.\r\ntemplate <typename ComponentType>\r\nclass Image {\r\n  // Returns cache-aligned row stride, being careful to avoid 2K aliasing.\r\n  static size_t BytesPerRow(const size_t xsize) {\r\n    // Allow reading one extra AVX-2 vector on the right margin.\r\n    const size_t row_size = xsize * sizeof(T) + 32;\r\n    const size_t align = CacheAligned::kCacheLineSize;\r\n    size_t bytes_per_row = (row_size + align - 1) & ~(align - 1);\r\n    // During the lengthy window before writes are committed to memory, CPUs\r\n    // guard against read after write hazards by checking the address, but\r\n    // only the lower 11 bits. We avoid a false dependency between writes to\r\n    // consecutive rows by ensuring their sizes are not multiples of 2 KiB.\r\n    if (bytes_per_row % 2048 == 0) {\r\n      bytes_per_row += align;\r\n    }\r\n    return bytes_per_row;\r\n  }\r\n\r\n public:\r\n  using T = ComponentType;\r\n\r\n  Image() : xsize_(0), ysize_(0), bytes_per_row_(0), bytes_(static_cast<uint8_t*>(nullptr), Ignore) {}\r\n\r\n  Image(const size_t xsize, const size_t ysize)\r\n      : xsize_(xsize),\r\n        ysize_(ysize),\r\n        bytes_per_row_(BytesPerRow(xsize)),\r\n        bytes_(Allocate(bytes_per_row_ * ysize)) {}\r\n\r\n  Image(const size_t xsize, const size_t ysize, ConstRestrict<uint8_t *> bytes,\r\n        const size_t bytes_per_row)\r\n      : xsize_(xsize),\r\n        ysize_(ysize),\r\n        bytes_per_row_(bytes_per_row),\r\n        bytes_(bytes, Ignore) {}\r\n\r\n  // Move constructor (required for returning Image from function)\r\n  Image(Image &&other)\r\n      : xsize_(other.xsize_),\r\n        ysize_(other.ysize_),\r\n        bytes_per_row_(other.bytes_per_row_),\r\n        bytes_(std::move(other.bytes_)) {}\r\n\r\n  // Move assignment (required for std::vector)\r\n  Image &operator=(Image &&other) {\r\n    xsize_ = other.xsize_;\r\n    ysize_ = other.ysize_;\r\n    bytes_per_row_ = other.bytes_per_row_;\r\n    bytes_ = std::move(other.bytes_);\r\n    return *this;\r\n  }\r\n\r\n  void Swap(Image &other) {\r\n    std::swap(xsize_, other.xsize_);\r\n    std::swap(ysize_, other.ysize_);\r\n    std::swap(bytes_per_row_, other.bytes_per_row_);\r\n    std::swap(bytes_, other.bytes_);\r\n  }\r\n\r\n  // How many pixels.\r\n  size_t xsize() const { return xsize_; }\r\n  size_t ysize() const { return ysize_; }\r\n\r\n  ConstRestrict<T *> Row(const size_t y) BUTTERAUGLI_CACHE_ALIGNED_RETURN {\r\n#ifdef BUTTERAUGLI_ENABLE_CHECKS\r\n    if (y >= ysize_) {\r\n      printf(\"Row %zu out of bounds (ysize=%zu)\\n\", y, ysize_);\r\n      abort();\r\n    }\r\n#endif\r\n    return reinterpret_cast<T *>(bytes_.get() + y * bytes_per_row_);\r\n  }\r\n\r\n  ConstRestrict<const T *> Row(const size_t y) const\r\n      BUTTERAUGLI_CACHE_ALIGNED_RETURN {\r\n#ifdef BUTTERAUGLI_ENABLE_CHECKS\r\n    if (y >= ysize_) {\r\n      printf(\"Const row %zu out of bounds (ysize=%zu)\\n\", y, ysize_);\r\n      abort();\r\n    }\r\n#endif\r\n    return reinterpret_cast<const T *>(bytes_.get() + y * bytes_per_row_);\r\n  }\r\n\r\n  // Raw access to byte contents, for interfacing with other libraries.\r\n  // Unsigned char instead of char to avoid surprises (sign extension).\r\n  ConstRestrict<uint8_t *> bytes() { return bytes_.get(); }\r\n  ConstRestrict<const uint8_t *> bytes() const { return bytes_.get(); }\r\n  size_t bytes_per_row() const { return bytes_per_row_; }\r\n\r\n  // Returns number of pixels (some of which are padding) per row. Useful for\r\n  // computing other rows via pointer arithmetic.\r\n  intptr_t PixelsPerRow() const {\r\n    static_assert(CacheAligned::kCacheLineSize % sizeof(T) == 0,\r\n                  \"Padding must be divisible by the pixel size.\");\r\n    return static_cast<intptr_t>(bytes_per_row_ / sizeof(T));\r\n  }\r\n\r\n private:\r\n  // Deleter used when bytes are not owned.\r\n  static void Ignore(void *ptr) {}\r\n\r\n  // (Members are non-const to enable assignment during move-assignment.)\r\n  size_t xsize_;  // original intended pixels, not including any padding.\r\n  size_t ysize_;\r\n  size_t bytes_per_row_;  // [bytes] including padding.\r\n  CacheAlignedUniquePtr bytes_;\r\n};\r\n\r\n// Returns newly allocated planes of the given dimensions.\r\ntemplate <typename T>\r\nstatic inline std::vector<Image<T>> CreatePlanes(const size_t xsize,\r\n                                                 const size_t ysize,\r\n                                                 const size_t num_planes) {\r\n  std::vector<Image<T>> planes;\r\n  planes.reserve(num_planes);\r\n  for (size_t i = 0; i < num_planes; ++i) {\r\n    planes.emplace_back(xsize, ysize);\r\n  }\r\n  return planes;\r\n}\r\n\r\n// Returns a new image with the same dimensions and pixel values.\r\ntemplate <typename T>\r\nstatic inline Image<T> CopyPixels(const Image<T> &other) {\r\n  Image<T> copy(other.xsize(), other.ysize());\r\n  const void *BUTTERAUGLI_RESTRICT from = other.bytes();\r\n  void *BUTTERAUGLI_RESTRICT to = copy.bytes();\r\n  memcpy(to, from, other.ysize() * other.bytes_per_row());\r\n  return copy;\r\n}\r\n\r\n// Returns new planes with the same dimensions and pixel values.\r\ntemplate <typename T>\r\nstatic inline std::vector<Image<T>> CopyPlanes(\r\n    const std::vector<Image<T>> &planes) {\r\n  std::vector<Image<T>> copy;\r\n  copy.reserve(planes.size());\r\n  for (const Image<T> &plane : planes) {\r\n    copy.push_back(CopyPixels(plane));\r\n  }\r\n  return copy;\r\n}\r\n\r\n// Compacts a padded image into a preallocated packed vector.\r\ntemplate <typename T>\r\nstatic inline void CopyToPacked(const Image<T> &from, std::vector<T> *to) {\r\n  const size_t xsize = from.xsize();\r\n  const size_t ysize = from.ysize();\r\n#if BUTTERAUGLI_ENABLE_CHECKS\r\n  if (to->size() < xsize * ysize) {\r\n    printf(\"%zu x %zu exceeds %zu capacity\\n\", xsize, ysize, to->size());\r\n    abort();\r\n  }\r\n#endif\r\n  for (size_t y = 0; y < ysize; ++y) {\r\n    ConstRestrict<const float*> row_from = from.Row(y);\r\n    ConstRestrict<float*> row_to = to->data() + y * xsize;\r\n    memcpy(row_to, row_from, xsize * sizeof(T));\r\n  }\r\n}\r\n\r\n// Expands a packed vector into a preallocated padded image.\r\ntemplate <typename T>\r\nstatic inline void CopyFromPacked(const std::vector<T> &from, Image<T> *to) {\r\n  const size_t xsize = to->xsize();\r\n  const size_t ysize = to->ysize();\r\n  assert(from.size() == xsize * ysize);\r\n  for (size_t y = 0; y < ysize; ++y) {\r\n    ConstRestrict<const float*> row_from = from.data() + y * xsize;\r\n    ConstRestrict<float*> row_to = to->Row(y);\r\n    memcpy(row_to, row_from, xsize * sizeof(T));\r\n  }\r\n}\r\n\r\ntemplate <typename T>\r\nstatic inline std::vector<Image<T>> PlanesFromPacked(\r\n    const size_t xsize, const size_t ysize,\r\n    const std::vector<std::vector<T>> &packed) {\r\n  std::vector<Image<T>> planes;\r\n  planes.reserve(packed.size());\r\n  for (const std::vector<T> &p : packed) {\r\n    planes.push_back(Image<T>(xsize, ysize));\r\n    CopyFromPacked(p, &planes.back());\r\n  }\r\n  return planes;\r\n}\r\n\r\ntemplate <typename T>\r\nstatic inline std::vector<std::vector<T>> PackedFromPlanes(\r\n    const std::vector<Image<T>> &planes) {\r\n  assert(!planes.empty());\r\n  const size_t num_pixels = planes[0].xsize() * planes[0].ysize();\r\n  std::vector<std::vector<T>> packed;\r\n  packed.reserve(planes.size());\r\n  for (const Image<T> &image : planes) {\r\n    packed.push_back(std::vector<T>(num_pixels));\r\n    CopyToPacked(image, &packed.back());\r\n  }\r\n  return packed;\r\n}\r\n\r\nclass ButteraugliComparator {\r\n public:\r\n  ButteraugliComparator(size_t xsize, size_t ysize, int step);\r\n\r\n  // Computes the butteraugli map between rgb0 and rgb1 and updates result.\r\n  void Diffmap(const std::vector<ImageF> &rgb0,\r\n               const std::vector<ImageF> &rgb1,\r\n               ImageF &result);\r\n\r\n  // Same as above, but OpsinDynamicsImage() was already applied to\r\n  // rgb0 and rgb1.\r\n  void DiffmapOpsinDynamicsImage(const std::vector<ImageF> &rgb0,\r\n                                 const std::vector<ImageF> &rgb1,\r\n                                 ImageF &result);\r\n\r\n private:\r\n  void BlockDiffMap(const std::vector<std::vector<float> > &rgb0,\r\n                    const std::vector<std::vector<float> > &rgb1,\r\n                    std::vector<float>* block_diff_dc,\r\n                    std::vector<float>* block_diff_ac);\r\n\r\n\r\n  void EdgeDetectorMap(const std::vector<std::vector<float> > &rgb0,\r\n                       const std::vector<std::vector<float> > &rgb1,\r\n                       std::vector<float>* edge_detector_map);\r\n\r\n  void EdgeDetectorLowFreq(const std::vector<std::vector<float> > &rgb0,\r\n                           const std::vector<std::vector<float> > &rgb1,\r\n                           std::vector<float>* block_diff_ac);\r\n\r\n  void CombineChannels(const std::vector<std::vector<float> >& scale_xyb,\r\n                       const std::vector<std::vector<float> >& scale_xyb_dc,\r\n                       const std::vector<float>& block_diff_dc,\r\n                       const std::vector<float>& block_diff_ac,\r\n                       const std::vector<float>& edge_detector_map,\r\n                       std::vector<float>* result);\r\n\r\n  const size_t xsize_;\r\n  const size_t ysize_;\r\n  const size_t num_pixels_;\r\n  const int step_;\r\n  const size_t res_xsize_;\r\n  const size_t res_ysize_;\r\n};\r\n\r\nvoid ButteraugliDiffmap(const std::vector<ImageF> &rgb0,\r\n                        const std::vector<ImageF> &rgb1,\r\n                        ImageF &diffmap);\r\n\r\ndouble ButteraugliScoreFromDiffmap(const ImageF& distmap);\r\n\r\n// Compute values of local frequency and dc masking based on the activity\r\n// in the two images.\r\nvoid Mask(const std::vector<std::vector<float> > &rgb0,\r\n          const std::vector<std::vector<float> > &rgb1,\r\n          size_t xsize, size_t ysize,\r\n          std::vector<std::vector<float> > *mask,\r\n          std::vector<std::vector<float> > *mask_dc);\r\n\r\n// Computes difference metrics for one 8x8 block.\r\nvoid ButteraugliBlockDiff(double rgb0[192],\r\n                          double rgb1[192],\r\n                          double diff_xyb_dc[3],\r\n                          double diff_xyb_ac[3],\r\n                          double diff_xyb_edge_dc[3]);\r\n\r\nvoid OpsinAbsorbance(const double in[3], double out[3]);\r\n\r\nvoid OpsinDynamicsImage(size_t xsize, size_t ysize,\r\n                        std::vector<std::vector<float> > &rgb);\r\n\r\nvoid MaskHighIntensityChange(\r\n    size_t xsize, size_t ysize,\r\n    const std::vector<std::vector<float> > &c0,\r\n    const std::vector<std::vector<float> > &c1,\r\n    std::vector<std::vector<float> > &rgb0,\r\n    std::vector<std::vector<float> > &rgb1);\r\n\r\nvoid Blur(size_t xsize, size_t ysize, float* channel, double sigma,\r\n          double border_ratio = 0.0);\r\n\r\nvoid RgbToXyb(double r, double g, double b,\r\n              double *valx, double *valy, double *valz);\r\n\r\ndouble SimpleGamma(double v);\r\n\r\ndouble GammaMinArg();\r\ndouble GammaMaxArg();\r\n\r\n// Polynomial evaluation via Clenshaw's scheme (similar to Horner's).\r\n// Template enables compile-time unrolling of the recursion, but must reside\r\n// outside of a class due to the specialization.\r\ntemplate <int INDEX>\r\nstatic inline void ClenshawRecursion(const double x, const double *coefficients,\r\n                                     double *b1, double *b2) {\r\n  const double x_b1 = x * (*b1);\r\n  const double t = (x_b1 + x_b1) - (*b2) + coefficients[INDEX];\r\n  *b2 = *b1;\r\n  *b1 = t;\r\n\r\n  ClenshawRecursion<INDEX - 1>(x, coefficients, b1, b2);\r\n}\r\n\r\n// Base case\r\ntemplate <>\r\ninline void ClenshawRecursion<0>(const double x, const double *coefficients,\r\n                                 double *b1, double *b2) {\r\n  const double x_b1 = x * (*b1);\r\n  // The final iteration differs - no 2 * x_b1 here.\r\n  *b1 = x_b1 - (*b2) + coefficients[0];\r\n}\r\n\r\n// Rational polynomial := dividing two polynomial evaluations. These are easier\r\n// to find than minimax polynomials.\r\nstruct RationalPolynomial {\r\n  template <int N>\r\n  static double EvaluatePolynomial(const double x,\r\n                                   const double (&coefficients)[N]) {\r\n    double b1 = 0.0;\r\n    double b2 = 0.0;\r\n    ClenshawRecursion<N - 1>(x, coefficients, &b1, &b2);\r\n    return b1;\r\n  }\r\n\r\n  // Evaluates the polynomial at x (in [min_value, max_value]).\r\n  inline double operator()(const float x) const {\r\n    // First normalize to [0, 1].\r\n    const double x01 = (x - min_value) / (max_value - min_value);\r\n    // And then to [-1, 1] domain of Chebyshev polynomials.\r\n    const double xc = 2.0 * x01 - 1.0;\r\n\r\n    const double yp = EvaluatePolynomial(xc, p);\r\n    const double yq = EvaluatePolynomial(xc, q);\r\n    if (yq == 0.0) return 0.0;\r\n    return static_cast<float>(yp / yq);\r\n  }\r\n\r\n  // Domain of the polynomials; they are undefined elsewhere.\r\n  double min_value;\r\n  double max_value;\r\n\r\n  // Coefficients of T_n (Chebyshev polynomials of the first kind).\r\n  // Degree 5/5 is a compromise between accuracy (0.1%) and numerical stability.\r\n  double p[5 + 1];\r\n  double q[5 + 1];\r\n};\r\n\r\nstatic inline float GammaPolynomial(float value) {\r\n  // Generated by gamma_polynomial.m from equispaced x/gamma(x) samples.\r\n  static const RationalPolynomial r = {\r\n  0.770000000000000, 274.579999999999984,\r\n  {\r\n    881.979476556478289, 1496.058452015812463, 908.662212739659481,\r\n    373.566100223287378, 85.840860336314364, 6.683258861509244,\r\n  },\r\n  {\r\n    12.262350348616792, 20.557285797683576, 12.161463238367844,\r\n    4.711532733641639, 0.899112889751053, 0.035662329617191,\r\n  }};\r\n  return r(value);\r\n}\r\n\r\n}  // namespace butteraugli\r\n\r\n#endif  // BUTTERAUGLI_BUTTERAUGLI_H_\r\n","// Copyright 2016 Google Inc. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// Author: Jyrki Alakuijala (jyrki.alakuijala@gmail.com)\r\n//\r\n// The physical architecture of butteraugli is based on the following naming\r\n// convention:\r\n//   * Opsin - dynamics of the photosensitive chemicals in the retina\r\n//             with their immediate electrical processing\r\n//   * Xyb - hybrid opponent/trichromatic color space\r\n//     x is roughly red-subtract-green.\r\n//     y is yellow.\r\n//     b is blue.\r\n//     Xyb values are computed from Opsin mixing, not directly from rgb.\r\n//   * Mask - for visual masking\r\n//   * Hf - color modeling for spatially high-frequency features\r\n//   * Lf - color modeling for spatially low-frequency features\r\n//   * Diffmap - to cluster and build an image of error between the images\r\n//   * Blur - to hold the smoothing code\r\n\r\n#include \"butteraugli/butteraugli.h\"\r\n\r\n#include <assert.h>\r\n#include <math.h>\r\n#include <stdint.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#include <algorithm>\r\n#include <array>\r\n\r\n// Restricted pointers speed up Convolution(); MSVC uses a different keyword.\r\n#ifdef _MSC_VER\r\n#define __restrict__ __restrict\r\n#endif\r\n\r\nnamespace butteraugli {\r\n\r\nvoid *CacheAligned::Allocate(const size_t bytes) {\r\n  char *const allocated = static_cast<char *>(malloc(bytes + kCacheLineSize));\r\n  if (allocated == nullptr) {\r\n    return nullptr;\r\n  }\r\n  const uintptr_t misalignment =\r\n      reinterpret_cast<uintptr_t>(allocated) & (kCacheLineSize - 1);\r\n  // malloc is at least kPointerSize aligned, so we can store the \"allocated\"\r\n  // pointer immediately before the aligned memory.\r\n  assert(misalignment % kPointerSize == 0);\r\n  char *const aligned = allocated + kCacheLineSize - misalignment;\r\n  memcpy(aligned - kPointerSize, &allocated, kPointerSize);\r\n  return aligned;\r\n}\r\n\r\nvoid CacheAligned::Free(void *aligned_pointer) {\r\n  if (aligned_pointer == nullptr) {\r\n    return;\r\n  }\r\n  char *const aligned = static_cast<char *>(aligned_pointer);\r\n  assert(reinterpret_cast<uintptr_t>(aligned) % kCacheLineSize == 0);\r\n  char *allocated;\r\n  memcpy(&allocated, aligned - kPointerSize, kPointerSize);\r\n  assert(allocated <= aligned - kPointerSize);\r\n  assert(allocated >= aligned - kCacheLineSize);\r\n  free(allocated);\r\n}\r\n\r\nstatic inline bool IsNan(const float x) {\r\n  uint32_t bits;\r\n  memcpy(&bits, &x, sizeof(bits));\r\n  const uint32_t bitmask_exp = 0x7F800000;\r\n  return (bits & bitmask_exp) == bitmask_exp && (bits & 0x7FFFFF);\r\n}\r\n\r\nstatic inline bool IsNan(const double x) {\r\n  uint64_t bits;\r\n  memcpy(&bits, &x, sizeof(bits));\r\n  return (0x7ff0000000000001ULL <= bits && bits <= 0x7fffffffffffffffULL) ||\r\n         (0xfff0000000000001ULL <= bits && bits <= 0xffffffffffffffffULL);\r\n}\r\n\r\nstatic inline void CheckImage(const ImageF &image, const char *name) {\r\n  for (size_t y = 0; y < image.ysize(); ++y) {\r\n    ConstRestrict<const float *> row = image.Row(y);\r\n    for (size_t x = 0; x < image.xsize(); ++x) {\r\n      if (IsNan(row[x])) {\r\n        printf(\"Image %s @ %lu,%lu (of %lu,%lu)\\n\", name, x, y, image.xsize(),\r\n               image.ysize());\r\n        exit(1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n#if BUTTERAUGLI_ENABLE_CHECKS\r\n\r\n#define CHECK_NAN(x, str)                \\\r\n  do {                                   \\\r\n    if (IsNan(x)) {                      \\\r\n      printf(\"%d: %s\\n\", __LINE__, str); \\\r\n      abort();                           \\\r\n    }                                    \\\r\n  } while (0)\r\n\r\n#define CHECK_IMAGE(image, name) CheckImage(image, name)\r\n\r\n#else\r\n\r\n#define CHECK_NAN(x, str)\r\n#define CHECK_IMAGE(image, name)\r\n\r\n#endif\r\n\r\n\r\nstatic const double kInternalGoodQualityThreshold = 14.921561160295326;\r\nstatic const double kGlobalScale = 1.0 / kInternalGoodQualityThreshold;\r\n\r\ninline double DotProduct(const double u[3], const double v[3]) {\r\n  return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];\r\n}\r\n\r\ninline double DotProduct(const float u[3], const double v[3]) {\r\n  return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];\r\n}\r\n\r\n// Computes a horizontal convolution and transposes the result.\r\nstatic void Convolution(size_t xsize, size_t ysize,\r\n                        size_t xstep,\r\n                        size_t len, size_t offset,\r\n                        const float* __restrict__ multipliers,\r\n                        const float* __restrict__ inp,\r\n                        double border_ratio,\r\n                        float* __restrict__ result) {\r\n  PROFILER_FUNC;\r\n  double weight_no_border = 0;\r\n  for (int j = 0; j <= 2 * offset; ++j) {\r\n    weight_no_border += multipliers[j];\r\n  }\r\n  for (size_t x = 0, ox = 0; x < xsize; x += xstep, ox++) {\r\n    int minx = x < offset ? 0 : x - offset;\r\n    int maxx = std::min(xsize, x + len - offset) - 1;\r\n    double weight = 0.0;\r\n    for (int j = minx; j <= maxx; ++j) {\r\n      weight += multipliers[j - x + offset];\r\n    }\r\n    // Interpolate linearly between the no-border scaling and border scaling.\r\n    weight = (1.0 - border_ratio) * weight + border_ratio * weight_no_border;\r\n    double scale = 1.0 / weight;\r\n    for (size_t y = 0; y < ysize; ++y) {\r\n      double sum = 0.0;\r\n      for (int j = minx; j <= maxx; ++j) {\r\n        sum += inp[y * xsize + j] * multipliers[j - x + offset];\r\n      }\r\n      result[ox * ysize + y] = sum * scale;\r\n    }\r\n  }\r\n}\r\n\r\nvoid Blur(size_t xsize, size_t ysize, float* channel, double sigma,\r\n          double border_ratio) {\r\n  PROFILER_FUNC;\r\n  double m = 2.25;  // Accuracy increases when m is increased.\r\n  const double scaler = -1.0 / (2 * sigma * sigma);\r\n  // For m = 9.0: exp(-scaler * diff * diff) < 2^ {-52}\r\n  const int diff = std::max<int>(1, m * fabs(sigma));\r\n  const int expn_size = 2 * diff + 1;\r\n  std::vector<float> expn(expn_size);\r\n  for (int i = -diff; i <= diff; ++i) {\r\n    expn[i + diff] = exp(scaler * i * i);\r\n  }\r\n  const int xstep = std::max(1, int(sigma / 3));\r\n  const int ystep = xstep;\r\n  int dxsize = (xsize + xstep - 1) / xstep;\r\n  int dysize = (ysize + ystep - 1) / ystep;\r\n  std::vector<float> tmp(dxsize * ysize);\r\n  std::vector<float> downsampled_output(dxsize * dysize);\r\n  Convolution(xsize, ysize, xstep, expn_size, diff, expn.data(), channel,\r\n              border_ratio,\r\n              tmp.data());\r\n  Convolution(ysize, dxsize, ystep, expn_size, diff, expn.data(), tmp.data(),\r\n              border_ratio,\r\n              downsampled_output.data());\r\n  for (int y = 0; y < ysize; y++) {\r\n    for (int x = 0; x < xsize; x++) {\r\n      // TODO: Use correct rounding.\r\n      channel[y * xsize + x] =\r\n          downsampled_output[(y / ystep) * dxsize + (x / xstep)];\r\n    }\r\n  }\r\n}\r\n\r\n// To change this to n, add the relevant FFTn function and kFFTnMapIndexTable.\r\nconstexpr size_t kBlockEdge = 8;\r\nconstexpr size_t kBlockSize = kBlockEdge * kBlockEdge;\r\nconstexpr size_t kBlockEdgeHalf = kBlockEdge / 2;\r\nconstexpr size_t kBlockHalf = kBlockEdge * kBlockEdgeHalf;\r\n\r\n// Contrast sensitivity related weights.\r\nstatic const double *GetContrastSensitivityMatrix() {\r\n  static double csf8x8[kBlockHalf + kBlockEdgeHalf + 1] = {\r\n    5.28270670524,\r\n    0.0,\r\n    0.0,\r\n    0.0,\r\n    0.3831134973,\r\n    0.676303603859,\r\n    3.58927792424,\r\n    18.6104367002,\r\n    18.6104367002,\r\n    3.09093131948,\r\n    1.0,\r\n    0.498250875965,\r\n    0.36198671102,\r\n    0.308982169883,\r\n    0.1312701920435,\r\n    2.37370549629,\r\n    3.58927792424,\r\n    1.0,\r\n    2.37370549629,\r\n    0.991205724152,\r\n    1.05178802919,\r\n    0.627264168628,\r\n    0.4,\r\n    0.1312701920435,\r\n    0.676303603859,\r\n    0.498250875965,\r\n    0.991205724152,\r\n    0.5,\r\n    0.3831134973,\r\n    0.349686450518,\r\n    0.627264168628,\r\n    0.308982169883,\r\n    0.3831134973,\r\n    0.36198671102,\r\n    1.05178802919,\r\n    0.3831134973,\r\n    0.12,\r\n  };\r\n  return &csf8x8[0];\r\n}\r\n\r\nstd::array<double, 21> MakeHighFreqColorDiffDx() {\r\n  std::array<double, 21> lut;\r\n  static const double off = 11.38708334481672;\r\n  static const double inc = 14.550189611520716;\r\n  lut[0] = 0.0;\r\n  lut[1] = off;\r\n  for (int i = 2; i < 21; ++i) {\r\n    lut[i] = lut[i - 1] + inc;\r\n  }\r\n  return lut;\r\n}\r\n\r\nconst double *GetHighFreqColorDiffDx() {\r\n  static const std::array<double, 21> kLut = MakeHighFreqColorDiffDx();\r\n  return kLut.data();\r\n}\r\n\r\nstd::array<double, 21> MakeHighFreqColorDiffDy() {\r\n  std::array<double, 21> lut;\r\n  static const double off = 1.4103373714040413;\r\n  static const double inc = 0.7084088867024;\r\n  lut[0] = 0.0;\r\n  lut[1] = off;\r\n  for (int i = 2; i < 21; ++i) {\r\n    lut[i] = lut[i - 1] + inc;\r\n  }\r\n  return lut;\r\n}\r\n\r\nconst double *GetHighFreqColorDiffDy() {\r\n  static const std::array<double, 21> kLut = MakeHighFreqColorDiffDy();\r\n  return kLut.data();\r\n}\r\n\r\nstd::array<double, 21> MakeLowFreqColorDiffDy() {\r\n  std::array<double, 21> lut;\r\n  static const double inc = 5.2511644570349185;\r\n  lut[0] = 0.0;\r\n  for (int i = 1; i < 21; ++i) {\r\n    lut[i] = lut[i - 1] + inc;\r\n  }\r\n  return lut;\r\n}\r\n\r\nconst double *GetLowFreqColorDiffDy() {\r\n  static const std::array<double, 21> kLut = MakeLowFreqColorDiffDy();\r\n  return kLut.data();\r\n}\r\n\r\ninline double Interpolate(const double *array, int size, double sx) {\r\n  double ix = fabs(sx);\r\n  assert(ix < 10000);\r\n  int baseix = static_cast<int>(ix);\r\n  double res;\r\n  if (baseix >= size - 1) {\r\n    res = array[size - 1];\r\n  } else {\r\n    double mix = ix - baseix;\r\n    int nextix = baseix + 1;\r\n    res = array[baseix] + mix * (array[nextix] - array[baseix]);\r\n  }\r\n  if (sx < 0) res = -res;\r\n  return res;\r\n}\r\n\r\ninline double InterpolateClampNegative(const double *array,\r\n                                       int size, double sx) {\r\n  if (sx < 0) {\r\n    sx = 0;\r\n  }\r\n  double ix = fabs(sx);\r\n  int baseix = static_cast<int>(ix);\r\n  double res;\r\n  if (baseix >= size - 1) {\r\n    res = array[size - 1];\r\n  } else {\r\n    double mix = ix - baseix;\r\n    int nextix = baseix + 1;\r\n    res = array[baseix] + mix * (array[nextix] - array[baseix]);\r\n  }\r\n  return res;\r\n}\r\n\r\nvoid RgbToXyb(double r, double g, double b,\r\n              double *valx, double *valy, double *valz) {\r\n  static const double a0 = 1.01611726948;\r\n  static const double a1 = 0.982482243696;\r\n  static const double a2 = 1.43571362627;\r\n  static const double a3 = 0.896039849412;\r\n  *valx = a0 * r - a1 * g;\r\n  *valy = a2 * r + a3 * g;\r\n  *valz = b;\r\n}\r\n\r\nstatic inline void XybToVals(double x, double y, double z,\r\n                             double *valx, double *valy, double *valz) {\r\n  static const double xmul = 0.758304045695;\r\n  static const double ymul = 2.28148649801;\r\n  static const double zmul = 1.87816926918;\r\n  *valx = Interpolate(GetHighFreqColorDiffDx(), 21, x * xmul);\r\n  *valy = Interpolate(GetHighFreqColorDiffDy(), 21, y * ymul);\r\n  *valz = zmul * z;\r\n}\r\n\r\n// Rough psychovisual distance to gray for low frequency colors.\r\nstatic void XybLowFreqToVals(double x, double y, double z,\r\n                             double *valx, double *valy, double *valz) {\r\n  static const double xmul = 6.64482198135;\r\n  static const double ymul = 0.837846224276;\r\n  static const double zmul = 7.34905756986;\r\n  static const double y_to_z_mul = 0.0812519812628;\r\n  z += y_to_z_mul * y;\r\n  *valz = z * zmul;\r\n  *valx = x * xmul;\r\n  *valy = Interpolate(GetLowFreqColorDiffDy(), 21, y * ymul);\r\n}\r\n\r\ndouble RemoveRangeAroundZero(double v, double range) {\r\n  if (v >= -range && v < range) {\r\n    return 0;\r\n  }\r\n  if (v < 0) {\r\n    return v + range;\r\n  } else {\r\n    return v - range;\r\n  }\r\n}\r\n\r\nvoid XybDiffLowFreqSquaredAccumulate(double r0, double g0, double b0,\r\n                                     double r1, double g1, double b1,\r\n                                     double factor, double res[3]) {\r\n  double valx0, valy0, valz0;\r\n  double valx1, valy1, valz1;\r\n  XybLowFreqToVals(r0, g0, b0, &valx0, &valy0, &valz0);\r\n  if (r1 == 0.0 && g1 == 0.0 && b1 == 0.0) {\r\n    PROFILER_ZONE(\"XybDiff r1=g1=b1=0\");\r\n    res[0] += factor * valx0 * valx0;\r\n    res[1] += factor * valy0 * valy0;\r\n    res[2] += factor * valz0 * valz0;\r\n    return;\r\n  }\r\n  XybLowFreqToVals(r1, g1, b1, &valx1, &valy1, &valz1);\r\n  // Approximate the distance of the colors by their respective distances\r\n  // to gray.\r\n  double valx = valx0 - valx1;\r\n  double valy = valy0 - valy1;\r\n  double valz = valz0 - valz1;\r\n  res[0] += factor * valx * valx;\r\n  res[1] += factor * valy * valy;\r\n  res[2] += factor * valz * valz;\r\n}\r\n\r\nstruct Complex {\r\n public:\r\n  double real;\r\n  double imag;\r\n};\r\n\r\ninline double abssq(const Complex& c) {\r\n  return c.real * c.real + c.imag * c.imag;\r\n}\r\n\r\nstatic void TransposeBlock(Complex data[kBlockSize]) {\r\n  for (int i = 0; i < kBlockEdge; i++) {\r\n    for (int j = 0; j < i; j++) {\r\n      std::swap(data[kBlockEdge * i + j], data[kBlockEdge * j + i]);\r\n    }\r\n  }\r\n}\r\n\r\n//  D. J. Bernstein's Fast Fourier Transform algorithm on 4 elements.\r\ninline void FFT4(Complex* a) {\r\n  double t1, t2, t3, t4, t5, t6, t7, t8;\r\n  t5 = a[2].real;\r\n  t1 = a[0].real - t5;\r\n  t7 = a[3].real;\r\n  t5 += a[0].real;\r\n  t3 = a[1].real - t7;\r\n  t7 += a[1].real;\r\n  t8 = t5 + t7;\r\n  a[0].real = t8;\r\n  t5 -= t7;\r\n  a[1].real = t5;\r\n  t6 = a[2].imag;\r\n  t2 = a[0].imag - t6;\r\n  t6 += a[0].imag;\r\n  t5 = a[3].imag;\r\n  a[2].imag = t2 + t3;\r\n  t2 -= t3;\r\n  a[3].imag = t2;\r\n  t4 = a[1].imag - t5;\r\n  a[3].real = t1 + t4;\r\n  t1 -= t4;\r\n  a[2].real = t1;\r\n  t5 += a[1].imag;\r\n  a[0].imag = t6 + t5;\r\n  t6 -= t5;\r\n  a[1].imag = t6;\r\n}\r\n\r\nstatic const double kSqrtHalf = 0.70710678118654752440084436210484903;\r\n\r\n//  D. J. Bernstein's Fast Fourier Transform algorithm on 8 elements.\r\nvoid FFT8(Complex* a) {\r\n  double t1, t2, t3, t4, t5, t6, t7, t8;\r\n\r\n  t7 = a[4].imag;\r\n  t4 = a[0].imag - t7;\r\n  t7 += a[0].imag;\r\n  a[0].imag = t7;\r\n\r\n  t8 = a[6].real;\r\n  t5 = a[2].real - t8;\r\n  t8 += a[2].real;\r\n  a[2].real = t8;\r\n\r\n  t7 = a[6].imag;\r\n  a[6].imag = t4 - t5;\r\n  t4 += t5;\r\n  a[4].imag = t4;\r\n\r\n  t6 = a[2].imag - t7;\r\n  t7 += a[2].imag;\r\n  a[2].imag = t7;\r\n\r\n  t8 = a[4].real;\r\n  t3 = a[0].real - t8;\r\n  t8 += a[0].real;\r\n  a[0].real = t8;\r\n\r\n  a[4].real = t3 - t6;\r\n  t3 += t6;\r\n  a[6].real = t3;\r\n\r\n  t7 = a[5].real;\r\n  t3 = a[1].real - t7;\r\n  t7 += a[1].real;\r\n  a[1].real = t7;\r\n\r\n  t8 = a[7].imag;\r\n  t6 = a[3].imag - t8;\r\n  t8 += a[3].imag;\r\n  a[3].imag = t8;\r\n  t1 = t3 - t6;\r\n  t3 += t6;\r\n\r\n  t7 = a[5].imag;\r\n  t4 = a[1].imag - t7;\r\n  t7 += a[1].imag;\r\n  a[1].imag = t7;\r\n\r\n  t8 = a[7].real;\r\n  t5 = a[3].real - t8;\r\n  t8 += a[3].real;\r\n  a[3].real = t8;\r\n\r\n  t2 = t4 - t5;\r\n  t4 += t5;\r\n\r\n  t6 = t1 - t4;\r\n  t8 = kSqrtHalf;\r\n  t6 *= t8;\r\n  a[5].real = a[4].real - t6;\r\n  t1 += t4;\r\n  t1 *= t8;\r\n  a[5].imag = a[4].imag - t1;\r\n  t6 += a[4].real;\r\n  a[4].real = t6;\r\n  t1 += a[4].imag;\r\n  a[4].imag = t1;\r\n\r\n  t5 = t2 - t3;\r\n  t5 *= t8;\r\n  a[7].imag = a[6].imag - t5;\r\n  t2 += t3;\r\n  t2 *= t8;\r\n  a[7].real = a[6].real - t2;\r\n  t2 += a[6].real;\r\n  a[6].real = t2;\r\n  t5 += a[6].imag;\r\n  a[6].imag = t5;\r\n\r\n  FFT4(a);\r\n\r\n  // Reorder to the correct output order.\r\n  // TODO: Modify the above computation so that this is not needed.\r\n  Complex tmp = a[2];\r\n  a[2] = a[3];\r\n  a[3] = a[5];\r\n  a[5] = a[7];\r\n  a[7] = a[4];\r\n  a[4] = a[1];\r\n  a[1] = a[6];\r\n  a[6] = tmp;\r\n}\r\n\r\n// Same as FFT8, but all inputs are real.\r\n// TODO: Since this does not need to be in-place, maybe there is a\r\n// faster FFT than this one, which is derived from DJB's in-place complex FFT.\r\nvoid RealFFT8(const double* in, Complex* out) {\r\n  double t1, t2, t3, t5, t6, t7, t8;\r\n  t8 = in[6];\r\n  t5 = in[2] - t8;\r\n  t8 += in[2];\r\n  out[2].real = t8;\r\n  out[6].imag = -t5;\r\n  out[4].imag = t5;\r\n  t8 = in[4];\r\n  t3 = in[0] - t8;\r\n  t8 += in[0];\r\n  out[0].real = t8;\r\n  out[4].real = t3;\r\n  out[6].real = t3;\r\n  t7 = in[5];\r\n  t3 = in[1] - t7;\r\n  t7 += in[1];\r\n  out[1].real = t7;\r\n  t8 = in[7];\r\n  t5 = in[3] - t8;\r\n  t8 += in[3];\r\n  out[3].real = t8;\r\n  t2 = -t5;\r\n  t6 = t3 - t5;\r\n  t8 = kSqrtHalf;\r\n  t6 *= t8;\r\n  out[5].real = out[4].real - t6;\r\n  t1 = t3 + t5;\r\n  t1 *= t8;\r\n  out[5].imag = out[4].imag - t1;\r\n  t6 += out[4].real;\r\n  out[4].real = t6;\r\n  t1 += out[4].imag;\r\n  out[4].imag = t1;\r\n  t5 = t2 - t3;\r\n  t5 *= t8;\r\n  out[7].imag = out[6].imag - t5;\r\n  t2 += t3;\r\n  t2 *= t8;\r\n  out[7].real = out[6].real - t2;\r\n  t2 += out[6].real;\r\n  out[6].real = t2;\r\n  t5 += out[6].imag;\r\n  out[6].imag = t5;\r\n  t5 = out[2].real;\r\n  t1 = out[0].real - t5;\r\n  t7 = out[3].real;\r\n  t5 += out[0].real;\r\n  t3 = out[1].real - t7;\r\n  t7 += out[1].real;\r\n  t8 = t5 + t7;\r\n  out[0].real = t8;\r\n  t5 -= t7;\r\n  out[1].real = t5;\r\n  out[2].imag = t3;\r\n  out[3].imag = -t3;\r\n  out[3].real = t1;\r\n  out[2].real = t1;\r\n  out[0].imag = 0;\r\n  out[1].imag = 0;\r\n\r\n  // Reorder to the correct output order.\r\n  // TODO: Modify the above computation so that this is not needed.\r\n  Complex tmp = out[2];\r\n  out[2] = out[3];\r\n  out[3] = out[5];\r\n  out[5] = out[7];\r\n  out[7] = out[4];\r\n  out[4] = out[1];\r\n  out[1] = out[6];\r\n  out[6] = tmp;\r\n}\r\n\r\n// Fills in block[kBlockEdgeHalf..(kBlockHalf+kBlockEdgeHalf)], and leaves the\r\n// rest unmodified.\r\nvoid ButteraugliFFTSquared(double block[kBlockSize]) {\r\n  double global_mul = 0.000064;\r\n  Complex block_c[kBlockSize];\r\n  assert(kBlockEdge == 8);\r\n  for (int y = 0; y < kBlockEdge; ++y) {\r\n    RealFFT8(block + y * kBlockEdge, block_c + y * kBlockEdge);\r\n  }\r\n  TransposeBlock(block_c);\r\n  double r0[kBlockEdge];\r\n  double r1[kBlockEdge];\r\n  for (int x = 0; x < kBlockEdge; ++x) {\r\n    r0[x] = block_c[x].real;\r\n    r1[x] = block_c[kBlockHalf + x].real;\r\n  }\r\n  RealFFT8(r0, block_c);\r\n  RealFFT8(r1, block_c + kBlockHalf);\r\n  for (int y = 1; y < kBlockEdgeHalf; ++y) {\r\n    FFT8(block_c + y * kBlockEdge);\r\n  }\r\n  for (int i = kBlockEdgeHalf; i < kBlockHalf + kBlockEdgeHalf + 1; ++i) {\r\n    block[i] = abssq(block_c[i]);\r\n    block[i] *= global_mul;\r\n  }\r\n}\r\n\r\n// Computes 8x8 FFT of each channel of xyb0 and xyb1 and adds the total squared\r\n// 3-dimensional xybdiff of the two blocks to diff_xyb_{dc,ac} and the average\r\n// diff on the edges to diff_xyb_edge_dc.\r\nvoid ButteraugliBlockDiff(double xyb0[3 * kBlockSize],\r\n                          double xyb1[3 * kBlockSize],\r\n                          double diff_xyb_dc[3],\r\n                          double diff_xyb_ac[3],\r\n                          double diff_xyb_edge_dc[3]) {\r\n  PROFILER_FUNC;\r\n  const double *csf8x8 = GetContrastSensitivityMatrix();\r\n\r\n  double avgdiff_xyb[3] = {0.0};\r\n  double avgdiff_edge[3][4] = { {0.0} };\r\n  for (int i = 0; i < 3 * kBlockSize; ++i) {\r\n    const double diff_xyb = xyb0[i] - xyb1[i];\r\n    const int c = i / kBlockSize;\r\n    avgdiff_xyb[c] += diff_xyb / kBlockSize;\r\n    const int k = i % kBlockSize;\r\n    const int kx = k % kBlockEdge;\r\n    const int ky = k / kBlockEdge;\r\n    const int h_edge_idx = ky == 0 ? 1 : ky == 7 ? 3 : -1;\r\n    const int v_edge_idx = kx == 0 ? 0 : kx == 7 ? 2 : -1;\r\n    if (h_edge_idx >= 0) {\r\n      avgdiff_edge[c][h_edge_idx] += diff_xyb / kBlockEdge;\r\n    }\r\n    if (v_edge_idx >= 0) {\r\n      avgdiff_edge[c][v_edge_idx] += diff_xyb / kBlockEdge;\r\n    }\r\n  }\r\n  XybDiffLowFreqSquaredAccumulate(avgdiff_xyb[0],\r\n                                  avgdiff_xyb[1],\r\n                                  avgdiff_xyb[2],\r\n                                  0, 0, 0, csf8x8[0],\r\n                                  diff_xyb_dc);\r\n  for (int i = 0; i < 4; ++i) {\r\n    XybDiffLowFreqSquaredAccumulate(avgdiff_edge[0][i],\r\n                                    avgdiff_edge[1][i],\r\n                                    avgdiff_edge[2][i],\r\n                                    0, 0, 0, csf8x8[0],\r\n                                    diff_xyb_edge_dc);\r\n  }\r\n\r\n  double* xyb_avg = xyb0;\r\n  double* xyb_halfdiff = xyb1;\r\n  for(int i = 0; i < 3 * kBlockSize; ++i) {\r\n    double avg = (xyb0[i] + xyb1[i])/2;\r\n    double halfdiff = (xyb0[i] - xyb1[i])/2;\r\n    xyb_avg[i] = avg;\r\n    xyb_halfdiff[i] = halfdiff;\r\n  }\r\n  double *y_avg = &xyb_avg[kBlockSize];\r\n  double *x_halfdiff_squared = &xyb_halfdiff[0];\r\n  double *y_halfdiff = &xyb_halfdiff[kBlockSize];\r\n  double *z_halfdiff_squared = &xyb_halfdiff[2 * kBlockSize];\r\n  ButteraugliFFTSquared(y_avg);\r\n  ButteraugliFFTSquared(x_halfdiff_squared);\r\n  ButteraugliFFTSquared(y_halfdiff);\r\n  ButteraugliFFTSquared(z_halfdiff_squared);\r\n\r\n  static const double xmul = 64.8;\r\n  static const double ymul = 1.753123908348329;\r\n  static const double ymul2 = 1.51983458269;\r\n  static const double zmul = 2.4;\r\n\r\n  for (size_t i = kBlockEdgeHalf; i < kBlockHalf + kBlockEdgeHalf + 1; ++i) {\r\n    double d = csf8x8[i];\r\n    diff_xyb_ac[0] += d * xmul * x_halfdiff_squared[i];\r\n    diff_xyb_ac[2] += d * zmul * z_halfdiff_squared[i];\r\n\r\n    y_avg[i] = sqrt(y_avg[i]);\r\n    y_halfdiff[i] = sqrt(y_halfdiff[i]);\r\n    double y0 = y_avg[i] - y_halfdiff[i];\r\n    double y1 = y_avg[i] + y_halfdiff[i];\r\n    // Remove the impact of small absolute values.\r\n    // This improves the behavior with flat noise.\r\n    static const double ylimit = 0.04;\r\n    y0 = RemoveRangeAroundZero(y0, ylimit);\r\n    y1 = RemoveRangeAroundZero(y1, ylimit);\r\n    if (y0 != y1) {\r\n      double valy0 = Interpolate(GetHighFreqColorDiffDy(), 21, y0 * ymul2);\r\n      double valy1 = Interpolate(GetHighFreqColorDiffDy(), 21, y1 * ymul2);\r\n      double valy = ymul * (valy0 - valy1);\r\n      diff_xyb_ac[1] += d * valy * valy;\r\n    }\r\n  }\r\n}\r\n\r\n// Low frequency edge detectors.\r\n// Two edge detectors are applied in each corner of the 8x8 square.\r\n// The squared 3-dimensional error vector is added to diff_xyb.\r\nvoid Butteraugli8x8CornerEdgeDetectorDiff(\r\n    const size_t pos_x,\r\n    const size_t pos_y,\r\n    const size_t xsize,\r\n    const size_t ysize,\r\n    const std::vector<std::vector<float> > &blurred0,\r\n    const std::vector<std::vector<float> > &blurred1,\r\n    double diff_xyb[3]) {\r\n  PROFILER_FUNC;\r\n  int local_count = 0;\r\n  double local_xyb[3] = { 0 };\r\n  static const double w = 0.711100840192;\r\n  for (int k = 0; k < 4; ++k) {\r\n    size_t step = 3;\r\n    size_t offset[4][2] = { { 0, 0 }, { 0, 7 }, { 7, 0 }, { 7, 7 } };\r\n    size_t x = pos_x + offset[k][0];\r\n    size_t y = pos_y + offset[k][1];\r\n    if (x >= step && x + step < xsize) {\r\n      size_t ix = y * xsize + (x - step);\r\n      size_t ix2 = ix + 2 * step;\r\n      XybDiffLowFreqSquaredAccumulate(\r\n          w * (blurred0[0][ix] - blurred0[0][ix2]),\r\n          w * (blurred0[1][ix] - blurred0[1][ix2]),\r\n          w * (blurred0[2][ix] - blurred0[2][ix2]),\r\n          w * (blurred1[0][ix] - blurred1[0][ix2]),\r\n          w * (blurred1[1][ix] - blurred1[1][ix2]),\r\n          w * (blurred1[2][ix] - blurred1[2][ix2]),\r\n          1.0, local_xyb);\r\n      ++local_count;\r\n    }\r\n    if (y >= step && y + step < ysize) {\r\n      size_t ix = (y - step) * xsize + x;\r\n      size_t ix2 = ix + 2 * step * xsize;\r\n      XybDiffLowFreqSquaredAccumulate(\r\n          w * (blurred0[0][ix] - blurred0[0][ix2]),\r\n          w * (blurred0[1][ix] - blurred0[1][ix2]),\r\n          w * (blurred0[2][ix] - blurred0[2][ix2]),\r\n          w * (blurred1[0][ix] - blurred1[0][ix2]),\r\n          w * (blurred1[1][ix] - blurred1[1][ix2]),\r\n          w * (blurred1[2][ix] - blurred1[2][ix2]),\r\n          1.0, local_xyb);\r\n      ++local_count;\r\n    }\r\n  }\r\n  static const double weight = 0.01617112696;\r\n  const double mul = weight * 8.0 / local_count;\r\n  for (int i = 0; i < 3; ++i) {\r\n    diff_xyb[i] += mul * local_xyb[i];\r\n  }\r\n}\r\n\r\n// https://en.wikipedia.org/wiki/Photopsin absordance modeling.\r\nconst double *GetOpsinAbsorbance() {\r\n  static const double kMix[12] = {\r\n    0.348036746003,\r\n    0.577814843137,\r\n    0.0544556093735,\r\n    0.774145581713,\r\n    0.26922717275,\r\n    0.767247733938,\r\n    0.0366922708552,\r\n    0.920130265014,\r\n    0.0882062883536,\r\n    0.158581714673,\r\n    0.712857943858,\r\n    10.6524069248,\r\n  };\r\n  return &kMix[0];\r\n}\r\n\r\nvoid OpsinAbsorbance(const double in[3], double out[3]) {\r\n  const double *mix = GetOpsinAbsorbance();\r\n  out[0] = mix[0] * in[0] + mix[1] * in[1] + mix[2] * in[2] + mix[3];\r\n  out[1] = mix[4] * in[0] + mix[5] * in[1] + mix[6] * in[2] + mix[7];\r\n  out[2] = mix[8] * in[0] + mix[9] * in[1] + mix[10] * in[2] + mix[11];\r\n}\r\n\r\ndouble GammaMinArg() {\r\n  double in[3] = { 0.0, 0.0, 0.0 };\r\n  double out[3];\r\n  OpsinAbsorbance(in, out);\r\n  return std::min(out[0], std::min(out[1], out[2]));\r\n}\r\n\r\ndouble GammaMaxArg() {\r\n  double in[3] = { 255.0, 255.0, 255.0 };\r\n  double out[3];\r\n  OpsinAbsorbance(in, out);\r\n  return std::max(out[0], std::max(out[1], out[2]));\r\n}\r\n\r\nButteraugliComparator::ButteraugliComparator(\r\n    size_t xsize, size_t ysize, int step)\r\n    : xsize_(xsize),\r\n      ysize_(ysize),\r\n      num_pixels_(xsize * ysize),\r\n      step_(step),\r\n      res_xsize_((xsize + step - 1) / step),\r\n      res_ysize_((ysize + step - 1) / step) {\r\n  assert(step <= 4);\r\n}\r\n\r\nvoid MaskHighIntensityChange(\r\n    size_t xsize, size_t ysize,\r\n    const std::vector<std::vector<float> > &c0,\r\n    const std::vector<std::vector<float> > &c1,\r\n    std::vector<std::vector<float> > &xyb0,\r\n    std::vector<std::vector<float> > &xyb1) {\r\n  PROFILER_FUNC;\r\n  for (int y = 0; y < ysize; ++y) {\r\n    for (int x = 0; x < xsize; ++x) {\r\n      int ix = y * xsize + x;\r\n      const double ave[3] = {\r\n        (c0[0][ix] + c1[0][ix]) * 0.5,\r\n        (c0[1][ix] + c1[1][ix]) * 0.5,\r\n        (c0[2][ix] + c1[2][ix]) * 0.5,\r\n      };\r\n      double sqr_max_diff = -1;\r\n      {\r\n        int offset[4] =\r\n            { -1, 1, -static_cast<int>(xsize), static_cast<int>(xsize) };\r\n        int border[4] =\r\n            { x == 0, x + 1 == xsize, y == 0, y + 1 == ysize };\r\n        for (int dir = 0; dir < 4; ++dir) {\r\n          if (border[dir]) {\r\n            continue;\r\n          }\r\n          const int ix2 = ix + offset[dir];\r\n          double diff = 0.5 * (c0[1][ix2] + c1[1][ix2]) - ave[1];\r\n          diff *= diff;\r\n          if (sqr_max_diff < diff) {\r\n            sqr_max_diff = diff;\r\n          }\r\n        }\r\n      }\r\n      static const double kReductionX = 275.19165240059317;\r\n      static const double kReductionY = 18599.41286306991;\r\n      static const double kReductionZ = 410.8995306951065;\r\n      static const double kChromaBalance = 106.95800948271017;\r\n      double chroma_scale = kChromaBalance / (ave[1] + kChromaBalance);\r\n\r\n      const double mix[3] = {\r\n        chroma_scale * kReductionX / (sqr_max_diff + kReductionX),\r\n        kReductionY / (sqr_max_diff + kReductionY),\r\n        chroma_scale * kReductionZ / (sqr_max_diff + kReductionZ),\r\n      };\r\n      // Interpolate lineraly between the average color and the actual\r\n      // color -- to reduce the importance of this pixel.\r\n      for (int i = 0; i < 3; ++i) {\r\n        xyb0[i][ix] = mix[i] * c0[i][ix] + (1 - mix[i]) * ave[i];\r\n        xyb1[i][ix] = mix[i] * c1[i][ix] + (1 - mix[i]) * ave[i];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ndouble SimpleGamma(double v) {\r\n  static const double kGamma = 0.387494322593;\r\n  static const double limit = 43.01745241042018;\r\n  double bright = v - limit;\r\n  if (bright >= 0) {\r\n    static const double mul = 0.0383723643799;\r\n    v -= bright * mul;\r\n  }\r\n  static const double limit2 = 94.68634353321337;\r\n  double bright2 = v - limit2;\r\n  if (bright2 >= 0) {\r\n    static const double mul = 0.22885405968;\r\n    v -= bright2 * mul;\r\n  }\r\n  static const double offset = 0.156775786057;\r\n  static const double scale = 8.898059160493739;\r\n  double retval = scale * (offset + pow(v, kGamma));\r\n  return retval;\r\n}\r\n\r\nstatic inline double Gamma(double v) {\r\n  // return SimpleGamma(v);\r\n  return GammaPolynomial(v);\r\n}\r\n\r\nvoid OpsinDynamicsImage(size_t xsize, size_t ysize,\r\n                        std::vector<std::vector<float> > &rgb) {\r\n  PROFILER_FUNC;\r\n  std::vector<std::vector<float> > blurred = rgb;\r\n  static const double kSigma = 1.1;\r\n  for (int i = 0; i < 3; ++i) {\r\n    Blur(xsize, ysize, blurred[i].data(), kSigma, 0.0);\r\n  }\r\n  for (int i = 0; i < rgb[0].size(); ++i) {\r\n    double sensitivity[3];\r\n    {\r\n      // Calculate sensitivity[3] based on the smoothed image gamma derivative.\r\n      double pre_rgb[3] = { blurred[0][i], blurred[1][i], blurred[2][i] };\r\n      double pre_mixed[3];\r\n      OpsinAbsorbance(pre_rgb, pre_mixed);\r\n      sensitivity[0] = Gamma(pre_mixed[0]) / pre_mixed[0];\r\n      sensitivity[1] = Gamma(pre_mixed[1]) / pre_mixed[1];\r\n      sensitivity[2] = Gamma(pre_mixed[2]) / pre_mixed[2];\r\n    }\r\n    double cur_rgb[3] = { rgb[0][i],  rgb[1][i],  rgb[2][i] };\r\n    double cur_mixed[3];\r\n    OpsinAbsorbance(cur_rgb, cur_mixed);\r\n    cur_mixed[0] *= sensitivity[0];\r\n    cur_mixed[1] *= sensitivity[1];\r\n    cur_mixed[2] *= sensitivity[2];\r\n    double x, y, z;\r\n    RgbToXyb(cur_mixed[0], cur_mixed[1], cur_mixed[2], &x, &y, &z);\r\n    rgb[0][i] = x;\r\n    rgb[1][i] = y;\r\n    rgb[2][i] = z;\r\n  }\r\n}\r\n\r\nstatic void ScaleImage(double scale, std::vector<float> *result) {\r\n  PROFILER_FUNC;\r\n  for (size_t i = 0; i < result->size(); ++i) {\r\n    (*result)[i] *= scale;\r\n  }\r\n}\r\n\r\n// Making a cluster of local errors to be more impactful than\r\n// just a single error.\r\nvoid CalculateDiffmap(const size_t xsize, const size_t ysize,\r\n                      const int step,\r\n                      std::vector<float>* diffmap) {\r\n  PROFILER_FUNC;\r\n  // Shift the diffmap more correctly above the pixels, from 2.5 pixels to 0.5\r\n  // pixels distance over the original image. The border of 2 pixels on top and\r\n  // left side and 3 pixels on right and bottom side are zeroed, but these\r\n  // values have no meaning, they only exist to keep the result map the same\r\n  // size as the input images.\r\n  int s2 = (8 - step) / 2;\r\n  // Upsample and take square root.\r\n  std::vector<float> diffmap_out(xsize * ysize);\r\n  const size_t res_xsize = (xsize + step - 1) / step;\r\n  for (size_t res_y = 0; res_y + 8 - step < ysize; res_y += step) {\r\n    for (size_t res_x = 0; res_x + 8 - step < xsize; res_x += step) {\r\n      size_t res_ix = (res_y * res_xsize + res_x) / step;\r\n      float orig_val = (*diffmap)[res_ix];\r\n      constexpr float kInitialSlope = 100;\r\n      // TODO(b/29974893): Until that is fixed do not call sqrt on very small\r\n      // numbers.\r\n      double val = orig_val < (1.0 / (kInitialSlope * kInitialSlope))\r\n                       ? kInitialSlope * orig_val\r\n                       : std::sqrt(orig_val);\r\n      for (size_t off_y = 0; off_y < step; ++off_y) {\r\n        for (size_t off_x = 0; off_x < step; ++off_x) {\r\n          diffmap_out[(res_y + off_y + s2) * xsize + res_x + off_x + s2] = val;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  *diffmap = diffmap_out;\r\n  {\r\n    static const double kSigma = 8.8510880283;\r\n    static const double mul1 = 24.8235314874;\r\n    static const double scale = 1.0 / (1.0 + mul1);\r\n    const int s = 8 - step;\r\n    std::vector<float> blurred((xsize - s) * (ysize - s));\r\n    for (int y = 0; y < ysize - s; ++y) {\r\n      for (int x = 0; x < xsize - s; ++x) {\r\n        blurred[y * (xsize - s) + x] = (*diffmap)[(y + s2) * xsize + x + s2];\r\n      }\r\n    }\r\n    static const double border_ratio = 0.03027655136;\r\n    Blur(xsize - s, ysize - s, blurred.data(), kSigma, border_ratio);\r\n    for (int y = 0; y < ysize - s; ++y) {\r\n      for (int x = 0; x < xsize - s; ++x) {\r\n        (*diffmap)[(y + s2) * xsize + x + s2]\r\n            += mul1 * blurred[y * (xsize - s) + x];\r\n      }\r\n    }\r\n    ScaleImage(scale, diffmap);\r\n  }\r\n}\r\n\r\nvoid ButteraugliComparator::Diffmap(const std::vector<ImageF> &rgb0_arg,\r\n                                    const std::vector<ImageF> &rgb1_arg,\r\n                                    ImageF &result) {\r\n  result = ImageF(xsize_, ysize_);\r\n  if (xsize_ < 8 || ysize_ < 8) return;\r\n  std::vector<std::vector<float>> rgb0_c = PackedFromPlanes(rgb0_arg);\r\n  std::vector<std::vector<float>> rgb1_c = PackedFromPlanes(rgb1_arg);\r\n  OpsinDynamicsImage(xsize_, ysize_, rgb0_c);\r\n  OpsinDynamicsImage(xsize_, ysize_, rgb1_c);\r\n  std::vector<ImageF> pg0 = PlanesFromPacked(xsize_, ysize_, rgb0_c);\r\n  std::vector<ImageF> pg1 = PlanesFromPacked(xsize_, ysize_, rgb1_c);\r\n  DiffmapOpsinDynamicsImage(pg0, pg1, result);\r\n}\r\n\r\nvoid ButteraugliComparator::DiffmapOpsinDynamicsImage(\r\n    const std::vector<ImageF> &xyb0_arg, const std::vector<ImageF> &xyb1_arg,\r\n    ImageF &result) {\r\n  result = ImageF(xsize_, ysize_);\r\n  if (xsize_ < 8 || ysize_ < 8) return;\r\n  std::vector<std::vector<float>> xyb0 = PackedFromPlanes(xyb0_arg);\r\n  std::vector<std::vector<float>> xyb1 = PackedFromPlanes(xyb1_arg);\r\n  auto xyb0_c = xyb0;\r\n  auto xyb1_c = xyb1;\r\n\r\n  MaskHighIntensityChange(xsize_, ysize_, xyb0_c, xyb1_c, xyb0, xyb1);\r\n  assert(8 <= xsize_);\r\n  for (int i = 0; i < 3; i++) {\r\n    assert(xyb0[i].size() == num_pixels_);\r\n    assert(xyb1[i].size() == num_pixels_);\r\n  }\r\n  std::vector<std::vector<float> > mask_xyb(3);\r\n  std::vector<std::vector<float> > mask_xyb_dc(3);\r\n  std::vector<float> block_diff_dc(3 * res_xsize_ * res_ysize_);\r\n  std::vector<float> block_diff_ac(3 * res_xsize_ * res_ysize_);\r\n  std::vector<float> edge_detector_map(3 * res_xsize_ * res_ysize_);\r\n  std::vector<float> packed_result;\r\n  BlockDiffMap(xyb0, xyb1, &block_diff_dc, &block_diff_ac);\r\n  EdgeDetectorMap(xyb0, xyb1, &edge_detector_map);\r\n  EdgeDetectorLowFreq(xyb0, xyb1, &block_diff_ac);\r\n  Mask(xyb0, xyb1, xsize_, ysize_, &mask_xyb, &mask_xyb_dc);\r\n  CombineChannels(mask_xyb, mask_xyb_dc, block_diff_dc, block_diff_ac,\r\n                  edge_detector_map, &packed_result);\r\n  CalculateDiffmap(xsize_, ysize_, step_, &packed_result);\r\n  CopyFromPacked(packed_result, &result);\r\n}\r\n\r\nvoid ButteraugliComparator::BlockDiffMap(\r\n    const std::vector<std::vector<float> > &xyb0,\r\n    const std::vector<std::vector<float> > &xyb1,\r\n    std::vector<float>* block_diff_dc,\r\n    std::vector<float>* block_diff_ac) {\r\n  PROFILER_FUNC;\r\n  for (size_t res_y = 0; res_y + (kBlockEdge - step_ - 1) < ysize_;\r\n       res_y += step_) {\r\n    for (size_t res_x = 0; res_x + (kBlockEdge - step_ - 1) < xsize_;\r\n         res_x += step_) {\r\n      size_t res_ix = (res_y * res_xsize_ + res_x) / step_;\r\n      size_t offset = (std::min(res_y, ysize_ - 8) * xsize_ +\r\n                       std::min(res_x, xsize_ - 8));\r\n      double block0[3 * kBlockEdge * kBlockEdge];\r\n      double block1[3 * kBlockEdge * kBlockEdge];\r\n      for (int i = 0; i < 3; ++i) {\r\n        double *m0 = &block0[i * kBlockEdge * kBlockEdge];\r\n        double *m1 = &block1[i * kBlockEdge * kBlockEdge];\r\n        for (size_t y = 0; y < kBlockEdge; y++) {\r\n          for (size_t x = 0; x < kBlockEdge; x++) {\r\n            m0[kBlockEdge * y + x] = xyb0[i][offset + y * xsize_ + x];\r\n            m1[kBlockEdge * y + x] = xyb1[i][offset + y * xsize_ + x];\r\n          }\r\n        }\r\n      }\r\n      double diff_xyb_dc[3] = { 0.0 };\r\n      double diff_xyb_ac[3] = { 0.0 };\r\n      double diff_xyb_edge_dc[3] = { 0.0 };\r\n      ButteraugliBlockDiff(block0, block1,\r\n                           diff_xyb_dc, diff_xyb_ac, diff_xyb_edge_dc);\r\n      for (int i = 0; i < 3; ++i) {\r\n        (*block_diff_dc)[3 * res_ix + i] = diff_xyb_dc[i];\r\n        (*block_diff_ac)[3 * res_ix + i] = diff_xyb_ac[i];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid ButteraugliComparator::EdgeDetectorMap(\r\n    const std::vector<std::vector<float> > &xyb0,\r\n    const std::vector<std::vector<float> > &xyb1,\r\n    std::vector<float>* edge_detector_map) {\r\n  PROFILER_FUNC;\r\n  static const double kSigma[3] = {\r\n    1.5,\r\n    0.586,\r\n    0.4,\r\n  };\r\n  std::vector<std::vector<float> > blurred0(xyb0);\r\n  std::vector<std::vector<float> > blurred1(xyb1);\r\n  for (int i = 0; i < 3; i++) {\r\n    Blur(xsize_, ysize_, blurred0[i].data(), kSigma[i], 0.0);\r\n    Blur(xsize_, ysize_, blurred1[i].data(), kSigma[i], 0.0);\r\n  }\r\n  for (size_t res_y = 0; res_y + (8 - step_) < ysize_; res_y += step_) {\r\n    for (size_t res_x = 0; res_x + (8 - step_) < xsize_; res_x += step_) {\r\n      size_t res_ix = (res_y * res_xsize_ + res_x) / step_;\r\n      double diff_xyb[3] = { 0.0 };\r\n      Butteraugli8x8CornerEdgeDetectorDiff(std::min(res_x, xsize_ - 8),\r\n                                           std::min(res_y, ysize_ - 8),\r\n                                           xsize_, ysize_,\r\n                                           blurred0, blurred1,\r\n                                           diff_xyb);\r\n      for (int i = 0; i < 3; ++i) {\r\n        (*edge_detector_map)[3 * res_ix + i] = diff_xyb[i];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid ButteraugliComparator::EdgeDetectorLowFreq(\r\n    const std::vector<std::vector<float> > &xyb0,\r\n    const std::vector<std::vector<float> > &xyb1,\r\n    std::vector<float>* block_diff_ac) {\r\n  PROFILER_FUNC;\r\n  static const double kSigma = 14;\r\n  static const double kMul = 10;\r\n  std::vector<std::vector<float> > blurred0(xyb0);\r\n  std::vector<std::vector<float> > blurred1(xyb1);\r\n  for (int i = 0; i < 3; i++) {\r\n    Blur(xsize_, ysize_, blurred0[i].data(), kSigma, 0.0);\r\n    Blur(xsize_, ysize_, blurred1[i].data(), kSigma, 0.0);\r\n  }\r\n  const int step = 8;\r\n  for (int y = 0; y + step < ysize_; y += step_) {\r\n    int resy = y / step_;\r\n    int resx = step / step_;\r\n    for (int x = 0; x + step < xsize_; x += step_, resx++) {\r\n      const int ix = y * xsize_ + x;\r\n      const int res_ix = resy * res_xsize_ + resx;\r\n      double diff[4][3];\r\n      for (int i = 0; i < 3; ++i) {\r\n        int ix2 = ix + 8;\r\n        diff[0][i] =\r\n            ((blurred1[i][ix] - blurred0[i][ix]) +\r\n             (blurred0[i][ix2] - blurred1[i][ix2]));\r\n        ix2 = ix + 8 * xsize_;\r\n        diff[1][i] =\r\n            ((blurred1[i][ix] - blurred0[i][ix]) +\r\n             (blurred0[i][ix2] - blurred1[i][ix2]));\r\n        ix2 = ix + 6 * xsize_ + 6;\r\n        diff[2][i] =\r\n            ((blurred1[i][ix] - blurred0[i][ix]) +\r\n             (blurred0[i][ix2] - blurred1[i][ix2]));\r\n        ix2 = ix + 6 * xsize_ - 6;\r\n        diff[3][i] = x < step ? 0 :\r\n            ((blurred1[i][ix] - blurred0[i][ix]) +\r\n             (blurred0[i][ix2] - blurred1[i][ix2]));\r\n      }\r\n      double max_diff_xyb[3] = { 0 };\r\n      for (int k = 0; k < 4; ++k) {\r\n        double diff_xyb[3] = { 0 };\r\n        XybDiffLowFreqSquaredAccumulate(diff[k][0], diff[k][1], diff[k][2],\r\n                                        0, 0, 0, 1.0,\r\n                                        diff_xyb);\r\n        for (int i = 0; i < 3; ++i) {\r\n          max_diff_xyb[i] = std::max<double>(max_diff_xyb[i], diff_xyb[i]);\r\n        }\r\n      }\r\n      for (int i = 0; i < 3; ++i) {\r\n        (*block_diff_ac)[3 * res_ix + i] += kMul * max_diff_xyb[i];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid ButteraugliComparator::CombineChannels(\r\n    const std::vector<std::vector<float> >& mask_xyb,\r\n    const std::vector<std::vector<float> >& mask_xyb_dc,\r\n    const std::vector<float>& block_diff_dc,\r\n    const std::vector<float>& block_diff_ac,\r\n    const std::vector<float>& edge_detector_map,\r\n    std::vector<float>* result) {\r\n  PROFILER_FUNC;\r\n  result->resize(res_xsize_ * res_ysize_);\r\n  for (size_t res_y = 0; res_y + (8 - step_) < ysize_; res_y += step_) {\r\n    for (size_t res_x = 0; res_x + (8 - step_) < xsize_; res_x += step_) {\r\n      size_t res_ix = (res_y * res_xsize_ + res_x) / step_;\r\n      double mask[3];\r\n      double dc_mask[3];\r\n      for (int i = 0; i < 3; ++i) {\r\n        mask[i] = mask_xyb[i][(res_y + 3) * xsize_ + (res_x + 3)];\r\n        dc_mask[i] = mask_xyb_dc[i][(res_y + 3) * xsize_ + (res_x + 3)];\r\n      }\r\n      (*result)[res_ix] =\r\n          (DotProduct(&block_diff_dc[3 * res_ix], dc_mask) +\r\n           DotProduct(&block_diff_ac[3 * res_ix], mask) +\r\n           DotProduct(&edge_detector_map[3 * res_ix], mask));\r\n    }\r\n  }\r\n}\r\n\r\ndouble ButteraugliScoreFromDiffmap(const ImageF& diffmap) {\r\n  PROFILER_FUNC;\r\n  float retval = 0.0f;\r\n  for (size_t y = 0; y < diffmap.ysize(); ++y) {\r\n    ConstRestrict<const float *> row = diffmap.Row(y);\r\n    for (size_t x = 0; x < diffmap.xsize(); ++x) {\r\n      retval = std::max(retval, row[x]);\r\n    }\r\n  }\r\n  return retval;\r\n}\r\n\r\nstatic std::array<double, 512> MakeMask(\r\n    double extmul, double extoff,\r\n    double mul, double offset,\r\n    double scaler) {\r\n  std::array<double, 512> lut;\r\n  for (int i = 0; i < lut.size(); ++i) {\r\n    const double c = mul / ((0.01 * scaler * i) + offset);\r\n    lut[i] = 1.0 + extmul * (c + extoff);\r\n    assert(lut[i] >= 0.0);\r\n    lut[i] *= lut[i];\r\n  }\r\n  return lut;\r\n}\r\n\r\ndouble MaskX(double delta) {\r\n  PROFILER_FUNC;\r\n  static const double extmul = 0.975741017749;\r\n  static const double extoff = -4.25328244168;\r\n  static const double offset = 0.454909521427;\r\n  static const double scaler = 0.0738288224836;\r\n  static const double mul = 20.8029176447;\r\n  static const std::array<double, 512> lut =\r\n                MakeMask(extmul, extoff, mul, offset, scaler);\r\n  return InterpolateClampNegative(lut.data(), lut.size(), delta);\r\n}\r\n\r\ndouble MaskY(double delta) {\r\n  PROFILER_FUNC;\r\n  static const double extmul = 0.373995618954;\r\n  static const double extoff = 1.5307267433;\r\n  static const double offset = 0.911952641929;\r\n  static const double scaler = 1.1731667845;\r\n  static const double mul = 16.2447033988;\r\n  static const std::array<double, 512> lut =\r\n      MakeMask(extmul, extoff, mul, offset, scaler);\r\n  return InterpolateClampNegative(lut.data(), lut.size(), delta);\r\n}\r\n\r\ndouble MaskB(double delta) {\r\n  PROFILER_FUNC;\r\n  static const double extmul = 0.61582234137;\r\n  static const double extoff = -4.25376118646;\r\n  static const double offset = 1.05105070921;\r\n  static const double scaler = 0.47434643535;\r\n  static const double mul = 31.1444967089;\r\n  static const std::array<double, 512> lut =\r\n      MakeMask(extmul, extoff, mul, offset, scaler);\r\n  return InterpolateClampNegative(lut.data(), lut.size(), delta);\r\n}\r\n\r\ndouble MaskDcX(double delta) {\r\n  PROFILER_FUNC;\r\n  static const double extmul = 1.79116943438;\r\n  static const double extoff = -3.86797479189;\r\n  static const double offset = 0.670960225853;\r\n  static const double scaler = 0.486575865525;\r\n  static const double mul = 20.4563479139;\r\n  static const std::array<double, 512> lut =\r\n      MakeMask(extmul, extoff, mul, offset, scaler);\r\n  return InterpolateClampNegative(lut.data(), lut.size(), delta);\r\n}\r\n\r\ndouble MaskDcY(double delta) {\r\n  PROFILER_FUNC;\r\n  static const double extmul = 0.212223514236;\r\n  static const double extoff = -3.65647120524;\r\n  static const double offset = 1.73396799447;\r\n  static const double scaler = 0.170392660501;\r\n  static const double mul = 21.6566724788;\r\n  static const std::array<double, 512> lut =\r\n      MakeMask(extmul, extoff, mul, offset, scaler);\r\n  return InterpolateClampNegative(lut.data(), lut.size(), delta);\r\n}\r\n\r\ndouble MaskDcB(double delta) {\r\n  PROFILER_FUNC;\r\n  static const double extmul = 0.349376011816;\r\n  static const double extoff = -0.894711072781;\r\n  static const double offset = 0.901647926679;\r\n  static const double scaler = 0.380086095024;\r\n  static const double mul = 18.0373825149;\r\n  static const std::array<double, 512> lut =\r\n      MakeMask(extmul, extoff, mul, offset, scaler);\r\n  return InterpolateClampNegative(lut.data(), lut.size(), delta);\r\n}\r\n\r\n// Replaces values[x + y * xsize] with the minimum of the values in the\r\n// square_size square with coordinates\r\n//   x - offset .. x + square_size - offset - 1,\r\n//   y - offset .. y + square_size - offset - 1.\r\nvoid MinSquareVal(size_t square_size, size_t offset,\r\n                  size_t xsize, size_t ysize,\r\n                  float *values) {\r\n  PROFILER_FUNC;\r\n  // offset is not negative and smaller than square_size.\r\n  assert(offset < square_size);\r\n  std::vector<float> tmp(xsize * ysize);\r\n  for (size_t y = 0; y < ysize; ++y) {\r\n    const size_t minh = offset > y ? 0 : y - offset;\r\n    const size_t maxh = std::min<size_t>(ysize, y + square_size - offset);\r\n    for (size_t x = 0; x < xsize; ++x) {\r\n      double min = values[x + minh * xsize];\r\n      for (size_t j = minh + 1; j < maxh; ++j) {\r\n        min = fmin(min, values[x + j * xsize]);\r\n      }\r\n      tmp[x + y * xsize] = min;\r\n    }\r\n  }\r\n  for (size_t x = 0; x < xsize; ++x) {\r\n    const size_t minw = offset > x ? 0 : x - offset;\r\n    const size_t maxw = std::min<size_t>(xsize, x + square_size - offset);\r\n    for (size_t y = 0; y < ysize; ++y) {\r\n      double min = tmp[minw + y * xsize];\r\n      for (size_t j = minw + 1; j < maxw; ++j) {\r\n        min = fmin(min, tmp[j + y * xsize]);\r\n      }\r\n      values[x + y * xsize] = min;\r\n    }\r\n  }\r\n}\r\n\r\n// ===== Functions used by Mask only =====\r\nvoid Average5x5(int xsize, int ysize, std::vector<float>* diffs) {\r\n  PROFILER_FUNC;\r\n  if (xsize < 4 || ysize < 4) {\r\n    // TODO: Make this work for small dimensions as well.\r\n    return;\r\n  }\r\n  static const float w = 0.679144890667;\r\n  static const float scale = 1.0 / (5.0 + 4 * w);\r\n  std::vector<float> result = *diffs;\r\n  std::vector<float> tmp0 = *diffs;\r\n  std::vector<float> tmp1 = *diffs;\r\n  ScaleImage(w, &tmp1);\r\n  for (int y = 0; y < ysize; y++) {\r\n    const int row0 = y * xsize;\r\n    result[row0 + 1] += tmp0[row0];\r\n    result[row0 + 0] += tmp0[row0 + 1];\r\n    result[row0 + 2] += tmp0[row0 + 1];\r\n    for (int x = 2; x < xsize - 2; ++x) {\r\n      result[row0 + x - 1] += tmp0[row0 + x];\r\n      result[row0 + x + 1] += tmp0[row0 + x];\r\n    }\r\n    result[row0 + xsize - 3] += tmp0[row0 + xsize - 2];\r\n    result[row0 + xsize - 1] += tmp0[row0 + xsize - 2];\r\n    result[row0 + xsize - 2] += tmp0[row0 + xsize - 1];\r\n    if (y > 0) {\r\n      const int rowd1 = row0 - xsize;\r\n      result[rowd1 + 1] += tmp1[row0];\r\n      result[rowd1 + 0] += tmp0[row0];\r\n      for (int x = 1; x < xsize - 1; ++x) {\r\n        result[rowd1 + x + 1] += tmp1[row0 + x];\r\n        result[rowd1 + x + 0] += tmp0[row0 + x];\r\n        result[rowd1 + x - 1] += tmp1[row0 + x];\r\n      }\r\n      result[rowd1 + xsize - 1] += tmp0[row0 + xsize - 1];\r\n      result[rowd1 + xsize - 2] += tmp1[row0 + xsize - 1];\r\n    }\r\n    if (y + 1 < ysize) {\r\n      const int rowu1 = row0 + xsize;\r\n      result[rowu1 + 1] += tmp1[row0];\r\n      result[rowu1 + 0] += tmp0[row0];\r\n      for (int x = 1; x < xsize - 1; ++x) {\r\n        result[rowu1 + x + 1] += tmp1[row0 + x];\r\n        result[rowu1 + x + 0] += tmp0[row0 + x];\r\n        result[rowu1 + x - 1] += tmp1[row0 + x];\r\n      }\r\n      result[rowu1 + xsize - 1] += tmp0[row0 + xsize - 1];\r\n      result[rowu1 + xsize - 2] += tmp1[row0 + xsize - 1];\r\n    }\r\n  }\r\n  *diffs = result;\r\n  ScaleImage(scale, diffs);\r\n}\r\n\r\nvoid DiffPrecompute(\r\n    const std::vector<std::vector<float> > &xyb0,\r\n    const std::vector<std::vector<float> > &xyb1,\r\n    size_t xsize, size_t ysize,\r\n    std::vector<std::vector<float> > *mask) {\r\n  PROFILER_FUNC;\r\n  mask->resize(3, std::vector<float>(xyb0[0].size()));\r\n  double valsh0[3] = { 0.0 };\r\n  double valsv0[3] = { 0.0 };\r\n  double valsh1[3] = { 0.0 };\r\n  double valsv1[3] = { 0.0 };\r\n  int ix2;\r\n  for (size_t y = 0; y < ysize; ++y) {\r\n    for (size_t x = 0; x < xsize; ++x) {\r\n      size_t ix = x + xsize * y;\r\n      if (x + 1 < xsize) {\r\n        ix2 = ix + 1;\r\n      } else {\r\n        ix2 = ix - 1;\r\n      }\r\n      {\r\n        double x0 = (xyb0[0][ix] - xyb0[0][ix2]);\r\n        double y0 = (xyb0[1][ix] - xyb0[1][ix2]);\r\n        double z0 = (xyb0[2][ix] - xyb0[2][ix2]);\r\n        XybToVals(x0, y0, z0, &valsh0[0], &valsh0[1], &valsh0[2]);\r\n        double x1 = (xyb1[0][ix] - xyb1[0][ix2]);\r\n        double y1 = (xyb1[1][ix] - xyb1[1][ix2]);\r\n        double z1 = (xyb1[2][ix] - xyb1[2][ix2]);\r\n        XybToVals(x1, y1, z1, &valsh1[0], &valsh1[1], &valsh1[2]);\r\n      }\r\n      if (y + 1 < ysize) {\r\n        ix2 = ix + xsize;\r\n      } else {\r\n        ix2 = ix - xsize;\r\n      }\r\n      {\r\n        double x0 = (xyb0[0][ix] - xyb0[0][ix2]);\r\n        double y0 = (xyb0[1][ix] - xyb0[1][ix2]);\r\n        double z0 = (xyb0[2][ix] - xyb0[2][ix2]);\r\n        XybToVals(x0, y0, z0, &valsv0[0], &valsv0[1], &valsv0[2]);\r\n        double x1 = (xyb1[0][ix] - xyb1[0][ix2]);\r\n        double y1 = (xyb1[1][ix] - xyb1[1][ix2]);\r\n        double z1 = (xyb1[2][ix] - xyb1[2][ix2]);\r\n        XybToVals(x1, y1, z1, &valsv1[0], &valsv1[1], &valsv1[2]);\r\n      }\r\n      for (int i = 0; i < 3; ++i) {\r\n        double sup0 = fabs(valsh0[i]) + fabs(valsv0[i]);\r\n        double sup1 = fabs(valsh1[i]) + fabs(valsv1[i]);\r\n        double m = std::min(sup0, sup1);\r\n        (*mask)[i][ix] = m;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid Mask(const std::vector<std::vector<float> > &xyb0,\r\n          const std::vector<std::vector<float> > &xyb1,\r\n          size_t xsize, size_t ysize,\r\n          std::vector<std::vector<float> > *mask,\r\n          std::vector<std::vector<float> > *mask_dc) {\r\n   PROFILER_FUNC;\r\n  mask->resize(3);\r\n  mask_dc->resize(3);\r\n  for (int i = 0; i < 3; ++i) {\r\n    (*mask)[i].resize(xsize * ysize);\r\n    (*mask_dc)[i].resize(xsize * ysize);\r\n  }\r\n  DiffPrecompute(xyb0, xyb1, xsize, ysize, mask);\r\n  for (int i = 0; i < 3; ++i) {\r\n    Average5x5(xsize, ysize, &(*mask)[i]);\r\n    MinSquareVal(4, 0, xsize, ysize, (*mask)[i].data());\r\n    static const double sigma[3] = {\r\n      9.65781083553,\r\n      14.2644604355,\r\n      4.53358927369,\r\n    };\r\n    Blur(xsize, ysize, (*mask)[i].data(), sigma[i], 0.0);\r\n  }\r\n  static const double w00 = 232.206464018;\r\n  static const double w11 = 22.9455222245;\r\n  static const double w22 = 503.962310606;\r\n\r\n  for (size_t y = 0; y < ysize; ++y) {\r\n    for (size_t x = 0; x < xsize; ++x) {\r\n      const size_t idx = y * xsize + x;\r\n      const double s0 = (*mask)[0][idx];\r\n      const double s1 = (*mask)[1][idx];\r\n      const double s2 = (*mask)[2][idx];\r\n      const double p0 = w00 * s0;\r\n      const double p1 = w11 * s1;\r\n      const double p2 = w22 * s2;\r\n\r\n      (*mask)[0][idx] = MaskX(p0);\r\n      (*mask)[1][idx] = MaskY(p1);\r\n      (*mask)[2][idx] = MaskB(p2);\r\n      (*mask_dc)[0][idx] = MaskDcX(p0);\r\n      (*mask_dc)[1][idx] = MaskDcY(p1);\r\n      (*mask_dc)[2][idx] = MaskDcB(p2);\r\n    }\r\n  }\r\n  for (int i = 0; i < 3; ++i) {\r\n    ScaleImage(kGlobalScale * kGlobalScale, &(*mask)[i]);\r\n    ScaleImage(kGlobalScale * kGlobalScale, &(*mask_dc)[i]);\r\n  }\r\n}\r\n\r\nvoid ButteraugliDiffmap(const std::vector<ImageF> &rgb0_image,\r\n                        const std::vector<ImageF> &rgb1_image,\r\n                        ImageF &result_image) {\r\n  const size_t xsize = rgb0_image[0].xsize();\r\n  const size_t ysize = rgb0_image[0].ysize();\r\n  ButteraugliComparator butteraugli(xsize, ysize, 3);\r\n  butteraugli.Diffmap(rgb0_image, rgb1_image, result_image);\r\n}\r\n\r\nbool ButteraugliInterface(const std::vector<ImageF> &rgb0,\r\n                          const std::vector<ImageF> &rgb1,\r\n                          ImageF &diffmap,\r\n                          double &diffvalue) {\r\n  const size_t xsize = rgb0[0].xsize();\r\n  const size_t ysize = rgb0[0].ysize();\r\n  if (xsize < 1 || ysize < 1) {\r\n    // Butteraugli values for small (where xsize or ysize is smaller\r\n    // than 8 pixels) images are non-sensical, but most likely it is\r\n    // less disruptive to try to compute something than just give up.\r\n    return false;  // No image.\r\n  }\r\n  for (int i = 1; i < 3; i++) {\r\n    if (rgb0[i].xsize() != xsize || rgb0[i].ysize() != ysize ||\r\n        rgb1[i].xsize() != xsize || rgb1[i].ysize() != ysize) {\r\n      return false;  // Image planes must have same dimensions.\r\n    }\r\n  }\r\n  if (xsize < 8 || ysize < 8) {\r\n    for (int y = 0; y < ysize; ++y) {\r\n      for (int x = 0; x < xsize; ++x) {\r\n        diffmap.Row(y)[x] = 0;\r\n      }\r\n    }\r\n    diffvalue = 0;\r\n    return true;\r\n  }\r\n  ButteraugliDiffmap(rgb0, rgb1, diffmap);\r\n  diffvalue = ButteraugliScoreFromDiffmap(diffmap);\r\n  return true;\r\n}\r\n\r\nbool ButteraugliAdaptiveQuantization(size_t xsize, size_t ysize,\r\n    const std::vector<std::vector<float> > &rgb, std::vector<float> &quant) {\r\n  if (xsize < 16 || ysize < 16) {\r\n    return false;  // Butteraugli is undefined for small images.\r\n  }\r\n  size_t size = xsize * ysize;\r\n\r\n  std::vector<std::vector<float> > scale_xyb(3);\r\n  std::vector<std::vector<float> > scale_xyb_dc(3);\r\n  Mask(rgb, rgb, xsize, ysize, &scale_xyb, &scale_xyb_dc);\r\n  quant.resize(size);\r\n\r\n  // Mask gives us values in 3 color channels, but for now we take only\r\n  // the intensity channel.\r\n  for (size_t i = 0; i < size; i++) {\r\n    quant[i] = scale_xyb[1][i];\r\n  }\r\n  return true;\r\n}\r\n\r\ndouble ButteraugliFuzzyClass(double score) {\r\n  static const double fuzzy_width_up = 10.287189655;\r\n  static const double fuzzy_width_down = 6.97490803335;\r\n  static const double m0 = 2.0;\r\n  double fuzzy_width = score < 1.0 ? fuzzy_width_down : fuzzy_width_up;\r\n  return m0 / (1.0 + exp((score - 1.0) * fuzzy_width));\r\n}\r\n\r\ndouble ButteraugliFuzzyInverse(double seek) {\r\n  double pos = 0;\r\n  for (double range = 1.0; range >= 1e-10; range *= 0.5) {\r\n    double cur = ButteraugliFuzzyClass(pos);\r\n    if (cur < seek) {\r\n      pos -= range;\r\n    } else {\r\n      pos += range;\r\n    }\r\n  }\r\n  return pos;\r\n}\r\n\r\n}  // namespace butteraugli\r\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    reverse_iterator();\n    explicit reverse_iterator(Iterator x);\n    template <class U> reverse_iterator(const reverse_iterator<U>& u);\n    Iterator base() const;\n    reference operator*() const;\n    pointer   operator->() const;\n    reverse_iterator& operator++();\n    reverse_iterator  operator++(int);\n    reverse_iterator& operator--();\n    reverse_iterator  operator--(int);\n    reverse_iterator  operator+ (difference_type n) const;\n    reverse_iterator& operator+=(difference_type n);\n    reverse_iterator  operator- (difference_type n) const;\n    reverse_iterator& operator-=(difference_type n);\n    reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\ntypename reverse_iterator<Iterator1>::difference_type\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator>\nreverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);\n\ntemplate <class Iterator> reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef back_insert_iterator<Cont>& reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef front_insert_iterator<Cont>& reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef insert_iterator<Cont>& reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    constexpr istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> auto end(C& c) -> decltype(c.end());\ntemplate <class C> auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> T* begin(T (&array)[N]);\ntemplate <class T, size_t N> T* end(T (&array)[N]);\n\ntemplate <class C> auto cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);        // C++14\ntemplate <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n// 24.8, container access:\ntemplate <class C> constexpr auto size(const C& c) -> decltype(c.size());         // C++17\ntemplate <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept; // C++17\ntemplate <class C> constexpr auto empty(const C& c) -> decltype(c.empty());       // C++17\ntemplate <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;  // C++17\ntemplate <class E> constexpr bool empty(initializer_list<E> il) noexcept;         // C++17\ntemplate <class C> constexpr auto data(C& c) -> decltype(c.data());               // C++17\ntemplate <class C> constexpr auto data(const C& c) -> decltype(c.data());         // C++17\ntemplate <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;           // C++17\ntemplate <class E> constexpr const E* data(initializer_list<E> il) noexcept;      // C++17\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declarations of vector and string.\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TYPE_VIS_ONLY input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY output_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_exactly_input_iterator\n    : public integral_constant<bool, \n    \t __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value && \n    \t!__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIter\nnext(_InputIter __x,\n     typename iterator_traits<_InputIter>::difference_type __n = 1,\n     typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    mutable _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator() : current() {}\n    _LIBCPP_INLINE_VISIBILITY explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY reverse_iterator(const reverse_iterator<_Up>& __u)\n        : __t(__u.base()), current(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator++(int)\n        {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator--(int)\n        {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator+ (difference_type __n) const\n        {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator+=(difference_type __n)\n        {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator- (difference_type __n) const\n        {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator-=(difference_type __n)\n        {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n        {return *(*this + __n);}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      back_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      front_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TYPE_VIS_ONLY istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator() : __in_stream_(0), __value_() {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(&__s)\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s)\n        : __out_stream_(&__s), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter)\n        : __out_stream_(&__s), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef iterator_type pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef typename iterator_traits<iterator_type>::reference __reference;\n    typedef typename conditional<\n            is_reference<__reference>::value,\n            typename remove_reference<__reference>::type&&,\n            __reference\n        >::type reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY move_iterator(const move_iterator<_Up>& __u)\n        : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {\n      return static_cast<reference>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const { return __i;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator++(int)\n        {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator--(int)\n        {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator+ (difference_type __n) const\n        {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator+=(difference_type __n)\n        {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator- (difference_type __n) const\n        {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator-=(difference_type __n)\n        {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n    {\n      return static_cast<reference>(__i[__n]);\n    }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)_VSTD::addressof(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class _LIBCPP_TYPE_VIS_ONLY vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n\t: public _LIBCPP_BOOL_CONSTANT(is_pointer<_Iter>::value) {};\n\t\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n\t: public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >\n\t: public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n\t: public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(begin(__c))\n{\n    return begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(end(__c))\n{\n    return end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crbegin(const _Cp& __c) -> decltype(rbegin(__c))\n{\n    return rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crend(const _Cp& __c) -> decltype(rend(__c))\n{\n    return rend(__c);\n}\n\n#endif\n\n\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Cont>\nconstexpr auto size(const _Cont& __c) -> decltype(__c.size()) { return __c.size(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr size_t size(const _Tp (&__array)[_Sz]) noexcept { return _Sz; }\n\ntemplate <class _Cont>\nconstexpr auto empty(const _Cont& __c) -> decltype(__c.empty()) { return __c.empty(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr bool empty(const _Tp (&__array)[_Sz]) noexcept { return false; }\n\ntemplate <class _Ep>\nconstexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }\n\ntemplate <class _Cont> constexpr\nauto data(_Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Cont> constexpr\nauto data(const _Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }\n\ntemplate <class _Ep>\nconstexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }\n#endif\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/debug_print.h\"\r\n\r\nnamespace guetzli {\r\n\r\nvoid PrintDebug(ProcessStats* stats, std::string s) {\r\n  if (stats->debug_output) {\r\n    stats->debug_output->append(s);\r\n  }\r\n  if (stats->debug_output_file) {\r\n    fprintf(stats->debug_output_file, \"%s\", s.c_str());\r\n  }\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/jpeg_data_decoder.h\"\r\n\r\n//#include \"guetzli/output_image.h\"\r\n\r\nnamespace guetzli {\r\n\r\n// Mimic libjpeg's heuristics to guess jpeg color space.\r\n// Requires that the jpg has 3 components.\r\nbool HasYCbCrColorSpace(const JPEGData& jpg) {\r\n  bool has_Adobe_marker = false;\r\n  uint8_t Adobe_transform = 0;\r\n  for (const std::string& app : jpg.app_data) {\r\n    if (static_cast<uint8_t>(app[0]) == 0xe0) {\r\n      return true;\r\n    } else if (static_cast<uint8_t>(app[0]) == 0xee && app.size() >= 15) {\r\n      has_Adobe_marker = true;\r\n      Adobe_transform = app[14];\r\n    }\r\n  }\r\n  if (has_Adobe_marker) {\r\n    return (Adobe_transform != 0);\r\n  }\r\n  const int cid0 = jpg.components[0].id;\r\n  const int cid1 = jpg.components[1].id;\r\n  const int cid2 = jpg.components[2].id;\r\n  return (cid0 != 'R' || cid1 != 'G' || cid2 != 'B');\r\n}\r\n\r\nstd::vector<uint8_t> DecodeJpegToRGB(const JPEGData& jpg) {\r\n  if (jpg.components.size() == 1 ||\r\n      (jpg.components.size() == 3 &&\r\n       HasYCbCrColorSpace(jpg) && (jpg.Is420() || jpg.Is444()))) {\r\n    OutputImage img(jpg.width, jpg.height);\r\n    img.CopyFromJpegData(jpg);\r\n    return img.ToSRGB();\r\n  }\r\n  return std::vector<uint8_t>();\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Integer implementation of the Discrete Cosine Transform (DCT)\r\n//\r\n// Note! DCT output is kept scaled by 16, to retain maximum 16bit precision\r\n\r\n#include \"guetzli/fdct.h\"\r\n\r\nnamespace guetzli {\r\n\r\nnamespace {\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Cosine table: C(k) = cos(k.pi/16)/sqrt(2), k = 1..7 using 15 bits signed\r\nconst coeff_t kTable04[7] = { 22725, 21407, 19266, 16384, 12873,  8867, 4520 };\r\n// rows #1 and #7 are pre-multiplied by 2.C(1) before the 2nd pass.\r\n// This multiply is merged in the table of constants used during 1st pass:\r\nconst coeff_t kTable17[7] = { 31521, 29692, 26722, 22725, 17855, 12299, 6270 };\r\n// rows #2 and #6 are pre-multiplied by 2.C(2):\r\nconst coeff_t kTable26[7] = { 29692, 27969, 25172, 21407, 16819, 11585, 5906 };\r\n// rows #3 and #5 are pre-multiplied by 2.C(3):\r\nconst coeff_t kTable35[7] = { 26722, 25172, 22654, 19266, 15137, 10426, 5315 };\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Constants (15bit precision) and C macros for IDCT vertical pass\r\n\r\n#define kTan1   (13036)   // = tan(pi/16)\r\n#define kTan2   (27146)   // = tan(2.pi/16) = sqrt(2) - 1.\r\n#define kTan3m1 (-21746)  // = tan(3.pi/16) - 1\r\n#define k2Sqrt2 (23170)   // = 1 / 2.sqrt(2)\r\n\r\n  // performs: {a,b} <- {a-b, a+b}, without saturation\r\n#define BUTTERFLY(a, b) do {   \\\r\n  SUB((a), (b));               \\\r\n  ADD((b), (b));               \\\r\n  ADD((b), (a));               \\\r\n} while (0)\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Constants for DCT horizontal pass\r\n\r\n// Note about the CORRECT_LSB macro:\r\n// using 16bit fixed-point constants, we often compute products like:\r\n// p = (A*x + B*y + 32768) >> 16 by adding two sub-terms q = (A*x) >> 16\r\n// and r = (B*y) >> 16 together. Statistically, we have p = q + r + 1\r\n// in 3/4 of the cases. This can be easily seen from the relation:\r\n//   (a + b + 1) >> 1 = (a >> 1) + (b >> 1) + ((a|b)&1)\r\n// The approximation we are doing is replacing ((a|b)&1) by 1.\r\n// In practice, this is a slightly more involved because the constants A and B\r\n// have also been rounded compared to their exact floating point value.\r\n// However, all in all the correction is quite small, and CORRECT_LSB can\r\n// be defined empty if needed.\r\n\r\n#define COLUMN_DCT8(in) do { \\\r\n  LOAD(m0, (in)[0 * 8]);     \\\r\n  LOAD(m2, (in)[2 * 8]);     \\\r\n  LOAD(m7, (in)[7 * 8]);     \\\r\n  LOAD(m5, (in)[5 * 8]);     \\\r\n                             \\\r\n  BUTTERFLY(m0, m7);         \\\r\n  BUTTERFLY(m2, m5);         \\\r\n                             \\\r\n  LOAD(m3, (in)[3 * 8]);     \\\r\n  LOAD(m4, (in)[4 * 8]);     \\\r\n  BUTTERFLY(m3, m4);         \\\r\n                             \\\r\n  LOAD(m6, (in)[6 * 8]);     \\\r\n  LOAD(m1, (in)[1 * 8]);     \\\r\n  BUTTERFLY(m1, m6);         \\\r\n  BUTTERFLY(m7, m4);         \\\r\n  BUTTERFLY(m6, m5);         \\\r\n                             \\\r\n  /* RowIdct() needs 15bits fixed-point input, when the output from   */ \\\r\n  /* ColumnIdct() would be 12bits. We are better doing the shift by 3 */ \\\r\n  /* now instead of in RowIdct(), because we have some multiplies to  */ \\\r\n  /* perform, that can take advantage of the extra 3bits precision.   */ \\\r\n  LSHIFT(m4, 3);             \\\r\n  LSHIFT(m5, 3);             \\\r\n  BUTTERFLY(m4, m5);         \\\r\n  STORE16((in)[0 * 8], m5);  \\\r\n  STORE16((in)[4 * 8], m4);  \\\r\n                             \\\r\n  LSHIFT(m7, 3);             \\\r\n  LSHIFT(m6, 3);             \\\r\n  LSHIFT(m3, 3);             \\\r\n  LSHIFT(m0, 3);             \\\r\n                             \\\r\n  LOAD_CST(m4, kTan2);       \\\r\n  m5 = m4;                   \\\r\n  MULT(m4, m7);              \\\r\n  MULT(m5, m6);              \\\r\n  SUB(m4, m6);               \\\r\n  ADD(m5, m7);               \\\r\n  STORE16((in)[2 * 8], m5);  \\\r\n  STORE16((in)[6 * 8], m4);  \\\r\n                             \\\r\n  /* We should be multiplying m6 by C4 = 1/sqrt(2) here, but we only have */ \\\r\n  /* the k2Sqrt2 = 1/(2.sqrt(2)) constant that fits into 15bits. So we    */ \\\r\n  /* shift by 4 instead of 3 to compensate for the additional 1/2 factor. */ \\\r\n  LOAD_CST(m6, k2Sqrt2);     \\\r\n  LSHIFT(m2, 3 + 1);         \\\r\n  LSHIFT(m1, 3 + 1);         \\\r\n  BUTTERFLY(m1, m2);         \\\r\n  MULT(m2, m6);              \\\r\n  MULT(m1, m6);              \\\r\n  BUTTERFLY(m3, m1);         \\\r\n  BUTTERFLY(m0, m2);         \\\r\n                             \\\r\n  LOAD_CST(m4, kTan3m1);     \\\r\n  LOAD_CST(m5, kTan1);       \\\r\n  m7 = m3;                   \\\r\n  m6 = m1;                   \\\r\n  MULT(m3, m4);              \\\r\n  MULT(m1, m5);              \\\r\n                             \\\r\n  ADD(m3, m7);               \\\r\n  ADD(m1, m2);               \\\r\n  CORRECT_LSB(m1);           \\\r\n  CORRECT_LSB(m3);           \\\r\n  MULT(m4, m0);              \\\r\n  MULT(m5, m2);              \\\r\n  ADD(m4, m0);               \\\r\n  SUB(m0, m3);               \\\r\n  ADD(m7, m4);               \\\r\n  SUB(m5, m6);               \\\r\n                             \\\r\n  STORE16((in)[1 * 8], m1);  \\\r\n  STORE16((in)[3 * 8], m0);  \\\r\n  STORE16((in)[5 * 8], m7);  \\\r\n  STORE16((in)[7 * 8], m5);  \\\r\n} while (0)\r\n\r\n\r\n// these are the macro required by COLUMN_*\r\n#define LOAD_CST(dst, src) (dst) = (src)\r\n#define LOAD(dst, src) (dst) = (src)\r\n#define MULT(a, b)  (a) = (((a) * (b)) >> 16)\r\n#define ADD(a, b)   (a) = (a) + (b)\r\n#define SUB(a, b)   (a) = (a) - (b)\r\n#define LSHIFT(a, n) (a) = ((a) << (n))\r\n#define STORE16(a, b) (a) = (b)\r\n#define CORRECT_LSB(a) (a) += 1\r\n\r\n// DCT vertical pass\r\n\r\ninline void ColumnDct(coeff_t* in) {\r\n  for (int i = 0; i < 8; ++i) {\r\n    int m0, m1, m2, m3, m4, m5, m6, m7;\r\n    COLUMN_DCT8(in + i);\r\n  }\r\n}\r\n\r\n// DCT horizontal pass\r\n\r\n// We don't really need to round before descaling, since we\r\n// still have 4 bits of precision left as final scaled output.\r\n#define DESCALE(a)  static_cast<coeff_t>((a) >> 16)\r\n\r\nvoid RowDct(coeff_t* in, const coeff_t* table) {\r\n  // The Fourier transform is an unitary operator, so we're basically\r\n  // doing the transpose of RowIdct()\r\n  const int a0 = in[0] + in[7];\r\n  const int b0 = in[0] - in[7];\r\n  const int a1 = in[1] + in[6];\r\n  const int b1 = in[1] - in[6];\r\n  const int a2 = in[2] + in[5];\r\n  const int b2 = in[2] - in[5];\r\n  const int a3 = in[3] + in[4];\r\n  const int b3 = in[3] - in[4];\r\n\r\n  // even part\r\n  const int C2 = table[1];\r\n  const int C4 = table[3];\r\n  const int C6 = table[5];\r\n  const int c0 = a0 + a3;\r\n  const int c1 = a0 - a3;\r\n  const int c2 = a1 + a2;\r\n  const int c3 = a1 - a2;\r\n\r\n  in[0] = DESCALE(C4 * (c0 + c2));\r\n  in[4] = DESCALE(C4 * (c0 - c2));\r\n  in[2] = DESCALE(C2 * c1 + C6 * c3);\r\n  in[6] = DESCALE(C6 * c1 - C2 * c3);\r\n\r\n  // odd part\r\n  const int C1 = table[0];\r\n  const int C3 = table[2];\r\n  const int C5 = table[4];\r\n  const int C7 = table[6];\r\n  in[1] = DESCALE(C1 * b0 + C3 * b1 + C5 * b2 + C7 * b3);\r\n  in[3] = DESCALE(C3 * b0 - C7 * b1 - C1 * b2 - C5 * b3);\r\n  in[5] = DESCALE(C5 * b0 - C1 * b1 + C7 * b2 + C3 * b3);\r\n  in[7] = DESCALE(C7 * b0 - C5 * b1 + C3 * b2 - C1 * b3);\r\n}\r\n#undef DESCALE\r\n#undef LOAD_CST\r\n#undef LOAD\r\n#undef MULT\r\n#undef ADD\r\n#undef SUB\r\n#undef LSHIFT\r\n#undef STORE16\r\n#undef CORRECT_LSB\r\n#undef kTan1\r\n#undef kTan2\r\n#undef kTan3m1\r\n#undef k2Sqrt2\r\n#undef BUTTERFLY\r\n#undef COLUMN_DCT8\r\n\r\n}  // namespace\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// visible FDCT callable functions\r\n\r\nvoid ComputeBlockDCT(coeff_t* coeffs) {\r\n  ColumnDct(coeffs);\r\n  RowDct(coeffs + 0 * 8, kTable04);\r\n  RowDct(coeffs + 1 * 8, kTable17);\r\n  RowDct(coeffs + 2 * 8, kTable26);\r\n  RowDct(coeffs + 3 * 8, kTable35);\r\n  RowDct(coeffs + 4 * 8, kTable04);\r\n  RowDct(coeffs + 5 * 8, kTable35);\r\n  RowDct(coeffs + 6 * 8, kTable26);\r\n  RowDct(coeffs + 7 * 8, kTable17);\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/jpeg_data_encoder.h\"\r\n\r\n#include <algorithm>\r\n#include <string.h>\r\n\r\n#include \"guetzli/fdct.cc\"\r\n\r\nnamespace guetzli {\r\n\r\nnamespace {\r\n\r\nstatic const int kIQuantBits = 16;\r\n// Output of the DCT is upscaled by 16.\r\nstatic const int kDCTBits = kIQuantBits + 4;\r\nstatic const int kBias = 0x80 << (kDCTBits - 8);\r\n\r\nvoid Quantize1(coeff_t* v, int iquant) {\r\n  *v = (*v * iquant + kBias) >> kDCTBits;\r\n}\r\n\r\n// Single pixel rgb to 16-bit yuv conversion.\r\n// The returned yuv values are signed integers in the\r\n// range [-128, 127] inclusive.\r\ninline static void RGBToYUV16(const uint8_t* const rgb,\r\n                              coeff_t *out) {\r\n  enum { FRAC = 16, HALF = 1 << (FRAC - 1) };\r\n  const int r = rgb[0];\r\n  const int g = rgb[1];\r\n  const int b = rgb[2];\r\n  out[0] = (19595 * r  + 38469 * g +  7471 * b - (128 << 16) + HALF) >> FRAC;\r\n  out[64] = (-11059 * r - 21709 * g + 32768 * b + HALF - 1) >> FRAC;\r\n  out[128] = (32768 * r  - 27439 * g -  5329 * b + HALF - 1) >> FRAC;\r\n}\r\n\r\n}  // namespace\r\n\r\nvoid AddApp0Data(JPEGData* jpg) {\r\n  const unsigned char kApp0Data[] = {\r\n      0xe0, 0x00, 0x10,              // APP0\r\n      0x4a, 0x46, 0x49, 0x46, 0x00,  // 'JFIF'\r\n      0x01, 0x01,                    // v1.01\r\n      0x00, 0x00, 0x01, 0x00, 0x01,  // aspect ratio = 1:1\r\n      0x00, 0x00                     // thumbnail width/height\r\n  };\r\n  jpg->app_data.push_back(\r\n      std::string(reinterpret_cast<const char*>(kApp0Data),\r\n                                 sizeof(kApp0Data)));\r\n}\r\n\r\nbool EncodeRGBToJpeg(const std::vector<uint8_t>& rgb, int w, int h,\r\n                     const int* quant, JPEGData* jpg) {\r\n  if (w < 0 || w >= 1 << 16 || h < 0 || h >= 1 << 16 ||\r\n      rgb.size() != 3 * w * h) {\r\n    return false;\r\n  }\r\n  InitJPEGDataForYUV444(w, h, jpg);\r\n  AddApp0Data(jpg);\r\n\r\n  int iquant[3 * kDCTBlockSize];\r\n  int idx = 0;\r\n  for (int i = 0; i < 3; ++i) {\r\n    for (int j = 0; j < kDCTBlockSize; ++j) {\r\n      int v = quant[idx];\r\n      jpg->quant[i].values[j] = v;\r\n      iquant[idx++] = ((1 << kIQuantBits) + 1) / v;\r\n    }\r\n  }\r\n\r\n  // Compute YUV444 DCT coefficients.\r\n  int block_ix = 0;\r\n  for (int block_y = 0; block_y < jpg->MCU_rows; ++block_y) {\r\n    for (int block_x = 0; block_x < jpg->MCU_cols; ++block_x) {\r\n      coeff_t block[3 * kDCTBlockSize];\r\n      // RGB->YUV transform.\r\n      for (int iy = 0; iy < 8; ++iy) {\r\n        for (int ix = 0; ix < 8; ++ix) {\r\n          int y = std::min(h - 1, 8 * block_y + iy);\r\n          int x = std::min(w - 1, 8 * block_x + ix);\r\n          int p = y * w + x;\r\n          RGBToYUV16(&rgb[3 * p], &block[8 * iy + ix]);\r\n        }\r\n      }\r\n      // DCT\r\n      for (int i = 0; i < 3; ++i) {\r\n        ComputeBlockDCT(&block[i * kDCTBlockSize]);\r\n      }\r\n      // Quantization\r\n      for (int i = 0; i < 3 * 64; ++i) {\r\n        Quantize1(&block[i], iquant[i]);\r\n      }\r\n      // Copy the resulting coefficients to *jpg.\r\n      for (int i = 0; i < 3; ++i) {\r\n        memcpy(&jpg->components[i].coeffs[block_ix * kDCTBlockSize],\r\n               &block[i * kDCTBlockSize], kDCTBlockSize * sizeof(block[0]));\r\n      }\r\n      ++block_ix;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nbool EncodeRGBToJpeg(const std::vector<uint8_t>& rgb, int w, int h,\r\n                     JPEGData* jpg) {\r\n  static const int quant[3 * kDCTBlockSize] = {\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n  };\r\n  return EncodeRGBToJpeg(rgb, w, h, quant, jpg);\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Data structures that represent the contents of a jpeg file.\r\n\r\n#ifndef GUETZLI_JPEG_DATA_H_\r\n#define GUETZLI_JPEG_DATA_H_\r\n\r\n#include <stddef.h>\r\n#include <stdint.h>\r\n#include <string>\r\n#include <vector>\r\n\r\n#include \"guetzli/jpeg_error.h\"\r\n\r\nnamespace guetzli {\r\n\r\nstatic const int kDCTBlockSize = 64;\r\nstatic const int kMaxComponents = 4;\r\nstatic const int kMaxQuantTables = 4;\r\nstatic const int kMaxHuffmanTables = 4;\r\nstatic const int kJpegHuffmanMaxBitLength = 16;\r\nstatic const int kJpegHuffmanAlphabetSize = 256;\r\nstatic const int kJpegDCAlphabetSize = 12;\r\nstatic const int kMaxDHTMarkers = 512;\r\n\r\nstatic const uint8_t kDefaultQuantMatrix[2][64] = {\r\n  { 16,  11,  10,  16,  24,  40,  51,  61,\r\n    12,  12,  14,  19,  26,  58,  60,  55,\r\n    14,  13,  16,  24,  40,  57,  69,  56,\r\n    14,  17,  22,  29,  51,  87,  80,  62,\r\n    18,  22,  37,  56,  68, 109, 103,  77,\r\n    24,  35,  55,  64,  81, 104, 113,  92,\r\n    49,  64,  78,  87, 103, 121, 120, 101,\r\n    72,  92,  95,  98, 112, 100, 103,  99 },\r\n  { 17,  18,  24,  47,  99,  99,  99,  99,\r\n    18,  21,  26,  66,  99,  99,  99,  99,\r\n    24,  26,  56,  99,  99,  99,  99,  99,\r\n    47,  66,  99,  99,  99,  99,  99,  99,\r\n    99,  99,  99,  99,  99,  99,  99,  99,\r\n    99,  99,  99,  99,  99,  99,  99,  99,\r\n    99,  99,  99,  99,  99,  99,  99,  99,\r\n    99,  99,  99,  99,  99,  99,  99,  99 }\r\n};\r\n\r\nconst int kJPEGNaturalOrder[80] = {\r\n  0,   1,  8, 16,  9,  2,  3, 10,\r\n  17, 24, 32, 25, 18, 11,  4,  5,\r\n  12, 19, 26, 33, 40, 48, 41, 34,\r\n  27, 20, 13,  6,  7, 14, 21, 28,\r\n  35, 42, 49, 56, 57, 50, 43, 36,\r\n  29, 22, 15, 23, 30, 37, 44, 51,\r\n  58, 59, 52, 45, 38, 31, 39, 46,\r\n  53, 60, 61, 54, 47, 55, 62, 63,\r\n  // extra entries for safety in decoder\r\n  63, 63, 63, 63, 63, 63, 63, 63,\r\n  63, 63, 63, 63, 63, 63, 63, 63\r\n};\r\n\r\nconst int kJPEGZigZagOrder[64] = {\r\n  0,   1,  5,  6, 14, 15, 27, 28,\r\n  2,   4,  7, 13, 16, 26, 29, 42,\r\n  3,   8, 12, 17, 25, 30, 41, 43,\r\n  9,  11, 18, 24, 31, 40, 44, 53,\r\n  10, 19, 23, 32, 39, 45, 52, 54,\r\n  20, 22, 33, 38, 46, 51, 55, 60,\r\n  21, 34, 37, 47, 50, 56, 59, 61,\r\n  35, 36, 48, 49, 57, 58, 62, 63\r\n};\r\n\r\n// Quantization values for an 8x8 pixel block.\r\nstruct JPEGQuantTable {\r\n  JPEGQuantTable() : values(kDCTBlockSize), precision(0),\r\n                     index(0), is_last(true) {}\r\n\r\n  std::vector<int> values;\r\n  int precision;\r\n  // The index of this quantization table as it was parsed from the input JPEG.\r\n  // Each DQT marker segment contains an 'index' field, and we save this index\r\n  // here. Valid values are 0 to 3.\r\n  int index;\r\n  // Set to true if this table is the last one within its marker segment.\r\n  bool is_last;\r\n};\r\n\r\n// Huffman code and decoding lookup table used for DC and AC coefficients.\r\nstruct JPEGHuffmanCode {\r\n  JPEGHuffmanCode() : counts(kJpegHuffmanMaxBitLength + 1),\r\n                      values(kJpegHuffmanAlphabetSize + 1),\r\n                      slot_id(0),\r\n                      is_last(true) {}\r\n\r\n  // Bit length histogram.\r\n  std::vector<int> counts;\r\n  // Symbol values sorted by increasing bit lengths.\r\n  std::vector<int> values;\r\n  // The index of the Huffman code in the current set of Huffman codes. For AC\r\n  // component Huffman codes, 0x10 is added to the index.\r\n  int slot_id;\r\n  // Set to true if this Huffman code is the last one within its marker segment.\r\n  bool is_last;\r\n};\r\n\r\n// Huffman table indexes used for one component of one scan.\r\nstruct JPEGComponentScanInfo {\r\n  int comp_idx;\r\n  int dc_tbl_idx;\r\n  int ac_tbl_idx;\r\n};\r\n\r\n// Contains information that is used in one scan.\r\nstruct JPEGScanInfo {\r\n  // Parameters used for progressive scans (named the same way as in the spec):\r\n  //   Ss : Start of spectral band in zig-zag sequence.\r\n  //   Se : End of spectral band in zig-zag sequence.\r\n  //   Ah : Successive approximation bit position, high.\r\n  //   Al : Successive approximation bit position, low.\r\n  int Ss;\r\n  int Se;\r\n  int Ah;\r\n  int Al;\r\n  std::vector<JPEGComponentScanInfo> components;\r\n};\r\n\r\ntypedef int16_t coeff_t;\r\n\r\n// Represents one component of a jpeg file.\r\nstruct JPEGComponent {\r\n  JPEGComponent() : id(0),\r\n                    h_samp_factor(1),\r\n                    v_samp_factor(1),\r\n                    quant_idx(0),\r\n                    width_in_blocks(0),\r\n                    height_in_blocks(0) {}\r\n\r\n  // One-byte id of the component.\r\n  int id;\r\n  // Horizontal and vertical sampling factors.\r\n  // In interleaved mode, each minimal coded unit (MCU) has\r\n  // h_samp_factor x v_samp_factor DCT blocks from this component.\r\n  int h_samp_factor;\r\n  int v_samp_factor;\r\n  // The index of the quantization table used for this component.\r\n  int quant_idx;\r\n  // The dimensions of the component measured in 8x8 blocks.\r\n  int width_in_blocks;\r\n  int height_in_blocks;\r\n  int num_blocks;\r\n  // The DCT coefficients of this component, laid out block-by-block, divided\r\n  // through the quantization matrix values.\r\n  std::vector<coeff_t> coeffs;\r\n};\r\n\r\n// Represents a parsed jpeg file.\r\nstruct JPEGData {\r\n  JPEGData() : width(0),\r\n               height(0),\r\n               version(0),\r\n               max_h_samp_factor(1),\r\n               max_v_samp_factor(1),\r\n               MCU_rows(0),\r\n               MCU_cols(0),\r\n               restart_interval(0),\r\n               original_jpg(NULL),\r\n               original_jpg_size(0),\r\n               error(JPEG_OK) {}\r\n\r\n  bool Is420() const;\r\n  bool Is444() const;\r\n\r\n  int width;\r\n  int height;\r\n  int version;\r\n  int max_h_samp_factor;\r\n  int max_v_samp_factor;\r\n  int MCU_rows;\r\n  int MCU_cols;\r\n  int restart_interval;\r\n  std::vector<std::string> app_data;\r\n  std::vector<std::string> com_data;\r\n  std::vector<JPEGQuantTable> quant;\r\n  std::vector<JPEGHuffmanCode> huffman_code;\r\n  std::vector<JPEGComponent> components;\r\n  std::vector<JPEGScanInfo> scan_info;\r\n  std::vector<uint8_t> marker_order;\r\n  std::vector<std::string> inter_marker_data;\r\n  std::string tail_data;\r\n  const uint8_t* original_jpg;\r\n  size_t original_jpg_size;\r\n  JPEGReadError error;\r\n};\r\n\r\nvoid InitJPEGDataForYUV444(int w, int h, JPEGData* jpg);\r\nvoid SaveQuantTables(const int q[3][kDCTBlockSize], JPEGData* jpg);\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_JPEG_DATA_H_\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/jpeg_huffman_decode.h\"\r\n\r\n#include <assert.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#include \"guetzli/jpeg_data.cc\"\r\n\r\nnamespace guetzli {\r\n\r\n// Returns the table width of the next 2nd level table, count is the histogram\r\n// of bit lengths for the remaining symbols, len is the code length of the next\r\n// processed symbol.\r\nstatic inline int NextTableBitSize(const int* count, int len) {\r\n  int left = 1 << (len - kJpegHuffmanRootTableBits);\r\n  while (len < kJpegHuffmanMaxBitLength) {\r\n    left -= count[len];\r\n    if (left <= 0) break;\r\n    ++len;\r\n    left <<= 1;\r\n  }\r\n  return len - kJpegHuffmanRootTableBits;\r\n}\r\n\r\nint BuildJpegHuffmanTable(const int* count_in, const int* symbols,\r\n                          HuffmanTableEntry* lut) {\r\n  HuffmanTableEntry code;    // current table entry\r\n  HuffmanTableEntry* table;  // next available space in table\r\n  int len;         // current code length\r\n  int idx;         // symbol index\r\n  int key;         // prefix code\r\n  int reps;        // number of replicate key values in current table\r\n  int low;         // low bits for current root entry\r\n  int table_bits;  // key length of current table\r\n  int table_size;  // size of current table\r\n  int total_size;  // sum of root table size and 2nd level table sizes\r\n\r\n  // Make a local copy of the input bit length histogram.\r\n  int count[kJpegHuffmanMaxBitLength + 1] = { 0 };\r\n  int total_count = 0;\r\n  for (len = 1; len <= kJpegHuffmanMaxBitLength; ++len) {\r\n    count[len] = count_in[len];\r\n    total_count += count[len];\r\n  }\r\n\r\n  table = lut;\r\n  table_bits = kJpegHuffmanRootTableBits;\r\n  table_size = 1 << table_bits;\r\n  total_size = table_size;\r\n\r\n  // Special case code with only one value.\r\n  if (total_count == 1) {\r\n    code.bits = 0;\r\n    code.value = symbols[0];\r\n    for (key = 0; key < total_size; ++key) {\r\n      table[key] = code;\r\n    }\r\n    return total_size;\r\n  }\r\n\r\n  // Fill in root table.\r\n  key = 0;\r\n  idx = 0;\r\n  for (len = 1; len <= kJpegHuffmanRootTableBits; ++len) {\r\n    for (; count[len] > 0; --count[len]) {\r\n      code.bits = len;\r\n      code.value = symbols[idx++];\r\n      reps = 1 << (kJpegHuffmanRootTableBits - len);\r\n      while (reps--) {\r\n        table[key++] = code;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Fill in 2nd level tables and add pointers to root table.\r\n  table += table_size;\r\n  table_size = 0;\r\n  low = 0;\r\n  for (len = kJpegHuffmanRootTableBits + 1;\r\n       len <= kJpegHuffmanMaxBitLength; ++len) {\r\n    for (; count[len] > 0; --count[len]) {\r\n      // Start a new sub-table if the previous one is full.\r\n      if (low >= table_size) {\r\n        table += table_size;\r\n        table_bits = NextTableBitSize(count, len);\r\n        table_size = 1 << table_bits;\r\n        total_size += table_size;\r\n        low = 0;\r\n        lut[key].bits = table_bits + kJpegHuffmanRootTableBits;\r\n        lut[key].value = (table - lut) - key;\r\n        ++key;\r\n      }\r\n      code.bits = len - kJpegHuffmanRootTableBits;\r\n      code.value = symbols[idx++];\r\n      reps = 1 << (table_bits - code.bits);\r\n      while (reps--) {\r\n        table[low++] = code;\r\n      }\r\n    }\r\n  }\r\n\r\n  return total_size;\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Utility function for building a Huffman lookup table for the jpeg decoder.\r\n\r\n#ifndef GUETZLI_JPEG_HUFFMAN_DECODE_H_\r\n#define GUETZLI_JPEG_HUFFMAN_DECODE_H_\r\n\r\n#include <inttypes.h>\r\n\r\nnamespace guetzli {\r\n\r\nstatic const int kJpegHuffmanRootTableBits = 8;\r\n// Maximum huffman lookup table size.\r\n// According to zlib/examples/enough.c, 758 entries are always enough for\r\n// an alphabet of 257 symbols (256 + 1 special symbol for the all 1s code) and\r\n// max bit length 16 if the root table has 8 bits.\r\nstatic const int kJpegHuffmanLutSize = 758;\r\n\r\nstruct HuffmanTableEntry {\r\n  // Initialize the value to an invalid symbol so that we can recognize it\r\n  // when reading the bit stream using a Huffman code with space > 0.\r\n  HuffmanTableEntry() : bits(0), value(0xffff) {}\r\n\r\n  uint8_t bits;     // number of bits used for this symbol\r\n  uint16_t value;   // symbol value or table offset\r\n};\r\n\r\n// Builds jpeg-style Huffman lookup table from the given symbols.\r\n// The symbols are in order of increasing bit lengths. The number of symbols\r\n// with bit length n is given in counts[n] for each n >= 1.\r\n// Returns the size of the lookup table.\r\nint BuildJpegHuffmanTable(const int* counts, const int* symbols,\r\n                          HuffmanTableEntry* lut);\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_JPEG_HUFFMAN_DECODE_H_\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/jpeg_data_reader.h\"\r\n\r\n#include <algorithm>\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#include \"guetzli/jpeg_huffman_decode.cc\"\r\n\r\nnamespace guetzli {\r\n\r\nnamespace {\r\n\r\n// Macros for commonly used error conditions.\r\n\r\n#define VERIFY_LEN(n)                                                   \\\r\n  if (*pos + (n) > len) {                                               \\\r\n    fprintf(stderr, \"Unexpected end of input: pos=%d need=%d len=%d\\n\", \\\r\n            static_cast<int>(*pos), static_cast<int>(n),                \\\r\n            static_cast<int>(len));                                     \\\r\n    jpg->error = JPEG_UNEXPECTED_EOF;                                   \\\r\n    return false;                                                       \\\r\n  }\r\n\r\n#define VERIFY_INPUT(var, low, high, code)                              \\\r\n  if (var < low || var > high) {                                        \\\r\n    fprintf(stderr, \"Invalid %s: %d\\n\", #var, static_cast<int>(var));   \\\r\n    jpg->error = JPEG_INVALID_ ## code;                                 \\\r\n        return false;                                                   \\\r\n  }\r\n\r\n#define VERIFY_MARKER_END()                                             \\\r\n  if (start_pos + marker_len != *pos) {                                 \\\r\n    fprintf(stderr, \"Invalid marker length: declared=%d actual=%d\\n\",   \\\r\n            static_cast<int>(marker_len),                               \\\r\n            static_cast<int>(*pos - start_pos));                        \\\r\n    jpg->error = JPEG_WRONG_MARKER_SIZE;                                \\\r\n    return false;                                                       \\\r\n  }\r\n\r\n#define EXPECT_MARKER() \\\r\n  if (pos + 2 > len || data[pos] != 0xff) {                             \\\r\n    fprintf(stderr, \"Marker byte (0xff) expected, found: %d \"           \\\r\n            \"pos=%d len=%d\\n\",                                          \\\r\n            (pos < len ? data[pos] : 0), static_cast<int>(pos),         \\\r\n            static_cast<int>(len));                                     \\\r\n    jpg->error = JPEG_MARKER_BYTE_NOT_FOUND;                            \\\r\n    return false;                                                       \\\r\n  }\r\n\r\n// Returns ceil(a/b).\r\ninline int DivCeil(int a, int b) {\r\n  return (a + b - 1) / b;\r\n}\r\n\r\ninline int ReadUint8(const uint8_t* data, size_t* pos) {\r\n  return data[(*pos)++];\r\n}\r\n\r\ninline int ReadUint16(const uint8_t* data, size_t* pos) {\r\n  int v = (data[*pos] << 8) + data[*pos + 1];\r\n  *pos += 2;\r\n  return v;\r\n}\r\n\r\n// Reads the Start of Frame (SOF) marker segment and fills in *jpg with the\r\n// parsed data.\r\nbool ProcessSOF(const uint8_t* data, const size_t len,\r\n                JpegReadMode mode, size_t* pos, JPEGData* jpg) {\r\n  if (jpg->width != 0) {\r\n    fprintf(stderr, \"Duplicate SOF marker.\\n\");\r\n    jpg->error = JPEG_DUPLICATE_SOF;\r\n    return false;\r\n  }\r\n  const size_t start_pos = *pos;\r\n  VERIFY_LEN(8);\r\n  size_t marker_len = ReadUint16(data, pos);\r\n  int precision = ReadUint8(data, pos);\r\n  int height = ReadUint16(data, pos);\r\n  int width = ReadUint16(data, pos);\r\n  int num_components = ReadUint8(data, pos);\r\n  VERIFY_INPUT(precision, 8, 8, PRECISION);\r\n  VERIFY_INPUT(height, 1, 65535, HEIGHT);\r\n  VERIFY_INPUT(width, 1, 65535, WIDTH);\r\n  VERIFY_INPUT(num_components, 1, kMaxComponents, NUMCOMP);\r\n  VERIFY_LEN(3 * num_components);\r\n  jpg->height = height;\r\n  jpg->width = width;\r\n  jpg->components.resize(num_components);\r\n\r\n  // Read sampling factors and quant table index for each component.\r\n  std::vector<bool> ids_seen(256, false);\r\n  for (int i = 0; i < jpg->components.size(); ++i) {\r\n    const int id = ReadUint8(data, pos);\r\n    if (ids_seen[id]) {   // (cf. section B.2.2, syntax of Ci)\r\n      fprintf(stderr, \"Duplicate ID %d in SOF.\\n\", id);\r\n      jpg->error = JPEG_DUPLICATE_COMPONENT_ID;\r\n      return false;\r\n    }\r\n    ids_seen[id] = true;\r\n    jpg->components[i].id = id;\r\n    int factor = ReadUint8(data, pos);\r\n    int h_samp_factor = factor >> 4;\r\n    int v_samp_factor = factor & 0xf;\r\n    VERIFY_INPUT(h_samp_factor, 1, 15, SAMP_FACTOR);\r\n    VERIFY_INPUT(v_samp_factor, 1, 15, SAMP_FACTOR);\r\n    jpg->components[i].h_samp_factor = h_samp_factor;\r\n    jpg->components[i].v_samp_factor = v_samp_factor;\r\n    jpg->components[i].quant_idx = ReadUint8(data, pos);\r\n    jpg->max_h_samp_factor = std::max(jpg->max_h_samp_factor, h_samp_factor);\r\n    jpg->max_v_samp_factor = std::max(jpg->max_v_samp_factor, v_samp_factor);\r\n  }\r\n\r\n  // We have checked above that none of the sampling factors are 0, so the max\r\n  // sampling factors can not be 0.\r\n  jpg->MCU_rows = DivCeil(jpg->height, jpg->max_v_samp_factor * 8);\r\n  jpg->MCU_cols = DivCeil(jpg->width, jpg->max_h_samp_factor * 8);\r\n  // Compute the block dimensions for each component.\r\n  if (mode == JPEG_READ_ALL) {\r\n    for (int i = 0; i < jpg->components.size(); ++i) {\r\n      JPEGComponent* c = &jpg->components[i];\r\n      if (jpg->max_h_samp_factor % c->h_samp_factor != 0 ||\r\n          jpg->max_v_samp_factor % c->v_samp_factor != 0) {\r\n        fprintf(stderr, \"Non-integral subsampling ratios.\\n\");\r\n        jpg->error = JPEG_INVALID_SAMPLING_FACTORS;\r\n        return false;\r\n      }\r\n      c->width_in_blocks = jpg->MCU_cols * c->h_samp_factor;\r\n      c->height_in_blocks = jpg->MCU_rows * c->v_samp_factor;\r\n      const uint64_t num_blocks =\r\n          static_cast<uint64_t>(c->width_in_blocks) * c->height_in_blocks;\r\n      if (num_blocks > (1ull << 21)) {\r\n        // Refuse to allocate more than 1 GB of memory for the coefficients,\r\n        // that is 2M blocks x 64 coeffs x 2 bytes per coeff x max 4 components.\r\n        // TODO(user) Add this limit to a GuetzliParams struct.\r\n        fprintf(stderr, \"Image too large.\\n\");\r\n        jpg->error = JPEG_IMAGE_TOO_LARGE;\r\n        return false;\r\n      }\r\n      c->num_blocks = static_cast<int>(num_blocks);\r\n      c->coeffs.resize(c->num_blocks * kDCTBlockSize);\r\n    }\r\n  }\r\n  VERIFY_MARKER_END();\r\n  return true;\r\n}\r\n\r\n// Reads the Start of Scan (SOS) marker segment and fills in *scan_info with the\r\n// parsed data.\r\nbool ProcessSOS(const uint8_t* data, const size_t len, size_t* pos,\r\n                JPEGData* jpg) {\r\n  const size_t start_pos = *pos;\r\n  VERIFY_LEN(3);\r\n  size_t marker_len = ReadUint16(data, pos);\r\n  int comps_in_scan = ReadUint8(data, pos);\r\n  VERIFY_INPUT(comps_in_scan, 1, jpg->components.size(), COMPS_IN_SCAN);\r\n\r\n  JPEGScanInfo scan_info;\r\n  scan_info.components.resize(comps_in_scan);\r\n  VERIFY_LEN(2 * comps_in_scan);\r\n  std::vector<bool> ids_seen(256, false);\r\n  for (int i = 0; i < comps_in_scan; ++i) {\r\n    int id = ReadUint8(data, pos);\r\n    if (ids_seen[id]) {   // (cf. section B.2.3, regarding CSj)\r\n      fprintf(stderr, \"Duplicate ID %d in SOS.\\n\", id);\r\n      jpg->error = JPEG_DUPLICATE_COMPONENT_ID;\r\n      return false;\r\n    }\r\n    ids_seen[id] = true;\r\n    bool found_index = false;\r\n    for (int j = 0; j < jpg->components.size(); ++j) {\r\n      if (jpg->components[j].id == id) {\r\n        scan_info.components[i].comp_idx = j;\r\n        found_index = true;\r\n      }\r\n    }\r\n    if (!found_index) {\r\n      fprintf(stderr, \"SOS marker: Could not find component with id %d\\n\", id);\r\n      jpg->error = JPEG_COMPONENT_NOT_FOUND;\r\n      return false;\r\n    }\r\n    int c = ReadUint8(data, pos);\r\n    int dc_tbl_idx = c >> 4;\r\n    int ac_tbl_idx = c & 0xf;\r\n    VERIFY_INPUT(dc_tbl_idx, 0, 3, HUFFMAN_INDEX);\r\n    VERIFY_INPUT(ac_tbl_idx, 0, 3, HUFFMAN_INDEX);\r\n    scan_info.components[i].dc_tbl_idx = dc_tbl_idx;\r\n    scan_info.components[i].ac_tbl_idx = ac_tbl_idx;\r\n  }\r\n  VERIFY_LEN(3);\r\n  scan_info.Ss = ReadUint8(data, pos);\r\n  scan_info.Se = ReadUint8(data, pos);\r\n  VERIFY_INPUT(scan_info.Ss, 0, 63, START_OF_SCAN);\r\n  VERIFY_INPUT(scan_info.Se, scan_info.Ss, 63, END_OF_SCAN);\r\n  int c = ReadUint8(data, pos);\r\n  scan_info.Ah = c >> 4;\r\n  scan_info.Al = c & 0xf;\r\n  // Check that all the Huffman tables needed for this scan are defined.\r\n  for (int i = 0; i < comps_in_scan; ++i) {\r\n    bool found_dc_table = false;\r\n    bool found_ac_table = false;\r\n    for (int j = 0; j < jpg->huffman_code.size(); ++j) {\r\n      int slot_id = jpg->huffman_code[j].slot_id;\r\n      if (slot_id == scan_info.components[i].dc_tbl_idx) {\r\n        found_dc_table = true;\r\n      } else if (slot_id == scan_info.components[i].ac_tbl_idx + 16) {\r\n        found_ac_table = true;\r\n      }\r\n    }\r\n    if (scan_info.Ss == 0 && !found_dc_table) {\r\n      fprintf(stderr, \"SOS marker: Could not find DC Huffman table with index \"\r\n              \"%d\\n\", scan_info.components[i].dc_tbl_idx);\r\n      jpg->error = JPEG_HUFFMAN_TABLE_NOT_FOUND;\r\n      return false;\r\n    }\r\n    if (scan_info.Se > 0 && !found_ac_table) {\r\n      fprintf(stderr, \"SOS marker: Could not find AC Huffman table with index \"\r\n              \"%d\\n\", scan_info.components[i].ac_tbl_idx);\r\n      jpg->error = JPEG_HUFFMAN_TABLE_NOT_FOUND;\r\n      return false;\r\n    }\r\n  }\r\n  jpg->scan_info.push_back(scan_info);\r\n  VERIFY_MARKER_END();\r\n  return true;\r\n}\r\n\r\n// Reads the Define Huffman Table (DHT) marker segment and fills in *jpg with\r\n// the parsed data. Builds the Huffman decoding table in either dc_huff_lut or\r\n// ac_huff_lut, depending on the type and solt_id of Huffman code being read.\r\nbool ProcessDHT(const uint8_t* data, const size_t len,\r\n                JpegReadMode mode,\r\n                std::vector<HuffmanTableEntry>* dc_huff_lut,\r\n                std::vector<HuffmanTableEntry>* ac_huff_lut,\r\n                size_t* pos,\r\n                JPEGData* jpg) {\r\n  const size_t start_pos = *pos;\r\n  VERIFY_LEN(2);\r\n  size_t marker_len = ReadUint16(data, pos);\r\n  if (marker_len == 2) {\r\n    fprintf(stderr, \"DHT marker: no Huffman table found\\n\");\r\n    jpg->error = JPEG_EMPTY_DHT;\r\n    return false;\r\n  }\r\n  while (*pos < start_pos + marker_len) {\r\n    VERIFY_LEN(1 + kJpegHuffmanMaxBitLength);\r\n    JPEGHuffmanCode huff;\r\n    huff.slot_id = ReadUint8(data, pos);\r\n    int huffman_index = huff.slot_id;\r\n    int is_ac_table = (huff.slot_id & 0x10) != 0;\r\n    HuffmanTableEntry* huff_lut;\r\n    if (is_ac_table) {\r\n      huffman_index -= 0x10;\r\n      VERIFY_INPUT(huffman_index, 0, 3, HUFFMAN_INDEX);\r\n      huff_lut = &(*ac_huff_lut)[huffman_index * kJpegHuffmanLutSize];\r\n    } else {\r\n      VERIFY_INPUT(huffman_index, 0, 3, HUFFMAN_INDEX);\r\n      huff_lut = &(*dc_huff_lut)[huffman_index * kJpegHuffmanLutSize];\r\n    }\r\n    huff.counts[0] = 0;\r\n    int total_count = 0;\r\n    int space = 1 << kJpegHuffmanMaxBitLength;\r\n    int max_depth = 1;\r\n    for (int i = 1; i <= kJpegHuffmanMaxBitLength; ++i) {\r\n      int count = ReadUint8(data, pos);\r\n      if (count != 0) {\r\n        max_depth = i;\r\n      }\r\n      huff.counts[i] = count;\r\n      total_count += count;\r\n      space -= count * (1 << (kJpegHuffmanMaxBitLength - i));\r\n    }\r\n    if (is_ac_table) {\r\n      VERIFY_INPUT(total_count, 0, kJpegHuffmanAlphabetSize, HUFFMAN_CODE);\r\n    } else {\r\n      VERIFY_INPUT(total_count, 0, kJpegDCAlphabetSize, HUFFMAN_CODE);\r\n    }\r\n    VERIFY_LEN(total_count);\r\n    std::vector<bool> values_seen(256, false);\r\n    for (int i = 0; i < total_count; ++i) {\r\n      uint8_t value = ReadUint8(data, pos);\r\n      if (!is_ac_table) {\r\n        VERIFY_INPUT(value, 0, kJpegDCAlphabetSize - 1, HUFFMAN_CODE);\r\n      }\r\n      if (values_seen[value]) {\r\n        fprintf(stderr, \"Duplicate Huffman code value %d\\n\", value);\r\n        jpg->error = JPEG_INVALID_HUFFMAN_CODE;\r\n        return false;\r\n      }\r\n      values_seen[value] = true;\r\n      huff.values[i] = value;\r\n    }\r\n    // Add an invalid symbol that will have the all 1 code.\r\n    ++huff.counts[max_depth];\r\n    huff.values[total_count] = kJpegHuffmanAlphabetSize;\r\n    space -= (1 << (kJpegHuffmanMaxBitLength - max_depth));\r\n    if (space < 0) {\r\n      fprintf(stderr, \"Invalid Huffman code lengths.\\n\");\r\n      jpg->error = JPEG_INVALID_HUFFMAN_CODE;\r\n      return false;\r\n    } else if (space > 0 && huff_lut[0].value != 0xffff) {\r\n      // Re-initialize the values to an invalid symbol so that we can recognize\r\n      // it when reading the bit stream using a Huffman code with space > 0.\r\n      for (int i = 0; i < kJpegHuffmanLutSize; ++i) {\r\n        huff_lut[i].bits = 0;\r\n        huff_lut[i].value = 0xffff;\r\n      }\r\n    }\r\n    huff.is_last = (*pos == start_pos + marker_len);\r\n    if (mode == JPEG_READ_ALL &&\r\n        !BuildJpegHuffmanTable(&huff.counts[0], &huff.values[0], huff_lut)) {\r\n      fprintf(stderr, \"Failed to build Huffman table.\\n\");\r\n      jpg->error = JPEG_INVALID_HUFFMAN_CODE;\r\n      return false;\r\n    }\r\n    jpg->huffman_code.push_back(huff);\r\n  }\r\n  VERIFY_MARKER_END();\r\n  return true;\r\n}\r\n\r\n// Reads the Define Quantization Table (DQT) marker segment and fills in *jpg\r\n// with the parsed data.\r\nbool ProcessDQT(const uint8_t* data, const size_t len, size_t* pos,\r\n                JPEGData* jpg) {\r\n  const size_t start_pos = *pos;\r\n  VERIFY_LEN(2);\r\n  size_t marker_len = ReadUint16(data, pos);\r\n  if (marker_len == 2) {\r\n    fprintf(stderr, \"DQT marker: no quantization table found\\n\");\r\n    jpg->error = JPEG_EMPTY_DQT;\r\n    return false;\r\n  }\r\n  while (*pos < start_pos + marker_len && jpg->quant.size() < kMaxQuantTables) {\r\n    VERIFY_LEN(1);\r\n    int quant_table_index = ReadUint8(data, pos);\r\n    int quant_table_precision = quant_table_index >> 4;\r\n    quant_table_index &= 0xf;\r\n    VERIFY_INPUT(quant_table_index, 0, 3, QUANT_TBL_INDEX);\r\n    VERIFY_LEN((quant_table_precision ? 2 : 1) * kDCTBlockSize);\r\n    JPEGQuantTable table;\r\n    table.index = quant_table_index;\r\n    table.precision = quant_table_precision;\r\n    for (int i = 0; i < kDCTBlockSize; ++i) {\r\n      int quant_val = quant_table_precision ?\r\n          ReadUint16(data, pos) :\r\n          ReadUint8(data, pos);\r\n      VERIFY_INPUT(quant_val, 1, 65535, QUANT_VAL);\r\n      table.values[kJPEGNaturalOrder[i]] = quant_val;\r\n    }\r\n    table.is_last = (*pos == start_pos + marker_len);\r\n    jpg->quant.push_back(table);\r\n  }\r\n  VERIFY_MARKER_END();\r\n  return true;\r\n}\r\n\r\n// Reads the DRI marker and saved the restart interval into *jpg.\r\nbool ProcessDRI(const uint8_t* data, const size_t len, size_t* pos,\r\n                JPEGData* jpg) {\r\n  if (jpg->restart_interval > 0) {\r\n    fprintf(stderr, \"Duplicate DRI marker.\\n\");\r\n    jpg->error = JPEG_DUPLICATE_DRI;\r\n    return false;\r\n  }\r\n  const size_t start_pos = *pos;\r\n  VERIFY_LEN(4);\r\n  size_t marker_len = ReadUint16(data, pos);\r\n  int restart_interval = ReadUint16(data, pos);\r\n  jpg->restart_interval = restart_interval;\r\n  VERIFY_MARKER_END();\r\n  return true;\r\n}\r\n\r\n// Saves the APP marker segment as a string to *jpg.\r\nbool ProcessAPP(const uint8_t* data, const size_t len, size_t* pos,\r\n                JPEGData* jpg) {\r\n  VERIFY_LEN(2);\r\n  size_t marker_len = ReadUint16(data, pos);\r\n  VERIFY_INPUT(marker_len, 2, 65535, MARKER_LEN);\r\n  VERIFY_LEN(marker_len - 2);\r\n  // Save the marker type together with the app data.\r\n  std::string app_str(reinterpret_cast<const char*>(\r\n      &data[*pos - 3]), marker_len + 1);\r\n  *pos += marker_len - 2;\r\n  jpg->app_data.push_back(app_str);\r\n  return true;\r\n}\r\n\r\n// Saves the COM marker segment as a string to *jpg.\r\nbool ProcessCOM(const uint8_t* data, const size_t len, size_t* pos,\r\n                JPEGData* jpg) {\r\n  VERIFY_LEN(2);\r\n  size_t marker_len = ReadUint16(data, pos);\r\n  VERIFY_INPUT(marker_len, 2, 65535, MARKER_LEN);\r\n  VERIFY_LEN(marker_len - 2);\r\n  std::string com_str(reinterpret_cast<const char*>(\r\n      &data[*pos - 2]), marker_len);\r\n  *pos += marker_len - 2;\r\n  jpg->com_data.push_back(com_str);\r\n  return true;\r\n}\r\n\r\n// Helper structure to read bits from the entropy coded data segment.\r\nstruct BitReaderState {\r\n  BitReaderState(const uint8_t* data, const size_t len, size_t pos)\r\n      : data_(data), len_(len) {\r\n    Reset(pos);\r\n  }\r\n\r\n  void Reset(size_t pos) {\r\n    pos_ = pos;\r\n    val_ = 0;\r\n    bits_left_ = 0;\r\n    next_marker_pos_ = len_ - 2;\r\n    FillBitWindow();\r\n  }\r\n\r\n  // Returns the next byte and skips the 0xff/0x00 escape sequences.\r\n  uint8_t GetNextByte() {\r\n    if (pos_ >= next_marker_pos_) {\r\n      ++pos_;\r\n      return 0;\r\n    }\r\n    uint8_t c = data_[pos_++];\r\n    if (c == 0xff) {\r\n      uint8_t escape = data_[pos_];\r\n      if (escape == 0) {\r\n        ++pos_;\r\n      } else {\r\n        // 0xff was followed by a non-zero byte, which means that we found the\r\n        // start of the next marker segment.\r\n        next_marker_pos_ = pos_ - 1;\r\n      }\r\n    }\r\n    return c;\r\n  }\r\n\r\n  void FillBitWindow() {\r\n    if (bits_left_ <= 16) {\r\n      while (bits_left_ <= 56) {\r\n        val_ <<= 8;\r\n        val_ |= (uint64_t)GetNextByte();\r\n        bits_left_ += 8;\r\n      }\r\n    }\r\n  }\r\n\r\n  int ReadBits(int nbits) {\r\n    FillBitWindow();\r\n    uint64_t val = (val_ >> (bits_left_ - nbits)) & ((1ULL << nbits) - 1);\r\n    bits_left_ -= nbits;\r\n    return val;\r\n  }\r\n\r\n  // Sets *pos to the next stream position where parsing should continue.\r\n  // Returns false if the stream ended too early.\r\n  bool FinishStream(size_t* pos) {\r\n    // Give back some bytes that we did not use.\r\n    int unused_bytes_left = bits_left_ >> 3;\r\n    while (unused_bytes_left-- > 0) {\r\n      --pos_;\r\n      // If we give back a 0 byte, we need to check if it was a 0xff/0x00 escape\r\n      // sequence, and if yes, we need to give back one more byte.\r\n      if (pos_ < next_marker_pos_ &&\r\n          data_[pos_] == 0 && data_[pos_ - 1] == 0xff) {\r\n        --pos_;\r\n      }\r\n    }\r\n    if (pos_ > next_marker_pos_) {\r\n      // Data ran out before the scan was complete.\r\n      fprintf(stderr, \"Unexpected end of scan.\\n\");\r\n      return false;\r\n    }\r\n    *pos = pos_;\r\n    return true;\r\n  }\r\n\r\n  const uint8_t* data_;\r\n  const size_t len_;\r\n  size_t pos_;\r\n  uint64_t val_;\r\n  int bits_left_;\r\n  size_t next_marker_pos_;\r\n};\r\n\r\n// Returns the next Huffman-coded symbol.\r\nint ReadSymbol(const HuffmanTableEntry* table, BitReaderState* br) {\r\n  int nbits;\r\n  br->FillBitWindow();\r\n  int val = (br->val_ >> (br->bits_left_ - 8)) & 0xff;\r\n  table += val;\r\n  nbits = table->bits - 8;\r\n  if (nbits > 0) {\r\n    br->bits_left_ -= 8;\r\n    table += table->value;\r\n    val = (br->val_ >> (br->bits_left_ - nbits)) & ((1 << nbits) - 1);\r\n    table += val;\r\n  }\r\n  br->bits_left_ -= table->bits;\r\n  return table->value;\r\n}\r\n\r\n// Returns the DC diff or AC value for extra bits value x and prefix code s.\r\n// See Tables F.1 and F.2 of the spec.\r\nint HuffExtend(int x, int s) {\r\n  return (x < (1 << (s - 1)) ? x + ((-1) << s ) + 1 : x);\r\n}\r\n\r\n// Decodes one 8x8 block of DCT coefficients from the bit stream.\r\nbool DecodeDCTBlock(const HuffmanTableEntry* dc_huff,\r\n                    const HuffmanTableEntry* ac_huff,\r\n                    int Ss, int Se, int Al,\r\n                    int* eobrun,\r\n                    BitReaderState* br,\r\n                    JPEGData* jpg,\r\n                    coeff_t* last_dc_coeff,\r\n                    coeff_t* coeffs) {\r\n  int s;\r\n  int r;\r\n  bool eobrun_allowed = Ss > 0;\r\n  if (Ss == 0) {\r\n    s = ReadSymbol(dc_huff, br);\r\n    if (s >= kJpegDCAlphabetSize) {\r\n      fprintf(stderr, \"Invalid Huffman symbol %d for DC coefficient.\\n\", s);\r\n      jpg->error = JPEG_INVALID_SYMBOL;\r\n      return false;\r\n    }\r\n    if (s > 0) {\r\n      r = br->ReadBits(s);\r\n      s = HuffExtend(r, s);\r\n    }\r\n    s += *last_dc_coeff;\r\n    const int dc_coeff = s << Al;\r\n    coeffs[0] = dc_coeff;\r\n    if (dc_coeff != coeffs[0]) {\r\n      fprintf(stderr, \"Invalid DC coefficient %d\\n\", dc_coeff);\r\n      jpg->error = JPEG_NON_REPRESENTABLE_DC_COEFF;\r\n      return false;\r\n    }\r\n    *last_dc_coeff = s;\r\n    ++Ss;\r\n  }\r\n  if (Ss > Se) {\r\n    return true;\r\n  }\r\n  if (*eobrun > 0) {\r\n    --(*eobrun);\r\n    return true;\r\n  }\r\n  for (int k = Ss; k <= Se; k++) {\r\n    s = ReadSymbol(ac_huff, br);\r\n    if (s >= kJpegHuffmanAlphabetSize) {\r\n      fprintf(stderr, \"Invalid Huffman symbol %d for AC coefficient %d\\n\",\r\n              s, k);\r\n      jpg->error = JPEG_INVALID_SYMBOL;\r\n      return false;\r\n    }\r\n    r = s >> 4;\r\n    s &= 15;\r\n    if (s > 0) {\r\n      k += r;\r\n      if (k > Se) {\r\n        fprintf(stderr, \"Out-of-band coefficient %d band was %d-%d\\n\",\r\n                k, Ss, Se);\r\n        jpg->error = JPEG_OUT_OF_BAND_COEFF;\r\n        return false;\r\n      }\r\n      if (s + Al >= kJpegDCAlphabetSize) {\r\n        fprintf(stderr, \"Out of range AC coefficient value: s=%d Al=%d k=%d\\n\",\r\n                s, Al, k);\r\n        jpg->error = JPEG_NON_REPRESENTABLE_AC_COEFF;\r\n        return false;\r\n      }\r\n      r = br->ReadBits(s);\r\n      s = HuffExtend(r, s);\r\n      coeffs[kJPEGNaturalOrder[k]] = s << Al;\r\n    } else if (r == 15) {\r\n      k += 15;\r\n    } else {\r\n      *eobrun = 1 << r;\r\n      if (r > 0) {\r\n        if (!eobrun_allowed) {\r\n          fprintf(stderr, \"End-of-block run crossing DC coeff.\\n\");\r\n          jpg->error = JPEG_EOB_RUN_TOO_LONG;\r\n          return false;\r\n        }\r\n        *eobrun += br->ReadBits(r);\r\n      }\r\n      break;\r\n    }\r\n  }\r\n  --(*eobrun);\r\n  return true;\r\n}\r\n\r\nbool RefineDCTBlock(const HuffmanTableEntry* ac_huff,\r\n                    int Ss, int Se, int Al,\r\n                    int* eobrun,\r\n                    BitReaderState* br,\r\n                    JPEGData* jpg,\r\n                    coeff_t* coeffs) {\r\n  bool eobrun_allowed = Ss > 0;\r\n  if (Ss == 0) {\r\n    int s = br->ReadBits(1);\r\n    coeff_t dc_coeff = coeffs[0];\r\n    dc_coeff |= s << Al;\r\n    coeffs[0] = dc_coeff;\r\n    ++Ss;\r\n  }\r\n  if (Ss > Se) {\r\n    return true;\r\n  }\r\n  int p1 = 1 << Al;\r\n  int m1 = (-1) << Al;\r\n  int k = Ss;\r\n  int r;\r\n  int s;\r\n  bool in_zero_run = false;\r\n  if (*eobrun <= 0) {\r\n    for (; k <= Se; k++) {\r\n      s = ReadSymbol(ac_huff, br);\r\n      if (s >= kJpegHuffmanAlphabetSize) {\r\n        fprintf(stderr, \"Invalid Huffman symbol %d for AC coefficient %d\\n\",\r\n                s, k);\r\n        jpg->error = JPEG_INVALID_SYMBOL;\r\n        return false;\r\n      }\r\n      r = s >> 4;\r\n      s &= 15;\r\n      if (s) {\r\n        if (s != 1) {\r\n          fprintf(stderr, \"Invalid Huffman symbol %d for AC coefficient %d\\n\",\r\n                  s, k);\r\n          jpg->error = JPEG_INVALID_SYMBOL;\r\n          return false;\r\n        }\r\n        s = br->ReadBits(1) ? p1 : m1;\r\n        in_zero_run = false;\r\n      } else {\r\n        if (r != 15) {\r\n          *eobrun = 1 << r;\r\n          if (r > 0) {\r\n            if (!eobrun_allowed) {\r\n              fprintf(stderr, \"End-of-block run crossing DC coeff.\\n\");\r\n              jpg->error = JPEG_EOB_RUN_TOO_LONG;\r\n              return false;\r\n            }\r\n            *eobrun += br->ReadBits(r);\r\n          }\r\n          break;\r\n        }\r\n        in_zero_run = true;\r\n      }\r\n      do {\r\n        coeff_t thiscoef = coeffs[kJPEGNaturalOrder[k]];\r\n        if (thiscoef != 0) {\r\n          if (br->ReadBits(1)) {\r\n            if ((thiscoef & p1) == 0) {\r\n              if (thiscoef >= 0) {\r\n                thiscoef += p1;\r\n              } else {\r\n                thiscoef += m1;\r\n              }\r\n            }\r\n          }\r\n          coeffs[kJPEGNaturalOrder[k]] = thiscoef;\r\n        } else {\r\n          if (--r < 0) {\r\n            break;\r\n          }\r\n        }\r\n        k++;\r\n      } while (k <= Se);\r\n      if (s) {\r\n        if (k > Se) {\r\n          fprintf(stderr, \"Out-of-band coefficient %d band was %d-%d\\n\",\r\n                  k, Ss, Se);\r\n          jpg->error = JPEG_OUT_OF_BAND_COEFF;\r\n          return false;\r\n        }\r\n        coeffs[kJPEGNaturalOrder[k]] = s;\r\n      }\r\n    }\r\n  }\r\n  if (in_zero_run) {\r\n    fprintf(stderr, \"Extra zero run before end-of-block.\\n\");\r\n    jpg->error = JPEG_EXTRA_ZERO_RUN;\r\n    return false;\r\n  }\r\n  if (*eobrun > 0) {\r\n    for (; k <= Se; k++) {\r\n      coeff_t thiscoef = coeffs[kJPEGNaturalOrder[k]];\r\n      if (thiscoef != 0) {\r\n        if (br->ReadBits(1)) {\r\n          if ((thiscoef & p1) == 0) {\r\n            if (thiscoef >= 0) {\r\n              thiscoef += p1;\r\n            } else {\r\n              thiscoef += m1;\r\n            }\r\n          }\r\n        }\r\n        coeffs[kJPEGNaturalOrder[k]] = thiscoef;\r\n      }\r\n    }\r\n  }\r\n  --(*eobrun);\r\n  return true;\r\n}\r\n\r\nbool ProcessRestart(const uint8_t* data, const size_t len,\r\n                    int* next_restart_marker, BitReaderState* br,\r\n                    JPEGData* jpg) {\r\n  size_t pos = 0;\r\n  if (!br->FinishStream(&pos)) {\r\n    jpg->error = JPEG_INVALID_SCAN;\r\n    return false;\r\n  }\r\n  int expected_marker = 0xd0 + *next_restart_marker;\r\n  EXPECT_MARKER();\r\n  int marker = data[pos + 1];\r\n  if (marker != expected_marker) {\r\n    fprintf(stderr, \"Did not find expected restart marker %d actual=%d\\n\",\r\n            expected_marker, marker);\r\n    jpg->error = JPEG_WRONG_RESTART_MARKER;\r\n    return false;\r\n  }\r\n  br->Reset(pos + 2);\r\n  *next_restart_marker += 1;\r\n  *next_restart_marker &= 0x7;\r\n  return true;\r\n}\r\n\r\nbool ProcessScan(const uint8_t* data, const size_t len,\r\n                 const std::vector<HuffmanTableEntry>& dc_huff_lut,\r\n                 const std::vector<HuffmanTableEntry>& ac_huff_lut,\r\n                 uint16_t scan_progression[kMaxComponents][kDCTBlockSize],\r\n                 bool is_progressive,\r\n                 size_t* pos,\r\n                 JPEGData* jpg) {\r\n  if (!ProcessSOS(data, len, pos, jpg)) {\r\n    return false;\r\n  }\r\n  JPEGScanInfo* scan_info = &jpg->scan_info.back();\r\n  bool is_interleaved = (scan_info->components.size() > 1);\r\n  int MCUs_per_row;\r\n  int MCU_rows;\r\n  if (is_interleaved) {\r\n    MCUs_per_row = jpg->MCU_cols;\r\n    MCU_rows = jpg->MCU_rows;\r\n  } else {\r\n    const JPEGComponent& c = jpg->components[scan_info->components[0].comp_idx];\r\n    MCUs_per_row =\r\n        DivCeil(jpg->width * c.h_samp_factor, 8 * jpg->max_h_samp_factor);\r\n    MCU_rows =\r\n        DivCeil(jpg->height * c.v_samp_factor, 8 * jpg->max_v_samp_factor);\r\n  }\r\n  coeff_t last_dc_coeff[kMaxComponents] = {0};\r\n  BitReaderState br(data, len, *pos);\r\n  int restarts_to_go = jpg->restart_interval;\r\n  int next_restart_marker = 0;\r\n  int eobrun = -1;\r\n  int block_scan_index = 0;\r\n  const int Al = is_progressive ? scan_info->Al : 0;\r\n  const int Ah = is_progressive ? scan_info->Ah : 0;\r\n  const int Ss = is_progressive ? scan_info->Ss : 0;\r\n  const int Se = is_progressive ? scan_info->Se : 63;\r\n  const uint16_t scan_bitmask = Ah == 0 ? (0xffff << Al) : (1u << Al);\r\n  const uint16_t refinement_bitmask = (1 << Al) - 1;\r\n  for (int i = 0; i < scan_info->components.size(); ++i) {\r\n    int comp_idx = scan_info->components[i].comp_idx;\r\n    for (int k = Ss; k <= Se; ++k) {\r\n      if (scan_progression[comp_idx][k] & scan_bitmask) {\r\n        fprintf(stderr, \"Overlapping scans: component=%d k=%d prev_mask=%d \"\r\n                \"cur_mask=%d\\n\", comp_idx, k, scan_progression[i][k],\r\n                scan_bitmask);\r\n        jpg->error = JPEG_OVERLAPPING_SCANS;\r\n        return false;\r\n      }\r\n      if (scan_progression[comp_idx][k] & refinement_bitmask) {\r\n        fprintf(stderr, \"Invalid scan order, a more refined scan was already \"\r\n                \"done: component=%d k=%d prev_mask=%d cur_mask=%d\\n\", comp_idx,\r\n                k, scan_progression[i][k], scan_bitmask);\r\n        jpg->error = JPEG_INVALID_SCAN_ORDER;\r\n        return false;\r\n      }\r\n      scan_progression[comp_idx][k] |= scan_bitmask;\r\n    }\r\n  }\r\n  if (Al > 10) {\r\n    fprintf(stderr, \"Scan parameter Al=%d is not supported in guetzli.\\n\", Al);\r\n    jpg->error = JPEG_NON_REPRESENTABLE_AC_COEFF;\r\n    return false;\r\n  }\r\n  for (int mcu_y = 0; mcu_y < MCU_rows; ++mcu_y) {\r\n    for (int mcu_x = 0; mcu_x < MCUs_per_row; ++mcu_x) {\r\n      // Handle the restart intervals.\r\n      if (jpg->restart_interval > 0) {\r\n        if (restarts_to_go == 0) {\r\n          if (ProcessRestart(data, len,\r\n                             &next_restart_marker, &br, jpg)) {\r\n            restarts_to_go = jpg->restart_interval;\r\n            memset(last_dc_coeff, 0, sizeof(last_dc_coeff));\r\n            if (eobrun > 0) {\r\n              fprintf(stderr, \"End-of-block run too long.\\n\");\r\n              jpg->error = JPEG_EOB_RUN_TOO_LONG;\r\n              return false;\r\n            }\r\n            eobrun = -1;   // fresh start\r\n          } else {\r\n            return false;\r\n          }\r\n        }\r\n        --restarts_to_go;\r\n      }\r\n      // Decode one MCU.\r\n      for (int i = 0; i < scan_info->components.size(); ++i) {\r\n        JPEGComponentScanInfo* si = &scan_info->components[i];\r\n        JPEGComponent* c = &jpg->components[si->comp_idx];\r\n        const HuffmanTableEntry* dc_lut =\r\n            &dc_huff_lut[si->dc_tbl_idx * kJpegHuffmanLutSize];\r\n        const HuffmanTableEntry* ac_lut =\r\n            &ac_huff_lut[si->ac_tbl_idx * kJpegHuffmanLutSize];\r\n        int nblocks_y = is_interleaved ? c->v_samp_factor : 1;\r\n        int nblocks_x = is_interleaved ? c->h_samp_factor : 1;\r\n        for (int iy = 0; iy < nblocks_y; ++iy) {\r\n          for (int ix = 0; ix < nblocks_x; ++ix) {\r\n            int block_y = mcu_y * nblocks_y + iy;\r\n            int block_x = mcu_x * nblocks_x + ix;\r\n            int block_idx = block_y * c->width_in_blocks + block_x;\r\n            coeff_t* coeffs = &c->coeffs[block_idx * kDCTBlockSize];\r\n            if (Ah == 0) {\r\n              if (!DecodeDCTBlock(dc_lut, ac_lut, Ss, Se, Al, &eobrun, &br, jpg,\r\n                                  &last_dc_coeff[si->comp_idx], coeffs)) {\r\n                return false;\r\n              }\r\n            } else {\r\n              if (!RefineDCTBlock(ac_lut, Ss, Se, Al,\r\n                                  &eobrun, &br, jpg, coeffs)) {\r\n                return false;\r\n              }\r\n            }\r\n            ++block_scan_index;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (eobrun > 0) {\r\n    fprintf(stderr, \"End-of-block run too long.\\n\");\r\n    jpg->error = JPEG_EOB_RUN_TOO_LONG;\r\n    return false;\r\n  }\r\n  if (!br.FinishStream(pos)) {\r\n    jpg->error = JPEG_INVALID_SCAN;\r\n    return false;\r\n  }\r\n  if (*pos > len) {\r\n    fprintf(stderr, \"Unexpected end of file during scan. pos=%d len=%d\\n\",\r\n            static_cast<int>(*pos), static_cast<int>(len));\r\n    jpg->error = JPEG_UNEXPECTED_EOF;\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n// Changes the quant_idx field of the components to refer to the index of the\r\n// quant table in the jpg->quant array.\r\nbool FixupIndexes(JPEGData* jpg) {\r\n  for (int i = 0; i < jpg->components.size(); ++i) {\r\n    JPEGComponent* c = &jpg->components[i];\r\n    bool found_index = false;\r\n    for (int j = 0; j < jpg->quant.size(); ++j) {\r\n      if (jpg->quant[j].index == c->quant_idx) {\r\n        c->quant_idx = j;\r\n        found_index = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!found_index) {\r\n      fprintf(stderr, \"Quantization table with index %d not found\\n\",\r\n              c->quant_idx);\r\n      jpg->error = JPEG_QUANT_TABLE_NOT_FOUND;\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nsize_t FindNextMarker(const uint8_t* data, const size_t len, size_t pos) {\r\n  // kIsValidMarker[i] == 1 means (0xc0 + i) is a valid marker.\r\n  static const uint8_t kIsValidMarker[] = {\r\n    1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\r\n  };\r\n  size_t num_skipped = 0;\r\n  while (pos + 1 < len &&\r\n         (data[pos] != 0xff || data[pos + 1] < 0xc0 ||\r\n          !kIsValidMarker[data[pos + 1] - 0xc0])) {\r\n    ++pos;\r\n    ++num_skipped;\r\n  }\r\n  return num_skipped;\r\n}\r\n\r\n}  // namespace\r\n\r\nbool ReadJpeg(const uint8_t* data, const size_t len, JpegReadMode mode,\r\n              JPEGData* jpg) {\r\n  size_t pos = 0;\r\n  // Check SOI marker.\r\n  EXPECT_MARKER();\r\n  int marker = data[pos + 1];\r\n  pos += 2;\r\n  if (marker != 0xd8) {\r\n    fprintf(stderr, \"Did not find expected SOI marker, actual=%d\\n\", marker);\r\n    jpg->error = JPEG_SOI_NOT_FOUND;\r\n    return false;\r\n  }\r\n  int lut_size = kMaxHuffmanTables * kJpegHuffmanLutSize;\r\n  std::vector<HuffmanTableEntry> dc_huff_lut(lut_size);\r\n  std::vector<HuffmanTableEntry> ac_huff_lut(lut_size);\r\n  bool found_sof = false;\r\n  uint16_t scan_progression[kMaxComponents][kDCTBlockSize] = { { 0 } };\r\n\r\n  bool is_progressive = false;   // default\r\n  do {\r\n    // Read next marker.\r\n    size_t num_skipped = FindNextMarker(data, len, pos);\r\n    if (num_skipped > 0) {\r\n      // Add a fake marker to indicate arbitrary in-between-markers data.\r\n      jpg->marker_order.push_back(0xff);\r\n      jpg->inter_marker_data.push_back(\r\n          std::string(reinterpret_cast<const char*>(&data[pos]),\r\n                                      num_skipped));\r\n      pos += num_skipped;\r\n    }\r\n    EXPECT_MARKER();\r\n    marker = data[pos + 1];\r\n    pos += 2;\r\n    bool ok = true;\r\n    switch (marker) {\r\n      case 0xc0:\r\n      case 0xc1:\r\n      case 0xc2:\r\n        is_progressive = (marker == 0xc2);\r\n        ok = ProcessSOF(data, len, mode, &pos, jpg);\r\n        found_sof = true;\r\n        break;\r\n      case 0xc4:\r\n        ok = ProcessDHT(data, len, mode, &dc_huff_lut, &ac_huff_lut, &pos, jpg);\r\n        break;\r\n      case 0xd0:\r\n      case 0xd1:\r\n      case 0xd2:\r\n      case 0xd3:\r\n      case 0xd4:\r\n      case 0xd5:\r\n      case 0xd6:\r\n      case 0xd7:\r\n        // RST markers do not have any data.\r\n        break;\r\n      case 0xd9:\r\n        // Found end marker.\r\n        break;\r\n      case 0xda:\r\n        if (mode == JPEG_READ_ALL) {\r\n          ok = ProcessScan(data, len, dc_huff_lut, ac_huff_lut,\r\n                           scan_progression, is_progressive, &pos, jpg);\r\n        }\r\n        break;\r\n      case 0xdb:\r\n        ok = ProcessDQT(data, len, &pos, jpg);\r\n        break;\r\n      case 0xdd:\r\n        ok = ProcessDRI(data, len, &pos, jpg);\r\n        break;\r\n      case 0xe0:\r\n      case 0xe1:\r\n      case 0xe2:\r\n      case 0xe3:\r\n      case 0xe4:\r\n      case 0xe5:\r\n      case 0xe6:\r\n      case 0xe7:\r\n      case 0xe8:\r\n      case 0xe9:\r\n      case 0xea:\r\n      case 0xeb:\r\n      case 0xec:\r\n      case 0xed:\r\n      case 0xee:\r\n      case 0xef:\r\n        if (mode != JPEG_READ_TABLES) {\r\n          ok = ProcessAPP(data, len, &pos, jpg);\r\n        }\r\n        break;\r\n      case 0xfe:\r\n        if (mode != JPEG_READ_TABLES) {\r\n          ok = ProcessCOM(data, len, &pos, jpg);\r\n        }\r\n        break;\r\n      default:\r\n        fprintf(stderr, \"Unsupported marker: %d pos=%d len=%d\\n\",\r\n                marker, static_cast<int>(pos), static_cast<int>(len));\r\n        jpg->error = JPEG_UNSUPPORTED_MARKER;\r\n        ok = false;\r\n        break;\r\n    }\r\n    if (!ok) {\r\n      return false;\r\n    }\r\n    jpg->marker_order.push_back(marker);\r\n    if (mode == JPEG_READ_HEADER && found_sof) {\r\n      break;\r\n    }\r\n  } while (marker != 0xd9);\r\n\r\n  if (!found_sof) {\r\n    fprintf(stderr, \"Missing SOF marker.\\n\");\r\n    jpg->error = JPEG_SOF_NOT_FOUND;\r\n    return false;\r\n  }\r\n\r\n  // Supplemental checks.\r\n  if (mode == JPEG_READ_ALL) {\r\n    if (pos < len) {\r\n      jpg->tail_data.assign(reinterpret_cast<const char*>(&data[pos]),\r\n                            len - pos);\r\n    }\r\n    if (!FixupIndexes(jpg)) {\r\n      return false;\r\n    }\r\n    if (jpg->huffman_code.size() == 0) {\r\n      // Section B.2.4.2: \"If a table has never been defined for a particular\r\n      // destination, then when this destination is specified in a scan header,\r\n      // the results are unpredictable.\"\r\n      fprintf(stderr, \"Need at least one Huffman code table.\\n\");\r\n      jpg->error = JPEG_HUFFMAN_TABLE_ERROR;\r\n      return false;\r\n    }\r\n    if (jpg->huffman_code.size() >= kMaxDHTMarkers) {\r\n      fprintf(stderr, \"Too many Huffman tables.\\n\");\r\n      jpg->error = JPEG_HUFFMAN_TABLE_ERROR;\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nbool ReadJpeg(const std::string& data, JpegReadMode mode,\r\n              JPEGData* jpg) {\r\n  return ReadJpeg(reinterpret_cast<const uint8_t*>(data.data()),\r\n                  static_cast<const size_t>(data.size()),\r\n                  mode, jpg);\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Entropy encoding (Huffman) utilities.\r\n\r\n#include \"guetzli/entropy_encode.h\"\r\n\r\n#include <assert.h>\r\n#include <algorithm>\r\n\r\nnamespace guetzli {\r\n\r\nbool SetDepth(int p0, HuffmanTree *pool, uint8_t *depth, int max_depth) {\r\n  int stack[17];\r\n  int level = 0;\r\n  int p = p0;\r\n  assert(max_depth <= 16);\r\n  stack[0] = -1;\r\n  while (true) {\r\n    if (pool[p].index_left_ >= 0) {\r\n      level++;\r\n      if (level > max_depth) return false;\r\n      stack[level] = pool[p].index_right_or_value_;\r\n      p = pool[p].index_left_;\r\n      continue;\r\n    } else {\r\n      depth[pool[p].index_right_or_value_] = static_cast<uint8_t>(level);\r\n    }\r\n    while (level >= 0 && stack[level] == -1) level--;\r\n    if (level < 0) return true;\r\n    p = stack[level];\r\n    stack[level] = -1;\r\n  }\r\n}\r\n\r\n// Sort the root nodes, least popular first.\r\nstatic inline bool SortHuffmanTree(const HuffmanTree& v0,\r\n                                   const HuffmanTree& v1) {\r\n  if (v0.total_count_ != v1.total_count_) {\r\n    return v0.total_count_ < v1.total_count_;\r\n  }\r\n  return v0.index_right_or_value_ > v1.index_right_or_value_;\r\n}\r\n\r\n// This function will create a Huffman tree.\r\n//\r\n// The catch here is that the tree cannot be arbitrarily deep.\r\n// Brotli specifies a maximum depth of 15 bits for \"code trees\"\r\n// and 7 bits for \"code length code trees.\"\r\n//\r\n// count_limit is the value that is to be faked as the minimum value\r\n// and this minimum value is raised until the tree matches the\r\n// maximum length requirement.\r\n//\r\n// This algorithm is not of excellent performance for very long data blocks,\r\n// especially when population counts are longer than 2**tree_limit, but\r\n// we are not planning to use this with extremely long blocks.\r\n//\r\n// See http://en.wikipedia.org/wiki/Huffman_coding\r\nvoid CreateHuffmanTree(const uint32_t *data,\r\n                       const size_t length,\r\n                       const int tree_limit,\r\n                       HuffmanTree* tree,\r\n                       uint8_t *depth) {\r\n  // For block sizes below 64 kB, we never need to do a second iteration\r\n  // of this loop. Probably all of our block sizes will be smaller than\r\n  // that, so this loop is mostly of academic interest. If we actually\r\n  // would need this, we would be better off with the Katajainen algorithm.\r\n  for (uint32_t count_limit = 1; ; count_limit *= 2) {\r\n    size_t n = 0;\r\n    for (size_t i = length; i != 0;) {\r\n      --i;\r\n      if (data[i]) {\r\n        const uint32_t count = std::max<uint32_t>(data[i], count_limit);\r\n        tree[n++] = HuffmanTree(count, -1, static_cast<int16_t>(i));\r\n      }\r\n    }\r\n\r\n    if (n == 1) {\r\n      depth[tree[0].index_right_or_value_] = 1;      // Only one element.\r\n      break;\r\n    }\r\n\r\n    std::sort(tree, tree + n, SortHuffmanTree);\r\n\r\n    // The nodes are:\r\n    // [0, n): the sorted leaf nodes that we start with.\r\n    // [n]: we add a sentinel here.\r\n    // [n + 1, 2n): new parent nodes are added here, starting from\r\n    //              (n+1). These are naturally in ascending order.\r\n    // [2n]: we add a sentinel at the end as well.\r\n    // There will be (2n+1) elements at the end.\r\n    const HuffmanTree sentinel(~static_cast<uint32_t>(0), -1, -1);\r\n    tree[n] = sentinel;\r\n    tree[n + 1] = sentinel;\r\n\r\n    size_t i = 0;      // Points to the next leaf node.\r\n    size_t j = n + 1;  // Points to the next non-leaf node.\r\n    for (size_t k = n - 1; k != 0; --k) {\r\n      size_t left, right;\r\n      if (tree[i].total_count_ <= tree[j].total_count_) {\r\n        left = i;\r\n        ++i;\r\n      } else {\r\n        left = j;\r\n        ++j;\r\n      }\r\n      if (tree[i].total_count_ <= tree[j].total_count_) {\r\n        right = i;\r\n        ++i;\r\n      } else {\r\n        right = j;\r\n        ++j;\r\n      }\r\n\r\n      // The sentinel node becomes the parent node.\r\n      size_t j_end = 2 * n - k;\r\n      tree[j_end].total_count_ =\r\n          tree[left].total_count_ + tree[right].total_count_;\r\n      tree[j_end].index_left_ = static_cast<int16_t>(left);\r\n      tree[j_end].index_right_or_value_ = static_cast<int16_t>(right);\r\n\r\n      // Add back the last sentinel node.\r\n      tree[j_end + 1] = sentinel;\r\n    }\r\n    if (SetDepth(static_cast<int>(2 * n - 1), &tree[0], depth, tree_limit)) {\r\n      /* We need to pack the Huffman tree in tree_limit bits. If this was not\r\n         successful, add fake entities to the lowest values and retry. */\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Entropy encoding (Huffman) utilities.\r\n\r\n#ifndef GUETZLI_ENTROPY_ENCODE_H_\r\n#define GUETZLI_ENTROPY_ENCODE_H_\r\n\r\n#include <stddef.h>\r\n#include <stdint.h>\r\n\r\nnamespace guetzli {\r\n\r\n// A node of a Huffman tree.\r\nstruct HuffmanTree {\r\n  HuffmanTree() {}\r\n  HuffmanTree(uint32_t count, int16_t left, int16_t right)\r\n      : total_count_(count),\r\n        index_left_(left),\r\n        index_right_or_value_(right) {\r\n  }\r\n  uint32_t total_count_;\r\n  int16_t index_left_;\r\n  int16_t index_right_or_value_;\r\n};\r\n\r\nbool SetDepth(int p, HuffmanTree *pool, uint8_t *depth, int max_depth);\r\n\r\n// This function will create a Huffman tree.\r\n//\r\n// The (data,length) contains the population counts.\r\n// The tree_limit is the maximum bit depth of the Huffman codes.\r\n//\r\n// The depth contains the tree, i.e., how many bits are used for\r\n// the symbol.\r\n//\r\n// The actual Huffman tree is constructed in the tree[] array, which has to\r\n// be at least 2 * length + 1 long.\r\n//\r\n// See http://en.wikipedia.org/wiki/Huffman_coding\r\nvoid CreateHuffmanTree(const uint32_t *data,\r\n                       const size_t length,\r\n                       const int tree_limit,\r\n                       HuffmanTree* tree,\r\n                       uint8_t *depth);\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_ENTROPY_ENCODE_H_\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/jpeg_data_writer.h\"\r\n\r\n#include <assert.h>\r\n#include <cstdlib>\r\n#include <string.h>\r\n\r\n#include \"guetzli/entropy_encode.cc\"\r\n#include \"guetzli/fast_log.h\"\r\n#include \"guetzli/jpeg_bit_writer.h\"\r\n\r\nnamespace guetzli {\r\n\r\nnamespace {\r\n\r\nstatic const int kJpegPrecision = 8;\r\n\r\n// Writes len bytes from buf, using the out callback.\r\ninline bool JPEGWrite(JPEGOutput out, const uint8_t* buf, size_t len) {\r\n  static const size_t kBlockSize = 1u << 30;\r\n  size_t pos = 0;\r\n  while (len - pos > kBlockSize) {\r\n    if (!out.Write(buf + pos, kBlockSize)) {\r\n      return false;\r\n    }\r\n    pos += kBlockSize;\r\n  }\r\n  return out.Write(buf + pos, len - pos);\r\n}\r\n\r\n// Writes a string using the out callback.\r\ninline bool JPEGWrite(JPEGOutput out, const std::string& s) {\r\n  const uint8_t* data = reinterpret_cast<const uint8_t*>(&s[0]);\r\n  return JPEGWrite(out, data, s.size());\r\n}\r\n\r\nbool EncodeMetadata(const JPEGData& jpg, bool strip_metadata, JPEGOutput out) {\r\n  if (strip_metadata) {\r\n    const uint8_t kApp0Data[] = {\r\n      0xff, 0xe0, 0x00, 0x10,        // APP0\r\n      0x4a, 0x46, 0x49, 0x46, 0x00,  // 'JFIF'\r\n      0x01, 0x01,                    // v1.01\r\n      0x00, 0x00, 0x01, 0x00, 0x01,  // aspect ratio = 1:1\r\n      0x00, 0x00                     // thumbnail width/height\r\n    };\r\n    return JPEGWrite(out, kApp0Data, sizeof(kApp0Data));\r\n  }\r\n  bool ok = true;\r\n  for (int i = 0; i < jpg.app_data.size(); ++i) {\r\n    uint8_t data[1] = { 0xff };\r\n    ok = ok && JPEGWrite(out, data, sizeof(data));\r\n    ok = ok && JPEGWrite(out, jpg.app_data[i]);\r\n  }\r\n  for (int i = 0; i < jpg.com_data.size(); ++i) {\r\n    uint8_t data[2] = { 0xff, 0xfe };\r\n    ok = ok && JPEGWrite(out, data, sizeof(data));\r\n    ok = ok && JPEGWrite(out, jpg.com_data[i]);\r\n  }\r\n  return ok;\r\n}\r\n\r\nbool EncodeDQT(const std::vector<JPEGQuantTable>& quant, JPEGOutput out) {\r\n  int marker_len = 2;\r\n  for (int i = 0; i < quant.size(); ++i) {\r\n    marker_len += 1 + (quant[i].precision ? 2 : 1) * kDCTBlockSize;\r\n  }\r\n  std::vector<uint8_t> data(marker_len + 2);\r\n  size_t pos = 0;\r\n  data[pos++] = 0xff;\r\n  data[pos++] = 0xdb;\r\n  data[pos++] = marker_len >> 8;\r\n  data[pos++] = marker_len & 0xff;\r\n  for (int i = 0; i < quant.size(); ++i) {\r\n    const JPEGQuantTable& table = quant[i];\r\n    data[pos++] = (table.precision << 4) + table.index;\r\n    for (int k = 0; k < kDCTBlockSize; ++k) {\r\n      int val = table.values[kJPEGNaturalOrder[k]];\r\n      if (table.precision) {\r\n        data[pos++] = val >> 8;\r\n      }\r\n      data[pos++] = val & 0xff;\r\n    }\r\n  }\r\n  return JPEGWrite(out, &data[0], pos);\r\n}\r\n\r\nbool EncodeSOF(const JPEGData& jpg, JPEGOutput out) {\r\n  const size_t ncomps = jpg.components.size();\r\n  const size_t marker_len = 8 + 3 * ncomps;\r\n  std::vector<uint8_t> data(marker_len + 2);\r\n  size_t pos = 0;\r\n  data[pos++] = 0xff;\r\n  data[pos++] = 0xc1;\r\n  data[pos++] = marker_len >> 8;\r\n  data[pos++] = marker_len & 0xff;\r\n  data[pos++] = kJpegPrecision;\r\n  data[pos++] = jpg.height >> 8;\r\n  data[pos++] = jpg.height & 0xff;\r\n  data[pos++] = jpg.width >> 8;\r\n  data[pos++] = jpg.width & 0xff;\r\n  data[pos++] = ncomps;\r\n  for (size_t i = 0; i < ncomps; ++i) {\r\n    data[pos++] = jpg.components[i].id;\r\n    data[pos++] = ((jpg.components[i].h_samp_factor << 4) |\r\n                      (jpg.components[i].v_samp_factor));\r\n    const int quant_idx = jpg.components[i].quant_idx;\r\n    if (quant_idx >= jpg.quant.size()) {\r\n      return false;\r\n    }\r\n    data[pos++] = jpg.quant[quant_idx].index;\r\n  }\r\n  return JPEGWrite(out, &data[0], pos);\r\n}\r\n\r\n// Builds a JPEG-style huffman code from the given bit depths.\r\nvoid BuildHuffmanCode(uint8_t* depth, int* counts, int* values) {\r\n  for (int i = 0; i < JpegHistogram::kSize; ++i) {\r\n    if (depth[i] > 0) {\r\n      ++counts[depth[i]];\r\n    }\r\n  }\r\n  int offset[kJpegHuffmanMaxBitLength + 1] = { 0 };\r\n  for (int i = 1; i <= kJpegHuffmanMaxBitLength; ++i) {\r\n    offset[i] = offset[i - 1] + counts[i - 1];\r\n  }\r\n  for (int i = 0; i < JpegHistogram::kSize; ++i) {\r\n    if (depth[i] > 0) {\r\n      values[offset[depth[i]]++] = i;\r\n    }\r\n  }\r\n}\r\n\r\nvoid BuildHuffmanCodeTable(const int* counts, const int* values,\r\n                           HuffmanCodeTable* table) {\r\n  int huffcode[256];\r\n  int huffsize[256];\r\n  int p = 0;\r\n  for (int l = 1; l <= kJpegHuffmanMaxBitLength; ++l) {\r\n    int i = counts[l];\r\n    while (i--) huffsize[p++] = l;\r\n  }\r\n\r\n  if (p == 0)\r\n    return;\r\n\r\n  huffsize[p - 1] = 0;\r\n  int lastp = p - 1;\r\n\r\n  int code = 0;\r\n  int si = huffsize[0];\r\n  p = 0;\r\n  while (huffsize[p]) {\r\n    while ((huffsize[p]) == si) {\r\n      huffcode[p++] = code;\r\n      code++;\r\n    }\r\n    code <<= 1;\r\n    si++;\r\n  }\r\n  for (p = 0; p < lastp; p++) {\r\n    int i = values[p];\r\n    table->depth[i] = huffsize[p];\r\n    table->code[i] = huffcode[p];\r\n  }\r\n}\r\n\r\n}  // namespace\r\n\r\n// Updates ac_histogram with the counts of the AC symbols that will be added by\r\n// a sequential jpeg encoder for this block. Every symbol is counted twice so\r\n// that we can add a fake symbol at the end with count 1 to be the last (least\r\n// frequent) symbol with the all 1 code.\r\nvoid UpdateACHistogramForDCTBlock(const coeff_t* coeffs,\r\n                                  JpegHistogram* ac_histogram) {\r\n  int r = 0;\r\n  for (int k = 1; k < 64; ++k) {\r\n    coeff_t coeff = coeffs[kJPEGNaturalOrder[k]];\r\n    if (coeff == 0) {\r\n      r++;\r\n      continue;\r\n    }\r\n    while (r > 15) {\r\n      ac_histogram->Add(0xf0);\r\n      r -= 16;\r\n    }\r\n    int nbits = Log2FloorNonZero(std::abs(coeff)) + 1;\r\n    int symbol = (r << 4) + nbits;\r\n    ac_histogram->Add(symbol);\r\n    r = 0;\r\n  }\r\n  if (r > 0) {\r\n    ac_histogram->Add(0);\r\n  }\r\n}\r\n\r\nsize_t HistogramHeaderCost(const JpegHistogram& histo) {\r\n  size_t header_bits = 17 * 8;\r\n  for (int i = 0; i + 1 < JpegHistogram::kSize; ++i) {\r\n    if (histo.counts[i] > 0) {\r\n      header_bits += 8;\r\n    }\r\n  }\r\n  return header_bits;\r\n}\r\n\r\nsize_t HistogramEntropyCost(const JpegHistogram& histo,\r\n                            const uint8_t depths[256]) {\r\n  size_t bits = 0;\r\n  for (int i = 0; i + 1 < JpegHistogram::kSize; ++i) {\r\n    // JpegHistogram::Add() counts every symbol twice, so we have to divide by\r\n    // two here.\r\n    bits += (histo.counts[i] / 2) * (depths[i] + (i & 0xf));\r\n  }\r\n  // Estimate escape byte rate to be 0.75/256.\r\n  bits += (bits * 3 + 512) >> 10;\r\n  return bits;\r\n}\r\n\r\nvoid BuildDCHistograms(const JPEGData& jpg, JpegHistogram* histo) {\r\n  for (int i = 0; i < jpg.components.size(); ++i) {\r\n    const JPEGComponent& c = jpg.components[i];\r\n    JpegHistogram* dc_histogram = &histo[i];\r\n    coeff_t last_dc_coeff = 0;\r\n    for (int mcu_y = 0; mcu_y < jpg.MCU_rows; ++mcu_y) {\r\n      for (int mcu_x = 0; mcu_x < jpg.MCU_cols; ++mcu_x) {\r\n        for (int iy = 0; iy < c.v_samp_factor; ++iy) {\r\n          for (int ix = 0; ix < c.h_samp_factor; ++ix) {\r\n            int block_y = mcu_y * c.v_samp_factor + iy;\r\n            int block_x = mcu_x * c.h_samp_factor + ix;\r\n            int block_idx = block_y * c.width_in_blocks + block_x;\r\n            coeff_t dc_coeff = c.coeffs[block_idx << 6];\r\n            int diff = std::abs(dc_coeff - last_dc_coeff);\r\n            int nbits = Log2Floor(diff) + 1;\r\n            dc_histogram->Add(nbits);\r\n            last_dc_coeff = dc_coeff;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid BuildACHistograms(const JPEGData& jpg, JpegHistogram* histo) {\r\n  for (int i = 0; i < jpg.components.size(); ++i) {\r\n    const JPEGComponent& c = jpg.components[i];\r\n    JpegHistogram* ac_histogram = &histo[i];\r\n    for (int j = 0; j < c.coeffs.size(); j += kDCTBlockSize) {\r\n      UpdateACHistogramForDCTBlock(&c.coeffs[j], ac_histogram);\r\n    }\r\n  }\r\n}\r\n\r\n// Size of everything except the Huffman codes and the entropy coded data.\r\nsize_t JpegHeaderSize(const JPEGData& jpg, bool strip_metadata) {\r\n  size_t num_bytes = 0;\r\n  num_bytes += 2;  // SOI\r\n  if (strip_metadata) {\r\n    num_bytes += 18;  // APP0\r\n  } else {\r\n    for (int i = 0; i < jpg.app_data.size(); ++i) {\r\n      num_bytes += 1 + jpg.app_data[i].size();\r\n    }\r\n    for (int i = 0; i < jpg.com_data.size(); ++i) {\r\n      num_bytes += 2 + jpg.com_data[i].size();\r\n    }\r\n  }\r\n  // DQT\r\n  num_bytes += 4;\r\n  for (int i = 0; i < jpg.quant.size(); ++i) {\r\n    num_bytes += 1 + (jpg.quant[i].precision ? 2 : 1) * kDCTBlockSize;\r\n  }\r\n  num_bytes += 10 + 3 * jpg.components.size();  // SOF\r\n  num_bytes += 4;  // DHT (w/o actual Huffman code data)\r\n  num_bytes += 8 + 2 * jpg.components.size();  // SOS\r\n  num_bytes += 2;  // EOI\r\n  num_bytes += jpg.tail_data.size();\r\n  return num_bytes;\r\n}\r\n\r\nsize_t ClusterHistograms(JpegHistogram* histo, size_t* num,\r\n                         int* histo_indexes, uint8_t* depth) {\r\n  memset(depth, 0, *num * JpegHistogram::kSize);\r\n  size_t costs[kMaxComponents];\r\n  for (size_t i = 0; i < *num; ++i) {\r\n    histo_indexes[i] = i;\r\n    std::vector<HuffmanTree> tree(2 * JpegHistogram::kSize + 1);\r\n    CreateHuffmanTree(histo[i].counts, JpegHistogram::kSize,\r\n                      kJpegHuffmanMaxBitLength, &tree[0],\r\n                      &depth[i * JpegHistogram::kSize]);\r\n    costs[i] = (HistogramHeaderCost(histo[i]) +\r\n                HistogramEntropyCost(histo[i],\r\n                                     &depth[i * JpegHistogram::kSize]));\r\n  }\r\n  const size_t orig_num = *num;\r\n  while (*num > 1) {\r\n    size_t last = *num - 1;\r\n    size_t second_last = *num - 2;\r\n    JpegHistogram combined(histo[last]);\r\n    combined.AddHistogram(histo[second_last]);\r\n    std::vector<HuffmanTree> tree(2 * JpegHistogram::kSize + 1);\r\n    uint8_t depth_combined[JpegHistogram::kSize] = { 0 };\r\n    CreateHuffmanTree(combined.counts, JpegHistogram::kSize,\r\n                      kJpegHuffmanMaxBitLength, &tree[0], depth_combined);\r\n    size_t cost_combined = (HistogramHeaderCost(combined) +\r\n                            HistogramEntropyCost(combined, depth_combined));\r\n    if (cost_combined < costs[last] + costs[second_last]) {\r\n      histo[second_last] = combined;\r\n      histo[last] = JpegHistogram();\r\n      costs[second_last] = cost_combined;\r\n      memcpy(&depth[second_last * JpegHistogram::kSize], depth_combined,\r\n             sizeof(depth_combined));\r\n      for (size_t i = 0; i < orig_num; ++i) {\r\n        if (histo_indexes[i] == last) {\r\n          histo_indexes[i] = second_last;\r\n        }\r\n      }\r\n      --(*num);\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n  size_t total_cost = 0;\r\n  for (int i = 0; i < *num; ++i) {\r\n    total_cost += costs[i];\r\n  }\r\n  return (total_cost + 7) / 8;\r\n}\r\n\r\nsize_t EstimateJpegDataSize(const int num_components,\r\n                            const std::vector<JpegHistogram>& histograms) {\r\n  assert(histograms.size() == 2 * num_components);\r\n  std::vector<JpegHistogram> clustered = histograms;\r\n  size_t num_dc = num_components;\r\n  size_t num_ac = num_components;\r\n  int indexes[kMaxComponents];\r\n  uint8_t depth[kMaxComponents * JpegHistogram::kSize];\r\n  return (ClusterHistograms(&clustered[0], &num_dc, indexes, depth) +\r\n          ClusterHistograms(&clustered[num_components], &num_ac, indexes,\r\n                            depth));\r\n}\r\n\r\nnamespace {\r\n\r\n// Writes DHT and SOS marker segments to out and fills in DC/AC Huffman tables\r\n// for each component of the image.\r\nbool BuildAndEncodeHuffmanCodes(const JPEGData& jpg, JPEGOutput out,\r\n                                std::vector<HuffmanCodeTable>* dc_huff_tables,\r\n                                std::vector<HuffmanCodeTable>* ac_huff_tables) {\r\n  const int ncomps = jpg.components.size();\r\n  dc_huff_tables->resize(ncomps);\r\n  ac_huff_tables->resize(ncomps);\r\n\r\n  // Build separate DC histograms for each component.\r\n  std::vector<JpegHistogram> histograms(ncomps);\r\n  BuildDCHistograms(jpg, &histograms[0]);\r\n\r\n  // Cluster DC histograms.\r\n  size_t num_dc_histo = ncomps;\r\n  int dc_histo_indexes[kMaxComponents];\r\n  std::vector<uint8_t> depths(ncomps * JpegHistogram::kSize);\r\n  ClusterHistograms(&histograms[0], &num_dc_histo, dc_histo_indexes,\r\n                    &depths[0]);\r\n\r\n  // Build separate AC histograms for each component.\r\n  histograms.resize(num_dc_histo + ncomps);\r\n  depths.resize((num_dc_histo + ncomps) * JpegHistogram::kSize);\r\n  BuildACHistograms(jpg, &histograms[num_dc_histo]);\r\n\r\n  // Cluster AC histograms.\r\n  size_t num_ac_histo = ncomps;\r\n  int ac_histo_indexes[kMaxComponents];\r\n  ClusterHistograms(&histograms[num_dc_histo], &num_ac_histo, ac_histo_indexes,\r\n                    &depths[num_dc_histo * JpegHistogram::kSize]);\r\n\r\n  // Compute DHT and SOS marker data sizes and start emitting DHT marker.\r\n  int num_histo = num_dc_histo + num_ac_histo;\r\n  histograms.resize(num_histo);\r\n  int total_count = 0;\r\n  for (int i = 0; i < histograms.size(); ++i) {\r\n    total_count += histograms[i].NumSymbols();\r\n  }\r\n  const size_t dht_marker_len =\r\n      2 + num_histo * (kJpegHuffmanMaxBitLength + 1) + total_count;\r\n  const size_t sos_marker_len = 6 + 2 * ncomps;\r\n  std::vector<uint8_t> data(dht_marker_len + sos_marker_len + 4);\r\n  size_t pos = 0;\r\n  data[pos++] = 0xff;\r\n  data[pos++] = 0xc4;\r\n  data[pos++] = dht_marker_len >> 8;\r\n  data[pos++] = dht_marker_len & 0xff;\r\n\r\n  // Compute Huffman codes for each histograms.\r\n  for (size_t i = 0; i < num_histo; ++i) {\r\n    const bool is_dc = i < num_dc_histo;\r\n    const int idx = is_dc ? i : i - num_dc_histo;\r\n    int counts[kJpegHuffmanMaxBitLength + 1] = { 0 };\r\n    int values[JpegHistogram::kSize] = { 0 };\r\n    BuildHuffmanCode(&depths[i * JpegHistogram::kSize], counts, values);\r\n    HuffmanCodeTable table;\r\n    for (int j = 0; j < 256; ++j) table.depth[j] = 255;\r\n    BuildHuffmanCodeTable(counts, values, &table);\r\n    for (int c = 0; c < ncomps; ++c) {\r\n      if (is_dc) {\r\n        if (dc_histo_indexes[c] == idx) (*dc_huff_tables)[c] = table;\r\n      } else {\r\n        if (ac_histo_indexes[c] == idx) (*ac_huff_tables)[c] = table;\r\n      }\r\n    }\r\n    int max_length = kJpegHuffmanMaxBitLength;\r\n    while (max_length > 0 && counts[max_length] == 0) --max_length;\r\n    --counts[max_length];\r\n    int total_count = 0;\r\n    for (int j = 0; j <= max_length; ++j) total_count += counts[j];\r\n    data[pos++] = is_dc ? i : i - num_dc_histo + 0x10;\r\n    for (size_t j = 1; j <= kJpegHuffmanMaxBitLength; ++j) {\r\n      data[pos++] = counts[j];\r\n    }\r\n    for (size_t j = 0; j < total_count; ++j) {\r\n      data[pos++] = values[j];\r\n    }\r\n  }\r\n\r\n  // Emit SOS marker data.\r\n  data[pos++] = 0xff;\r\n  data[pos++] = 0xda;\r\n  data[pos++] = sos_marker_len >> 8;\r\n  data[pos++] = sos_marker_len & 0xff;\r\n  data[pos++] = ncomps;\r\n  for (int i = 0; i < ncomps; ++i) {\r\n    data[pos++] = jpg.components[i].id;\r\n    data[pos++] = (dc_histo_indexes[i] << 4) | ac_histo_indexes[i];\r\n  }\r\n  data[pos++] = 0;\r\n  data[pos++] = 63;\r\n  data[pos++] = 0;\r\n  assert(pos == data.size());\r\n  return JPEGWrite(out, &data[0], data.size());\r\n}\r\n\r\nvoid EncodeDCTBlockSequential(const coeff_t* coeffs,\r\n                              const HuffmanCodeTable& dc_huff,\r\n                              const HuffmanCodeTable& ac_huff,\r\n                              coeff_t* last_dc_coeff,\r\n                              BitWriter* bw) {\r\n  coeff_t temp2;\r\n  coeff_t temp;\r\n  temp2 = coeffs[0];\r\n  temp = temp2 - *last_dc_coeff;\r\n  *last_dc_coeff = temp2;\r\n  temp2 = temp;\r\n  if (temp < 0) {\r\n    temp = -temp;\r\n    temp2--;\r\n  }\r\n  int nbits = Log2Floor(temp) + 1;\r\n  bw->WriteBits(dc_huff.depth[nbits], dc_huff.code[nbits]);\r\n  if (nbits > 0) {\r\n    bw->WriteBits(nbits, temp2 & ((1 << nbits) - 1));\r\n  }\r\n  int r = 0;\r\n  for (int k = 1; k < 64; ++k) {\r\n    if ((temp = coeffs[kJPEGNaturalOrder[k]]) == 0) {\r\n      r++;\r\n      continue;\r\n    }\r\n    if (temp < 0) {\r\n      temp = -temp;\r\n      temp2 = ~temp;\r\n    } else {\r\n      temp2 = temp;\r\n    }\r\n    while (r > 15) {\r\n      bw->WriteBits(ac_huff.depth[0xf0], ac_huff.code[0xf0]);\r\n      r -= 16;\r\n    }\r\n    int nbits = Log2FloorNonZero(temp) + 1;\r\n    int symbol = (r << 4) + nbits;\r\n    bw->WriteBits(ac_huff.depth[symbol], ac_huff.code[symbol]);\r\n    bw->WriteBits(nbits, temp2 & ((1 << nbits) - 1));\r\n    r = 0;\r\n  }\r\n  if (r > 0) {\r\n    bw->WriteBits(ac_huff.depth[0], ac_huff.code[0]);\r\n  }\r\n}\r\n\r\nbool EncodeScan(const JPEGData& jpg,\r\n                const std::vector<HuffmanCodeTable>& dc_huff_table,\r\n                const std::vector<HuffmanCodeTable>& ac_huff_table,\r\n                JPEGOutput out) {\r\n  coeff_t last_dc_coeff[kMaxComponents] = { 0 };\r\n  BitWriter bw(1 << 17);\r\n  for (int mcu_y = 0; mcu_y < jpg.MCU_rows; ++mcu_y) {\r\n    for (int mcu_x = 0; mcu_x < jpg.MCU_cols; ++mcu_x) {\r\n      // Encode one MCU\r\n      for (int i = 0; i < jpg.components.size(); ++i) {\r\n        const JPEGComponent& c = jpg.components[i];\r\n        int nblocks_y = c.v_samp_factor;\r\n        int nblocks_x = c.h_samp_factor;\r\n        for (int iy = 0; iy < nblocks_y; ++iy) {\r\n          for (int ix = 0; ix < nblocks_x; ++ix) {\r\n            int block_y = mcu_y * nblocks_y + iy;\r\n            int block_x = mcu_x * nblocks_x + ix;\r\n            int block_idx = block_y * c.width_in_blocks + block_x;\r\n            const coeff_t* coeffs = &c.coeffs[block_idx << 6];\r\n            EncodeDCTBlockSequential(coeffs, dc_huff_table[i], ac_huff_table[i],\r\n                                     &last_dc_coeff[i], &bw);\r\n          }\r\n        }\r\n      }\r\n      if (bw.pos > (1 << 16)) {\r\n        if (!JPEGWrite(out, bw.data.get(), bw.pos)) {\r\n          return false;\r\n        }\r\n        bw.pos = 0;\r\n      }\r\n    }\r\n  }\r\n  bw.JumpToByteBoundary();\r\n  return !bw.overflow && JPEGWrite(out, bw.data.get(), bw.pos);\r\n}\r\n\r\n}  // namespace\r\n\r\nbool WriteJpeg(const JPEGData& jpg, bool strip_metadata, JPEGOutput out) {\r\n  static const uint8_t kSOIMarker[2] = { 0xff, 0xd8 };\r\n  static const uint8_t kEOIMarker[2] = { 0xff, 0xd9 };\r\n  std::vector<HuffmanCodeTable> dc_codes;\r\n  std::vector<HuffmanCodeTable> ac_codes;\r\n  return (JPEGWrite(out, kSOIMarker, sizeof(kSOIMarker)) &&\r\n          EncodeMetadata(jpg, strip_metadata, out) &&\r\n          EncodeDQT(jpg.quant, out) &&\r\n          EncodeSOF(jpg, out) &&\r\n          BuildAndEncodeHuffmanCodes(jpg, out, &dc_codes, &ac_codes) &&\r\n          EncodeScan(jpg, dc_codes, ac_codes, out) &&\r\n          JPEGWrite(out, kEOIMarker, sizeof(kEOIMarker)) &&\r\n          (strip_metadata || JPEGWrite(out, jpg.tail_data)));\r\n}\r\n\r\nint NullOut(void* data, const uint8_t* buf, size_t count) {\r\n  return count;\r\n}\r\n\r\nvoid BuildSequentialHuffmanCodes(\r\n    const JPEGData& jpg,\r\n    std::vector<HuffmanCodeTable>* dc_huffman_code_tables,\r\n    std::vector<HuffmanCodeTable>* ac_huffman_code_tables) {\r\n  JPEGOutput out(NullOut, nullptr);\r\n  BuildAndEncodeHuffmanCodes(jpg, out, dc_huffman_code_tables,\r\n                             ac_huffman_code_tables);\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Functions for writing a JPEGData object into a jpeg byte stream.\r\n\r\n#ifndef GUETZLI_JPEG_DATA_WRITER_H_\r\n#define GUETZLI_JPEG_DATA_WRITER_H_\r\n\r\n#include <stdint.h>\r\n#include <string.h>\r\n#include <vector>\r\n\r\n#include \"guetzli/jpeg_data.h\"\r\n\r\nnamespace guetzli {\r\n\r\n// Function pointer type used to write len bytes into buf. Returns the\r\n// number of bytes written or -1 on error.\r\ntypedef int (*JPEGOutputHook)(void* data, const uint8_t* buf, size_t len);\r\n\r\n// Output callback function with associated data.\r\nstruct JPEGOutput {\r\n  JPEGOutput(JPEGOutputHook cb, void* data) : cb(cb), data(data) {}\r\n  bool Write(const uint8_t* buf, size_t len) const {\r\n    return (len == 0) || (cb(data, buf, len) == len);\r\n  }\r\n private:\r\n  JPEGOutputHook cb;\r\n  void* data;\r\n};\r\n\r\nbool WriteJpeg(const JPEGData& jpg, bool strip_metadata, JPEGOutput out);\r\n\r\nstruct HuffmanCodeTable {\r\n  uint8_t depth[256];\r\n  int code[256];\r\n};\r\n\r\nvoid BuildSequentialHuffmanCodes(\r\n    const JPEGData& jpg, std::vector<HuffmanCodeTable>* dc_huffman_code_tables,\r\n    std::vector<HuffmanCodeTable>* ac_huffman_code_tables);\r\n\r\nstruct JpegHistogram {\r\n  static const int kSize = kJpegHuffmanAlphabetSize + 1;\r\n\r\n  JpegHistogram() { Clear(); }\r\n  void Clear() {\r\n    memset(counts, 0, sizeof(counts));\r\n    counts[kSize - 1] = 1;\r\n  }\r\n  void Add(int symbol) {\r\n    counts[symbol] += 2;\r\n  }\r\n  void Add(int symbol, int weight) {\r\n    counts[symbol] += 2 * weight;\r\n  }\r\n  void AddHistogram(const JpegHistogram& other) {\r\n    for (int i = 0; i + 1 < kSize; ++i) {\r\n      counts[i] += other.counts[i];\r\n    }\r\n    counts[kSize - 1] = 1;\r\n  }\r\n  int NumSymbols() const {\r\n    int n = 0;\r\n    for (int i = 0; i + 1 < kSize; ++i) {\r\n      n += (counts[i] > 0 ? 1 : 0);\r\n    }\r\n    return n;\r\n  }\r\n\r\n  uint32_t counts[kSize];\r\n};\r\n\r\nvoid BuildDCHistograms(const JPEGData& jpg, JpegHistogram* histo);\r\nvoid BuildACHistograms(const JPEGData& jpg, JpegHistogram* histo);\r\nsize_t JpegHeaderSize(const JPEGData& jpg, bool strip_metadata);\r\nsize_t EstimateJpegDataSize(const int num_components,\r\n                            const std::vector<JpegHistogram>& histograms);\r\n\r\nsize_t HistogramEntropyCost(const JpegHistogram& histo,\r\n                            const uint8_t depths[256]);\r\nsize_t HistogramHeaderCost(const JpegHistogram& histo);\r\n\r\nvoid UpdateACHistogramForDCTBlock(const coeff_t* coeffs,\r\n                                  JpegHistogram* ac_histogram);\r\n\r\nsize_t ClusterHistograms(JpegHistogram* histo, size_t* num, int* histo_indexes,\r\n                         uint8_t* depths);\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_JPEG_DATA_WRITER_H_\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#ifndef GUETZLI_FAST_LOG_H_\r\n#define GUETZLI_FAST_LOG_H_\r\n\r\n#include <math.h>\r\n\r\nnamespace guetzli {\r\n\r\ninline int Log2FloorNonZero(uint32_t n) {\r\n#ifdef __GNUC__\r\n  return 31 ^ __builtin_clz(n);\r\n#else\r\n  unsigned int result = 0;\r\n  while (n >>= 1) result++;\r\n  return result;\r\n#endif\r\n}\r\n\r\ninline int Log2Floor(uint32_t n) {\r\n  return n == 0 ? -1 : Log2FloorNonZero(n);\r\n}\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_FAST_LOG_H_\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/processor.h\"\r\n\r\n#include <algorithm>\r\n#include <set>\r\n#include <string.h>\r\n#include <vector>\r\n\r\n#include \"guetzli/output_image.cc\"\r\n#include \"guetzli/butteraugli_comparator.cc\"\r\n#include \"guetzli/comparator.h\"\r\n#include \"guetzli/debug_print.cc\"\r\n#include \"guetzli/fast_log.h\"\r\n#include \"guetzli/jpeg_data_decoder.cc\"\r\n#include \"guetzli/jpeg_data_encoder.cc\"\r\n#include \"guetzli/jpeg_data_reader.cc\"\r\n#include \"guetzli/jpeg_data_writer.cc\"\r\n//#include \"guetzli/quantize.cc\"\r\n\r\nnamespace guetzli {\r\n\r\nnamespace {\r\n\r\nstatic const size_t kBlockSize = 3 * kDCTBlockSize;\r\n\r\nstruct CoeffData {\r\n  int idx;\r\n  float block_err;\r\n};\r\nstruct QuantData {\r\n  int q[3][kDCTBlockSize];\r\n  bool dist_ok;\r\n  GuetzliOutput out;\r\n};\r\nclass Processor {\r\n public:\r\n  bool ProcessJpegData(const Params& params, const JPEGData& jpg_in,\r\n                       Comparator* comparator, GuetzliOutput* out,\r\n                       ProcessStats* stats);\r\n\r\n private:\r\n  void SelectFrequencyMasking(const JPEGData& jpg, OutputImage* img,\r\n                              const uint8_t comp_mask, const double target_mul,\r\n                              bool stop_early);\r\n  void ComputeBlockZeroingOrder(\r\n      const coeff_t block[kBlockSize], const coeff_t orig_block[kBlockSize],\r\n      const int block_x, const int block_y, const int factor_x,\r\n      const int factor_y, const uint8_t comp_mask, OutputImage* img,\r\n      std::vector<CoeffData>* output_order);\r\n  bool SelectQuantMatrix(const JPEGData& jpg_in, const bool downsample,\r\n                         int best_q[3][kDCTBlockSize],\r\n                         GuetzliOutput* quantized_out);\r\n  QuantData TryQuantMatrix(const JPEGData& jpg_in,\r\n                           const float target_mul,\r\n                           int q[3][kDCTBlockSize]);\r\n  void MaybeOutput(const std::string& encoded_jpg);\r\n  void DownsampleImage(OutputImage* img);\r\n  void OutputJpeg(const JPEGData& in, std::string* out);\r\n\r\n  Params params_;\r\n  Comparator* comparator_;\r\n  GuetzliOutput* final_output_;\r\n  ProcessStats* stats_;\r\n};\r\n\r\nvoid RemoveOriginalQuantization(JPEGData* jpg, int q_in[3][kDCTBlockSize]) {\r\n  for (int i = 0; i < 3; ++i) {\r\n    JPEGComponent& c = jpg->components[i];\r\n    const int* q = &jpg->quant[c.quant_idx].values[0];\r\n    memcpy(&q_in[i][0], q, kDCTBlockSize * sizeof(q[0]));\r\n    for (int j = 0; j < c.coeffs.size(); ++j) {\r\n      c.coeffs[j] *= q[j % kDCTBlockSize];\r\n    }\r\n  }\r\n  int q[3][kDCTBlockSize];\r\n  for (int i = 0; i < 3; ++i)\r\n    for (int j = 0; j < kDCTBlockSize; ++j) q[i][j] = 1;\r\n  SaveQuantTables(q, jpg);\r\n}\r\n\r\nvoid Processor::DownsampleImage(OutputImage* img) {\r\n  if (img->component(1).factor_x() > 1 || img->component(1).factor_y() > 1) {\r\n    return;\r\n  }\r\n  OutputImage::DownsampleConfig cfg;\r\n  cfg.use_silver_screen = params_.use_silver_screen;\r\n  img->Downsample(cfg);\r\n}\r\n\r\n}  // namespace\r\n\r\nint GuetzliStringOut(void* data, const uint8_t* buf, size_t count) {\r\n  std::string* sink =\r\n      reinterpret_cast<std::string*>(data);\r\n  sink->append(reinterpret_cast<const char*>(buf), count);\r\n  return count;\r\n}\r\n\r\nvoid Processor::OutputJpeg(const JPEGData& jpg,\r\n                           std::string* out) {\r\n  out->clear();\r\n  JPEGOutput output(GuetzliStringOut, out);\r\n  if (!WriteJpeg(jpg, params_.clear_metadata, output)) {\r\n    assert(0);\r\n  }\r\n}\r\n\r\nvoid Processor::MaybeOutput(const std::string& encoded_jpg) {\r\n  double score = comparator_->ScoreOutputSize(encoded_jpg.size());\r\n  GUETZLI_LOG(stats_, \" Score[%.4f]\", score);\r\n  if (score < final_output_->score || final_output_->score < 0) {\r\n    final_output_->jpeg_data = encoded_jpg;\r\n    final_output_->distmap = comparator_->distmap();\r\n    final_output_->distmap_aggregate = comparator_->distmap_aggregate();\r\n    final_output_->score = score;\r\n    GUETZLI_LOG(stats_, \" (*)\");\r\n  }\r\n  GUETZLI_LOG(stats_, \"\\n\");\r\n}\r\n\r\nbool CompareQuantData(const QuantData& a, const QuantData& b) {\r\n  if (a.dist_ok && !b.dist_ok) return true;\r\n  if (!a.dist_ok && b.dist_ok) return false;\r\n  return a.out.jpeg_data.size() < b.out.jpeg_data.size();\r\n}\r\n\r\n// Compares a[0..kBlockSize) and b[0..kBlockSize) vectors, and returns\r\n//   0 : if they are equal\r\n//  -1 : if a is everywhere <= than b and in at least one coordinate <\r\n//   1 : if a is everywhere >= than b and in at least one coordinate >\r\n//   2 : if a and b are uncomparable (some coordinate smaller and some greater)\r\nint CompareQuantMatrices(const int* a, const int* b) {\r\n  int i = 0;\r\n  while (i < kBlockSize && a[i] == b[i]) ++i;\r\n  if (i == kBlockSize) {\r\n    return 0;\r\n  }\r\n  if (a[i] < b[i]) {\r\n    for (++i; i < kBlockSize; ++i) {\r\n      if (a[i] > b[i]) return 2;\r\n    }\r\n    return -1;\r\n  } else {\r\n    for (++i; i < kBlockSize; ++i) {\r\n      if (a[i] < b[i]) return 2;\r\n    }\r\n    return 1;\r\n  }\r\n}\r\n\r\ndouble ContrastSensitivity(int k) {\r\n  return 1.0 / (1.0 + kJPEGZigZagOrder[k] / 2.0);\r\n}\r\n\r\ndouble QuantMatrixHeuristicScore(const int q[3][kDCTBlockSize]) {\r\n  double score = 0.0;\r\n  for (int c = 0; c < 3; ++c) {\r\n    for (int k = 0; k < kDCTBlockSize; ++k) {\r\n      score += 0.5 * (q[c][k] - 1.0) * ContrastSensitivity(k);\r\n    }\r\n  }\r\n  return score;\r\n}\r\n\r\nclass QuantMatrixGenerator {\r\n public:\r\n  QuantMatrixGenerator(bool downsample, ProcessStats* stats)\r\n      : downsample_(downsample), hscore_a_(-1.0), hscore_b_(-1.0),\r\n        total_csf_(0.0), stats_(stats) {\r\n    for (int k = 0; k < kDCTBlockSize; ++k) {\r\n      total_csf_ += 3.0 * ContrastSensitivity(k);\r\n    }\r\n  }\r\n\r\n  bool GetNext(int q[3][kDCTBlockSize]) {\r\n    // This loop should terminate by return. This 1000 iteration limit is just a\r\n    // precaution.\r\n    for (int iter = 0; iter < 1000; iter++) {\r\n      double hscore;\r\n      if (hscore_b_ == -1.0) {\r\n        if (hscore_a_ == -1.0) {\r\n          hscore = downsample_ ? 0.0 : total_csf_;\r\n        } else {\r\n          if (hscore_a_ < 5.0 * total_csf_) {\r\n            hscore = hscore_a_ + total_csf_;\r\n          } else {\r\n            hscore = 2 * (hscore_a_ + total_csf_);\r\n          }\r\n        }\r\n        if (hscore > 100 * total_csf_) {\r\n          // We could not find a quantization matrix that creates enough\r\n          // butteraugli error. This can happen if all dct coefficients are\r\n          // close to zero in the original image.\r\n          return false;\r\n        }\r\n      } else if (hscore_b_ == 0.0) {\r\n        return false;\r\n      } else if (hscore_a_ == -1.0) {\r\n        hscore = 0.0;\r\n      } else {\r\n        int lower_q[3][kDCTBlockSize];\r\n        int upper_q[3][kDCTBlockSize];\r\n        constexpr double kEps = 0.05;\r\n        GetQuantMatrixWithHeuristicScore(\r\n            (1 - kEps) * hscore_a_ + kEps * 0.5 * (hscore_a_ + hscore_b_),\r\n            lower_q);\r\n        GetQuantMatrixWithHeuristicScore(\r\n            (1 - kEps) * hscore_b_ + kEps * 0.5 * (hscore_a_ + hscore_b_),\r\n            upper_q);\r\n        if (CompareQuantMatrices(&lower_q[0][0], &upper_q[0][0]) == 0)\r\n          return false;\r\n        hscore = (hscore_a_ + hscore_b_) * 0.5;\r\n      }\r\n      GetQuantMatrixWithHeuristicScore(hscore, q);\r\n      bool retry = false;\r\n      for (int i = 0; i < quants_.size(); ++i) {\r\n        if (CompareQuantMatrices(&q[0][0], &quants_[i].q[0][0]) == 0) {\r\n          if (quants_[i].dist_ok) {\r\n            hscore_a_ = hscore;\r\n          } else {\r\n            hscore_b_ = hscore;\r\n          }\r\n          retry = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!retry) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  void Add(const QuantData& data) {\r\n    quants_.push_back(data);\r\n    double hscore = QuantMatrixHeuristicScore(data.q);\r\n    if (data.dist_ok) {\r\n      hscore_a_ = std::max(hscore_a_, hscore);\r\n    } else {\r\n      hscore_b_ = hscore_b_ == -1.0 ? hscore : std::min(hscore_b_, hscore);\r\n    }\r\n  }\r\n\r\n private:\r\n  void GetQuantMatrixWithHeuristicScore(double score,\r\n                                        int q[3][kDCTBlockSize]) const {\r\n    int level = static_cast<int>(score / total_csf_);\r\n    score -= level * total_csf_;\r\n    for (int k = kDCTBlockSize - 1; k >= 0; --k) {\r\n      for (int c = 0; c < 3; ++c) {\r\n        q[c][kJPEGNaturalOrder[k]] = 2 * level + (score > 0.0 ? 3 : 1);\r\n      }\r\n      score -= 3.0 * ContrastSensitivity(kJPEGNaturalOrder[k]);\r\n    }\r\n  }\r\n\r\n  const bool downsample_;\r\n  // Lower bound for quant matrix heuristic score used in binary search.\r\n  double hscore_a_;\r\n  // Upper bound for quant matrix heuristic score used in binary search, or 0.0\r\n  // if no upper bound is found yet.\r\n  double hscore_b_;\r\n  // Cached value of the sum of all ContrastSensitivity() values over all\r\n  // quant matrix elements.\r\n  double total_csf_;\r\n  std::vector<QuantData> quants_;\r\n\r\n  ProcessStats* stats_;\r\n};\r\n\r\nQuantData Processor::TryQuantMatrix(const JPEGData& jpg_in,\r\n                                    const float target_mul,\r\n                                    int q[3][kDCTBlockSize]) {\r\n  QuantData data;\r\n  memcpy(data.q, q, sizeof(data.q));\r\n  OutputImage img(jpg_in.width, jpg_in.height);\r\n  img.CopyFromJpegData(jpg_in);\r\n  img.ApplyGlobalQuantization(data.q);\r\n  JPEGData jpg_out = jpg_in;\r\n  img.SaveToJpegData(&jpg_out);\r\n  std::string encoded_jpg;\r\n  OutputJpeg(jpg_out, &encoded_jpg);\r\n  GUETZLI_LOG(stats_, \"Iter %2d: %s quantization matrix:\\n\",\r\n              stats_->counters[kNumItersCnt] + 1,\r\n              img.FrameTypeStr().c_str());\r\n  GUETZLI_LOG_QUANT(stats_, q);\r\n  GUETZLI_LOG(stats_, \"Iter %2d: %s GQ[%5.2f] Out[%7zd]\",\r\n              stats_->counters[kNumItersCnt] + 1,\r\n              img.FrameTypeStr().c_str(),\r\n              QuantMatrixHeuristicScore(q), encoded_jpg.size());\r\n  ++stats_->counters[kNumItersCnt];\r\n  comparator_->Compare(img);\r\n  data.dist_ok = comparator_->DistanceOK(target_mul);\r\n  data.out.jpeg_data = encoded_jpg;\r\n  data.out.distmap = comparator_->distmap();\r\n  data.out.distmap_aggregate = comparator_->distmap_aggregate();\r\n  data.out.score = comparator_->ScoreOutputSize(encoded_jpg.size());\r\n  MaybeOutput(encoded_jpg);\r\n  return data;\r\n}\r\n\r\nbool Processor::SelectQuantMatrix(const JPEGData& jpg_in, const bool downsample,\r\n                                  int best_q[3][kDCTBlockSize],\r\n                                  GuetzliOutput* quantized_out) {\r\n  QuantMatrixGenerator qgen(downsample, stats_);\r\n  // Don't try to go up to exactly the target distance when selecting a\r\n  // quantization matrix, since we will need some slack to do the frequency\r\n  // masking later.\r\n  const float target_mul_high = 0.97;\r\n  const float target_mul_low = 0.95;\r\n\r\n  QuantData best = TryQuantMatrix(jpg_in, target_mul_high, best_q);\r\n  for (;;) {\r\n    int q_next[3][kDCTBlockSize];\r\n    if (!qgen.GetNext(q_next)) {\r\n      break;\r\n    }\r\n\r\n    QuantData data =\r\n        TryQuantMatrix(jpg_in, target_mul_high, q_next);\r\n    qgen.Add(data);\r\n    if (CompareQuantData(data, best)) {\r\n      best = data;\r\n      if (data.dist_ok && !comparator_->DistanceOK(target_mul_low)) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  memcpy(&best_q[0][0], &best.q[0][0], kBlockSize * sizeof(best_q[0][0]));\r\n  *quantized_out = best.out;\r\n  GUETZLI_LOG(stats_, \"\\n%s selected quantization matrix:\\n\",\r\n              downsample ? \"YUV420\" : \"YUV444\");\r\n  GUETZLI_LOG_QUANT(stats_, best_q);\r\n  return best.dist_ok;\r\n}\r\n\r\n\r\n// REQUIRES: block[c*64...(c*64+63)] is all zero if (comp_mask & (1<<c)) == 0.\r\nvoid Processor::ComputeBlockZeroingOrder(\r\n    const coeff_t block[kBlockSize], const coeff_t orig_block[kBlockSize],\r\n    const int block_x, const int block_y, const int factor_x,\r\n    const int factor_y, const uint8_t comp_mask, OutputImage* img,\r\n    std::vector<CoeffData>* output_order) {\r\n  static const uint8_t oldCsf[kDCTBlockSize] = {\r\n      10, 10, 20, 40, 60, 70, 80, 90,\r\n      10, 20, 30, 60, 70, 80, 90, 90,\r\n      20, 30, 60, 70, 80, 90, 90, 90,\r\n      40, 60, 70, 80, 90, 90, 90, 90,\r\n      60, 70, 80, 90, 90, 90, 90, 90,\r\n      70, 80, 90, 90, 90, 90, 90, 90,\r\n      80, 90, 90, 90, 90, 90, 90, 90,\r\n      90, 90, 90, 90, 90, 90, 90, 90,\r\n  };\r\n  static const double kWeight[3] = { 1.0, 0.22, 0.20 };\r\n#include \"guetzli/order.inc\"\r\n  std::vector<std::pair<int, float> > input_order;\r\n  for (int c = 0; c < 3; ++c) {\r\n    if (!(comp_mask & (1 << c))) continue;\r\n    for (int k = 1; k < kDCTBlockSize; ++k) {\r\n      int idx = c * kDCTBlockSize + k;\r\n      if (block[idx] != 0) {\r\n        float score;\r\n        if (params_.new_zeroing_model) {\r\n          score = std::abs(orig_block[idx]) * csf[idx] + bias[idx];\r\n        } else {\r\n          score = (std::abs(orig_block[idx]) - kJPEGZigZagOrder[k] / 64.0) *\r\n                  kWeight[c] / oldCsf[k];\r\n        }\r\n        input_order.push_back(std::make_pair(idx, score));\r\n      }\r\n    }\r\n  }\r\n  std::sort(input_order.begin(), input_order.end(),\r\n            [](const std::pair<int, float>& a, const std::pair<int, float>& b) {\r\n              return a.second < b.second; });\r\n  coeff_t processed_block[kBlockSize];\r\n  memcpy(processed_block, block, sizeof(processed_block));\r\n  while (!input_order.empty()) {\r\n    float best_err = 1e17;\r\n    int best_i = 0;\r\n    for (int i = 0; i < std::min<size_t>(params_.zeroing_greedy_lookahead,\r\n                                         input_order.size());\r\n         ++i) {\r\n      coeff_t candidate_block[kBlockSize];\r\n      memcpy(candidate_block, processed_block, sizeof(candidate_block));\r\n      const int idx = input_order[i].first;\r\n      candidate_block[idx] = 0;\r\n      for (int c = 0; c < 3; ++c) {\r\n        if (comp_mask & (1 << c)) {\r\n          img->component(c).SetCoeffBlock(\r\n              block_x, block_y, &candidate_block[c * kDCTBlockSize]);\r\n        }\r\n      }\r\n      float max_err = 0;\r\n      for (int iy = 0; iy < factor_y; ++iy) {\r\n        for (int ix = 0; ix < factor_x; ++ix) {\r\n          int block_xx = block_x * factor_x + ix;\r\n          int block_yy = block_y * factor_y + iy;\r\n          if (8 * block_xx < img->width() && 8 * block_yy < img->height()) {\r\n            float err = comparator_->CompareBlock(*img, block_xx, block_yy);\r\n            max_err = std::max(max_err, err);\r\n          }\r\n        }\r\n      }\r\n      if (max_err < best_err) {\r\n        best_err = max_err;\r\n        best_i = i;\r\n      }\r\n    }\r\n    int idx = input_order[best_i].first;\r\n    processed_block[idx] = 0;\r\n    input_order.erase(input_order.begin() + best_i);\r\n    output_order->push_back({idx, best_err});\r\n    for (int c = 0; c < 3; ++c) {\r\n      if (comp_mask & (1 << c)) {\r\n        img->component(c).SetCoeffBlock(\r\n            block_x, block_y, &processed_block[c * kDCTBlockSize]);\r\n      }\r\n    }\r\n  }\r\n  // Make the block error values monotonic.\r\n  float min_err = 1e10;\r\n  for (int i = output_order->size() - 1; i >= 0; --i) {\r\n    min_err = std::min(min_err, (*output_order)[i].block_err);\r\n    (*output_order)[i].block_err = min_err;\r\n  }\r\n  // Cut off at the block error limit.\r\n  int num = 0;\r\n  while (num < output_order->size() &&\r\n         (*output_order)[num].block_err <= comparator_->BlockErrorLimit()) {\r\n    ++num;\r\n  }\r\n  output_order->resize(num);\r\n  // Restore *img to the same state as it was at the start of this function.\r\n  for (int c = 0; c < 3; ++c) {\r\n    if (comp_mask & (1 << c)) {\r\n      img->component(c).SetCoeffBlock(\r\n          block_x, block_y, &block[c * kDCTBlockSize]);\r\n    }\r\n  }\r\n}\r\n\r\nnamespace {\r\n\r\nvoid UpdateACHistogram(const int weight,\r\n                       const coeff_t* coeffs,\r\n                       const int* q,\r\n                       JpegHistogram* ac_histogram) {\r\n  int r = 0;\r\n  for (int k = 1; k < 64; ++k) {\r\n    const int k_nat = kJPEGNaturalOrder[k];\r\n    coeff_t coeff = coeffs[k_nat];\r\n    if (coeff == 0) {\r\n      r++;\r\n      continue;\r\n    }\r\n    while (r > 15) {\r\n      ac_histogram->Add(0xf0, weight);\r\n      r -= 16;\r\n    }\r\n    int nbits = Log2FloorNonZero(std::abs(coeff / q[k_nat])) + 1;\r\n    int symbol = (r << 4) + nbits;\r\n    ac_histogram->Add(symbol, weight);\r\n    r = 0;\r\n  }\r\n  if (r > 0) {\r\n    ac_histogram->Add(0, weight);\r\n  }\r\n}\r\n\r\nsize_t ComputeEntropyCodes(const std::vector<JpegHistogram>& histograms,\r\n                           std::vector<uint8_t>* depths) {\r\n  std::vector<JpegHistogram> clustered = histograms;\r\n  size_t num = histograms.size();\r\n  std::vector<int> indexes(histograms.size());\r\n  std::vector<uint8_t> clustered_depths(\r\n      histograms.size() * JpegHistogram::kSize);\r\n  ClusterHistograms(&clustered[0], &num, &indexes[0], &clustered_depths[0]);\r\n  depths->resize(clustered_depths.size());\r\n  for (int i = 0; i < histograms.size(); ++i) {\r\n    memcpy(&(*depths)[i * JpegHistogram::kSize],\r\n           &clustered_depths[indexes[i] * JpegHistogram::kSize],\r\n           JpegHistogram::kSize);\r\n  }\r\n  size_t histogram_size = 0;\r\n  for (int i = 0; i < num; ++i) {\r\n    histogram_size += HistogramHeaderCost(clustered[i]) / 8;\r\n  }\r\n  return histogram_size;\r\n}\r\n\r\nsize_t EntropyCodedDataSize(const std::vector<JpegHistogram>& histograms,\r\n                            const std::vector<uint8_t>& depths) {\r\n  size_t numbits = 0;\r\n  for (int i = 0; i < histograms.size(); ++i) {\r\n    numbits += HistogramEntropyCost(\r\n        histograms[i], &depths[i * JpegHistogram::kSize]);\r\n  }\r\n  return (numbits + 7) / 8;\r\n}\r\n\r\nsize_t EstimateDCSize(const JPEGData& jpg) {\r\n  std::vector<JpegHistogram> histograms(jpg.components.size());\r\n  BuildDCHistograms(jpg, &histograms[0]);\r\n  size_t num = histograms.size();\r\n  std::vector<int> indexes(num);\r\n  std::vector<uint8_t> depths(num * JpegHistogram::kSize);\r\n  return ClusterHistograms(&histograms[0], &num, &indexes[0], &depths[0]);\r\n}\r\n\r\n}  // namespace\r\n\r\nvoid Processor::SelectFrequencyMasking(const JPEGData& jpg, OutputImage* img,\r\n                                       const uint8_t comp_mask,\r\n                                       const double target_mul,\r\n                                       bool stop_early) {\r\n  const int width = img->width();\r\n  const int height = img->height();\r\n  const int last_c = Log2FloorNonZero(comp_mask);\r\n  if (last_c >= jpg.components.size()) return;\r\n  const int factor_x = img->component(last_c).factor_x();\r\n  const int factor_y = img->component(last_c).factor_y();\r\n  const int block_width = (width + 8 * factor_x - 1) / (8 * factor_x);\r\n  const int block_height = (height + 8 * factor_y - 1) / (8 * factor_y);\r\n  const int num_blocks = block_width * block_height;\r\n\r\n  std::vector<std::vector<CoeffData> > orders(num_blocks);\r\n  for (int block_y = 0, block_ix = 0; block_y < block_height; ++block_y) {\r\n    for (int block_x = 0; block_x < block_width; ++block_x, ++block_ix) {\r\n      coeff_t block[kBlockSize] = { 0 };\r\n      coeff_t orig_block[kBlockSize] = { 0 };\r\n      for (int c = 0; c < 3; ++c) {\r\n        if (comp_mask & (1 << c)) {\r\n          assert(img->component(c).factor_x() == factor_x);\r\n          assert(img->component(c).factor_y() == factor_y);\r\n          img->component(c).GetCoeffBlock(block_x, block_y,\r\n                                          &block[c * kDCTBlockSize]);\r\n          const JPEGComponent& comp = jpg.components[c];\r\n          int jpg_block_ix = block_y * comp.width_in_blocks + block_x;\r\n          memcpy(&orig_block[c * kDCTBlockSize],\r\n                 &comp.coeffs[jpg_block_ix * kDCTBlockSize],\r\n                 kDCTBlockSize * sizeof(orig_block[0]));\r\n        }\r\n      }\r\n      ComputeBlockZeroingOrder(block, orig_block, block_x, block_y, factor_x,\r\n                               factor_y, comp_mask, img,\r\n                               &orders[block_ix]);\r\n    }\r\n  }\r\n\r\n  JPEGData jpg_out = jpg;\r\n  img->SaveToJpegData(&jpg_out);\r\n  const int jpg_header_size = JpegHeaderSize(jpg_out, params_.clear_metadata);\r\n  const int dc_size = EstimateDCSize(jpg_out);\r\n  std::vector<JpegHistogram> ac_histograms(jpg_out.components.size());\r\n  BuildACHistograms(jpg_out, &ac_histograms[0]);\r\n  std::vector<uint8_t> ac_depths;\r\n  int ac_histogram_size = ComputeEntropyCodes(ac_histograms, &ac_depths);\r\n  int base_size = jpg_header_size + dc_size + ac_histogram_size +\r\n      EntropyCodedDataSize(ac_histograms, ac_depths);\r\n  int prev_size = base_size;\r\n\r\n  std::vector<float> max_block_error(num_blocks);\r\n  std::vector<int> last_indexes(num_blocks);\r\n  std::vector<float> distmap(width * height);\r\n\r\n  bool first_up_iter = true;\r\n  for (int direction : {1, -1}) {\r\n    for (;;) {\r\n      if (stop_early && direction == -1) {\r\n        if (prev_size > 1.01 * final_output_->jpeg_data.size()) {\r\n          // If we are down-adjusting the error, the output size will only keep\r\n          // increasing.\r\n          // TODO(user): Do this check always by comparing only the size\r\n          // of the currently processed components.\r\n          break;\r\n        }\r\n      }\r\n      std::vector<std::pair<int, float> > global_order;\r\n      int blocks_to_change;\r\n      std::vector<float> block_weight;\r\n      for (int rblock = 1; rblock <= 4; ++rblock) {\r\n        block_weight = std::vector<float>(num_blocks);\r\n        comparator_->ComputeBlockErrorAdjustmentWeights(\r\n            direction, rblock, target_mul, factor_x, factor_y, distmap,\r\n            &block_weight);\r\n        global_order.clear();\r\n        blocks_to_change = 0;\r\n        for (int block_y = 0, block_ix = 0; block_y < block_height; ++block_y) {\r\n          for (int block_x = 0; block_x < block_width; ++block_x, ++block_ix) {\r\n            const int last_index = last_indexes[block_ix];\r\n            const std::vector<CoeffData>& order = orders[block_ix];\r\n            const float max_err = max_block_error[block_ix];\r\n            if (block_weight[block_ix] == 0) {\r\n              continue;\r\n            }\r\n            if (direction > 0) {\r\n              for (int i = last_index; i < order.size(); ++i) {\r\n                float val = ((order[i].block_err - max_err) /\r\n                             block_weight[block_ix]);\r\n                global_order.push_back(std::make_pair(block_ix, val));\r\n              }\r\n              blocks_to_change += (last_index < order.size() ? 1 : 0);\r\n            } else {\r\n              for (int i = last_index - 1; i >= 0; --i) {\r\n                float val = ((max_err - order[i].block_err) /\r\n                             block_weight[block_ix]);\r\n                global_order.push_back(std::make_pair(block_ix, val));\r\n              }\r\n              blocks_to_change += (last_index > 0 ? 1 : 0);\r\n            }\r\n          }\r\n        }\r\n        if (!global_order.empty()) {\r\n          // If we found something to adjust with the current block adjustment\r\n          // radius, we can stop and adjust the blocks we have.\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (global_order.empty()) {\r\n        break;\r\n      }\r\n\r\n      std::sort(global_order.begin(), global_order.end(),\r\n                [](const std::pair<int, float>& a,\r\n                   const std::pair<int, float>& b) {\r\n                  return a.second < b.second; });\r\n\r\n      double rel_size_delta = direction > 0 ? 0.01 : 0.0005;\r\n      if (direction > 0 && comparator_->DistanceOK(1.0)) {\r\n        rel_size_delta = 0.05;\r\n      }\r\n      size_t min_size_delta = base_size * rel_size_delta;\r\n\r\n      float coeffs_to_change_per_block =\r\n          direction > 0 ? 2.0 : factor_x * factor_y * 0.2;\r\n      int min_coeffs_to_change = coeffs_to_change_per_block * blocks_to_change;\r\n\r\n      if (first_up_iter) {\r\n        const float limit = 0.75 * comparator_->BlockErrorLimit();\r\n        auto it = std::partition_point(global_order.begin(), global_order.end(),\r\n                                       [=](const std::pair<int, float>& a) {\r\n                                         return a.second < limit; });\r\n        min_coeffs_to_change = std::max<int>(min_coeffs_to_change,\r\n                                             it - global_order.begin());\r\n        first_up_iter = false;\r\n      }\r\n\r\n      std::set<int> changed_blocks;\r\n      float val_threshold = 0.0;\r\n      int changed_coeffs = 0;\r\n      int est_jpg_size = prev_size;\r\n      for (int i = 0; i < global_order.size(); ++i) {\r\n        const int block_ix = global_order[i].first;\r\n        const int block_x = block_ix % block_width;\r\n        const int block_y = block_ix / block_width;\r\n        const int last_idx = last_indexes[block_ix];\r\n        const std::vector<CoeffData>& order = orders[block_ix];\r\n        const int idx = order[last_idx + std::min(direction, 0)].idx;\r\n        const int c = idx / kDCTBlockSize;\r\n        const int k = idx % kDCTBlockSize;\r\n        const int* quant = img->component(c).quant();\r\n        const JPEGComponent& comp = jpg.components[c];\r\n        const int jpg_block_ix = block_y * comp.width_in_blocks + block_x;\r\n        const int newval = direction > 0 ? 0 : Quantize(\r\n            comp.coeffs[jpg_block_ix * kDCTBlockSize + k], quant[k]);\r\n        coeff_t block[kDCTBlockSize] = { 0 };\r\n        img->component(c).GetCoeffBlock(block_x, block_y, block);\r\n        UpdateACHistogram(-1, block, quant, &ac_histograms[c]);\r\n        block[k] = newval;\r\n        UpdateACHistogram(1, block, quant, &ac_histograms[c]);\r\n        img->component(c).SetCoeffBlock(block_x, block_y, block);\r\n        last_indexes[block_ix] += direction;\r\n        changed_blocks.insert(block_ix);\r\n        val_threshold = global_order[i].second;\r\n        ++changed_coeffs;\r\n        static const int kEntropyCodeUpdateFreq = 10;\r\n        if (i % kEntropyCodeUpdateFreq == 0) {\r\n          ac_histogram_size = ComputeEntropyCodes(ac_histograms, &ac_depths);\r\n        }\r\n        est_jpg_size = jpg_header_size + dc_size + ac_histogram_size +\r\n            EntropyCodedDataSize(ac_histograms, ac_depths);\r\n        if (changed_coeffs > min_coeffs_to_change &&\r\n            std::abs(est_jpg_size - prev_size) > min_size_delta) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      for (int i = 0; i < num_blocks; ++i) {\r\n        max_block_error[i] += block_weight[i] * val_threshold * direction;\r\n      }\r\n\r\n      ++stats_->counters[kNumItersCnt];\r\n      ++stats_->counters[direction > 0 ? kNumItersUpCnt : kNumItersDownCnt];\r\n      JPEGData jpg_out = jpg;\r\n      img->SaveToJpegData(&jpg_out);\r\n      std::string encoded_jpg;\r\n      OutputJpeg(jpg_out, &encoded_jpg);\r\n      GUETZLI_LOG(stats_,\r\n                  \"Iter %2d: %s(%d) %s Coeffs[%d/%zd] \"\r\n                  \"Blocks[%zd/%d/%d] ValThres[%.4f] Out[%7zd] EstErr[%.2f%%]\",\r\n                  stats_->counters[kNumItersCnt], img->FrameTypeStr().c_str(),\r\n                  comp_mask, direction > 0 ? \"up\" : \"down\", changed_coeffs,\r\n                  global_order.size(), changed_blocks.size(),\r\n                  blocks_to_change, num_blocks, val_threshold,\r\n                  encoded_jpg.size(),\r\n                  100.0 - (100.0 * est_jpg_size) / encoded_jpg.size());\r\n      comparator_->Compare(*img);\r\n      MaybeOutput(encoded_jpg);\r\n      distmap = comparator_->distmap();\r\n      prev_size = est_jpg_size;\r\n    }\r\n  }\r\n}\r\n\r\nbool IsGrayscale(const JPEGData& jpg) {\r\n  for (int c = 1; c < 3; ++c) {\r\n    const JPEGComponent& comp = jpg.components[c];\r\n    for (size_t i = 0; i < comp.coeffs.size(); ++i) {\r\n      if (comp.coeffs[i] != 0) return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nbool Processor::ProcessJpegData(const Params& params, const JPEGData& jpg_in,\r\n                                Comparator* comparator, GuetzliOutput* out,\r\n                                ProcessStats* stats) {\r\n  params_ = params;\r\n  comparator_ = comparator;\r\n  final_output_ = out;\r\n  stats_ = stats;\r\n\r\n  if (params.butteraugli_target > 2.0f) {\r\n    fprintf(stderr,\r\n            \"Guetzli should be called with quality >= 84, otherwise the\\n\"\r\n            \"output will have noticeable artifacts. If you want to\\n\"\r\n            \"proceed anyway, please edit the source code.\\n\");\r\n    return false;\r\n  }\r\n  if (jpg_in.components.size() != 3 || !HasYCbCrColorSpace(jpg_in)) {\r\n    fprintf(stderr, \"Only YUV color space input jpeg is supported\\n\");\r\n    return false;\r\n  }\r\n  bool input_is_420;\r\n  if (jpg_in.Is444()) {\r\n    input_is_420 = false;\r\n  } else if (jpg_in.Is420()) {\r\n    input_is_420 = true;\r\n  } else {\r\n    fprintf(stderr, \"Unsupported sampling factors:\");\r\n    for (int i = 0; i < jpg_in.components.size(); ++i) {\r\n      fprintf(stderr, \" %dx%d\", jpg_in.components[i].h_samp_factor,\r\n              jpg_in.components[i].v_samp_factor);\r\n    }\r\n    fprintf(stderr, \"\\n\");\r\n    return false;\r\n  }\r\n  JPEGData jpg = jpg_in;\r\n  int q_in[3][kDCTBlockSize];\r\n  // Output the original image, in case we do not manage to create anything\r\n  // with a good enough quality.\r\n  std::string encoded_jpg;\r\n  OutputJpeg(jpg, &encoded_jpg);\r\n  final_output_->score = -1;\r\n  GUETZLI_LOG(stats, \"Original Out[%7zd]\", encoded_jpg.size());\r\n  if (comparator_ == nullptr) {\r\n    GUETZLI_LOG(stats, \" <image too small for Butteraugli>\\n\");\r\n    final_output_->jpeg_data = encoded_jpg;\r\n    final_output_->distmap = std::vector<float>(jpg.width * jpg.height, 0.0);\r\n    final_output_->distmap_aggregate = 0;\r\n    final_output_->score = encoded_jpg.size();\r\n    // Butteraugli doesn't work with images this small.\r\n    return true;\r\n  }\r\n  RemoveOriginalQuantization(&jpg, q_in);\r\n  OutputImage img(jpg.width, jpg.height);\r\n  img.CopyFromJpegData(jpg);\r\n  comparator_->Compare(img);\r\n  MaybeOutput(encoded_jpg);\r\n  int try_420 = (input_is_420 || params_.force_420 ||\r\n                 (params_.try_420 && !IsGrayscale(jpg))) ? 1 : 0;\r\n  int force_420 = (input_is_420 || params_.force_420) ? 1 : 0;\r\n  for (int downsample = force_420; downsample <= try_420; ++downsample) {\r\n    OutputImage img(jpg.width, jpg.height);\r\n    img.CopyFromJpegData(jpg);\r\n    JPEGData tmp_jpg = jpg;\r\n    if (downsample) {\r\n      DownsampleImage(&img);\r\n      img.SaveToJpegData(&tmp_jpg);\r\n    }\r\n    int best_q[3][kDCTBlockSize];\r\n    memcpy(best_q, q_in, sizeof(best_q));\r\n    GuetzliOutput quantized_out;\r\n    if (!SelectQuantMatrix(tmp_jpg, downsample, best_q, &quantized_out)) {\r\n      for (int c = 0; c < 3; ++c) {\r\n        for (int i = 0; i < kDCTBlockSize; ++i) {\r\n          best_q[c][i] = 1;\r\n        }\r\n      }\r\n    }\r\n    img.ApplyGlobalQuantization(best_q);\r\n\r\n    if (!downsample) {\r\n      SelectFrequencyMasking(tmp_jpg, &img, 7, 1.0, false);\r\n    } else {\r\n      const float ymul = tmp_jpg.components.size() == 1 ? 1.0 : 0.97;\r\n      SelectFrequencyMasking(tmp_jpg, &img, 1, ymul, false);\r\n      SelectFrequencyMasking(tmp_jpg, &img, 6, 1.0, true);\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nbool ProcessJpegData(const Params& params, const JPEGData& jpg_in,\r\n                     Comparator* comparator, GuetzliOutput* out,\r\n                     ProcessStats* stats) {\r\n  Processor processor;\r\n  return processor.ProcessJpegData(params, jpg_in, comparator, out, stats);\r\n}\r\n\r\nbool Process(const Params& params, ProcessStats* stats,\r\n             const std::string& data,\r\n             std::string* jpg_out) {\r\n  JPEGData jpg;\r\n  if (!ReadJpeg(data, JPEG_READ_ALL, &jpg)) {\r\n    fprintf(stderr, \"Can't read jpg data from input file\\n\");\r\n    return false;\r\n  }\r\n  std::vector<uint8_t> rgb = DecodeJpegToRGB(jpg);\r\n  if (rgb.empty()) {\r\n    fprintf(stderr, \"Unsupported input JPEG file (e.g. unsupported \"\r\n            \"downsampling mode).\\nPlease provide the input image as \"\r\n            \"a PNG file.\\n\");\r\n    return false;\r\n  }\r\n  GuetzliOutput out;\r\n  ProcessStats dummy_stats;\r\n  if (stats == nullptr) {\r\n    stats = &dummy_stats;\r\n  }\r\n  std::unique_ptr<ButteraugliComparator> comparator;\r\n  if (jpg.width >= 32 && jpg.height >= 32) {\r\n    comparator.reset(\r\n        new ButteraugliComparator(jpg.width, jpg.height, rgb,\r\n                                  params.butteraugli_target, stats));\r\n  }\r\n  bool ok = ProcessJpegData(params, jpg, comparator.get(), &out, stats);\r\n  *jpg_out = out.jpeg_data;\r\n  return ok;\r\n}\r\n\r\nbool Process(const Params& params, ProcessStats* stats,\r\n             const std::vector<uint8_t>& rgb, int w, int h,\r\n             std::string* jpg_out) {\r\n  JPEGData jpg;\r\n  if (!EncodeRGBToJpeg(rgb, w, h, &jpg)) {\r\n    fprintf(stderr, \"Could not create jpg data from rgb pixels\\n\");\r\n    return false;\r\n  }\r\n  GuetzliOutput out;\r\n  ProcessStats dummy_stats;\r\n  if (stats == nullptr) {\r\n    stats = &dummy_stats;\r\n  }\r\n  std::unique_ptr<ButteraugliComparator> comparator;\r\n  if (jpg.width >= 32 && jpg.height >= 32) {\r\n    comparator.reset(\r\n        new ButteraugliComparator(jpg.width, jpg.height, rgb,\r\n                                  params.butteraugli_target, stats));\r\n  }\r\n  bool ok = ProcessJpegData(params, jpg, comparator.get(), &out, stats);\r\n  *jpg_out = out.jpeg_data;\r\n  return ok;\r\n}\r\n\r\n}  // namespace guetzli\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#ifndef GUETZLI_PROCESSOR_H_\r\n#define GUETZLI_PROCESSOR_H_\r\n\r\n#include <string>\r\n#include <vector>\r\n\r\n#include \"guetzli/comparator.h\"\r\n#include \"guetzli/jpeg_data.h\"\r\n#include \"guetzli/stats.h\"\r\n\r\nnamespace guetzli {\r\n\r\nstruct Params {\r\n  float butteraugli_target = 1.0;\r\n  bool clear_metadata = true;\r\n  bool try_420 = false;\r\n  bool force_420 = false;\r\n  bool use_silver_screen = false;\r\n  int zeroing_greedy_lookahead = 3;\r\n  bool new_zeroing_model = true;\r\n};\r\n\r\nbool Process(const Params& params, ProcessStats* stats,\r\n             const std::string& in_data,\r\n             std::string* out_data);\r\n\r\nstruct GuetzliOutput {\r\n  std::string jpeg_data;\r\n  std::vector<float> distmap;\r\n  double distmap_aggregate;\r\n  double score;\r\n};\r\n\r\nbool ProcessJpegData(const Params& params, const JPEGData& jpg_in,\r\n                     Comparator* comparator, GuetzliOutput* out,\r\n                     ProcessStats* stats);\r\n\r\n// Sets *out to a jpeg encoded string that will decode to an image that is\r\n// visually indistinguishable from the input rgb image.\r\nbool Process(const Params& params, ProcessStats* stats,\r\n             const std::vector<uint8_t>& rgb, int w, int h,\r\n             std::string* out);\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_PROCESSOR_H_\r\n","// -*- C++ -*-\n//===----------------------------- map ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MAP\n#define _LIBCPP_MAP\n\n/*\n\n    map synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass map\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    map()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit map(const key_compare& comp);\n    map(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp = key_compare());\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp, const allocator_type& a);\n    map(const map& m);\n    map(map&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit map(const allocator_type& a);\n    map(const map& m, const allocator_type& a);\n    map(map&& m, const allocator_type& a);\n    map(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last, const allocator_type& a)\n            : map(first, last, Compare(), a) {}  // C++14\n    map(initializer_list<value_type> il, const allocator_type& a)\n        : map(il, Compare(), a) {}  // C++14\n   ~map();\n\n    map& operator=(const map& m);\n    map& operator=(map&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    map& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // element access:\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n          mapped_type& at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& v);\n    pair<iterator, bool> insert(      value_type&& v);                                // C++17\n    template <class P>\n        pair<iterator, bool> insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position,       value_type&& v);                   // C++17\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    template <class... Args>\n        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);          // C++17\n    template <class... Args>\n        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);               // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args); // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);      // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);            // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);                 // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);   // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);        // C++17\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position); // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(map& m)\n        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&\n            is_nothrow_swappable<key_compare>::value); // C++17\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass multimap\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type,mapped_type>         value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type,value_type,bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    multimap()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multimap(const key_compare& comp);\n    multimap(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp,\n                 const allocator_type& a);\n    multimap(const multimap& m);\n    multimap(multimap&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multimap(const allocator_type& a);\n    multimap(const multimap& m, const allocator_type& a);\n    multimap(multimap&& m, const allocator_type& a);\n    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    multimap(initializer_list<value_type> il, const key_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const allocator_type& a)\n            : multimap(first, last, Compare(), a) {} // C++14\n    multimap(initializer_list<value_type> il, const allocator_type& a)\n        : multimap(il, Compare(), a) {} // C++14\n    ~multimap();\n\n    multimap& operator=(const multimap& m);\n    multimap& operator=(multimap&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multimap& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    iterator insert(      value_type&& v);                                            // C++17\n    template <class P>\n        iterator insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position,       value_type&& v);                   // C++17\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position); // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multimap& m)\n        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&\n            is_nothrow_swappable<key_compare>::value); // C++17\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(multimap<Key, T, Compare, Allocator>& x,\n     multimap<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <functional>\n#include <initializer_list>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _CP, class _Compare,\n          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value\n         >\nclass __map_value_compare\n    : private _Compare\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : _Compare() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : _Compare(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}\n    void swap(__map_value_compare&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)\n    {\n        using _VSTD::swap;\n        swap(static_cast<const _Compare&>(*this), static_cast<const _Compare&>(__y));\n    }\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return static_cast<const _Compare&>(*this) (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return static_cast<const _Compare&>(*this) (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare>\nclass __map_value_compare<_Key, _CP, _Compare, false>\n{\n    _Compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : comp() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : comp(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return comp;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return comp(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return comp(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return comp(__x, __y.__cc.first);}\n    void swap(__map_value_compare&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)\n    {\n        using _VSTD::swap;\n        swap(comp, __y.comp);\n    }\n    \n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return comp (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return comp (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare, bool __b>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__map_value_compare<_Key, _CP, _Compare, __b>& __x,\n     __map_value_compare<_Key, _CP, _Compare, __b>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Allocator>\nclass __map_node_destructor\n{\n    typedef _Allocator                          allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\n\nprivate:\n    allocator_type& __na_;\n\n    __map_node_destructor& operator=(const __map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class multimap;\ntemplate <class _TreeIterator> class __map_const_iterator;\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp>\nunion __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(const __value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(__value_type&& __v)\n        {__nc = _VSTD::move(__v.__nc); return *this;}\n\n    template <class _ValueTp,\n              class = typename enable_if<\n                    __is_same_uncvref<_ValueTp, value_type>::value\n                 >::type\n             >\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(_ValueTp&& __v) {\n        __nc = _VSTD::forward<_ValueTp>(__v); return *this;\n    }\n\nprivate:\n    __value_type() _LIBCPP_EQUAL_DELETE;\n    ~__value_type() _LIBCPP_EQUAL_DELETE;\n    __value_type(const __value_type& __v) _LIBCPP_EQUAL_DELETE;\n    __value_type(__value_type&& __v) _LIBCPP_EQUAL_DELETE;\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\nprivate:\n   __value_type();\n   __value_type(__value_type const&);\n   __value_type& operator=(__value_type const&);\n   ~__value_type();\n};\n\n#endif\n\ntemplate <class _Tp>\nstruct __extract_key_value_types;\n\ntemplate <class _Key, class _Tp>\nstruct __extract_key_value_types<__value_type<_Key, _Tp> >\n{\n  typedef _Key const __key_type;\n  typedef _Tp        __mapped_type;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_iterator\n{\n    typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n\n    _TreeIterator __i_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename _NodeTypes::__map_value_type_pointer        pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator++(int)\n    {\n        __map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator--(int)\n    {\n        __map_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend \n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_const_iterator\n{\n    typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n\n    _TreeIterator __i_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_map_value_type_pointer  pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(__map_iterator<\n        typename _TreeIterator::__non_const_iterator> __i) _NOEXCEPT\n        : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator++(int)\n    {\n        __map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator--(int)\n    {\n        __map_const_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY map\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>   __base;\n    typedef typename __base::__node_traits                 __node_traits;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>             iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    map()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : map(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m)\n        : __tree_(__m.__tree_)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(const map& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    map(map&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    map(initializer_list<value_type> __il, const allocator_type& __a)\n        : map(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_CXX03_LANG\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n          mapped_type& at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> emplace(_Args&& ...__args) {\n        return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {\n        return __tree_.__emplace_hint_unique(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __p)\n            {return __tree_.__insert_unique(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_unique(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n        insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_unique(__p.__i_, __v);}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    insert(value_type&& __v) {return __tree_.__insert_unique(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p,  value_type&& __v)\n    {return __tree_.__insert_unique(__p.__i_, _VSTD::move(__v));}\n#endif\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                insert(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_unique_key_args(__k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_unique_key_args(__k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)\n    {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return _VSTD::make_pair(__p, false);\n        }\n        return _VSTD::make_pair(emplace_hint(__p, __k, _VSTD::forward<_Vp>(__v)), true);\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)\n    {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return _VSTD::make_pair(__p, false);\n        }\n        return _VSTD::make_pair(emplace_hint(__p, _VSTD::move(__k), _VSTD::forward<_Vp>(__v)), true);\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator __h, const key_type& __k, _Vp&& __v)\n     {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return __p;\n        }\n        return emplace_hint(__h, __k, _VSTD::forward<_Vp>(__v));\n     }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator __h, key_type&& __k, _Vp&& __v)\n     {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return __p;\n        }\n        return emplace_hint(__h, _VSTD::move(__k), _VSTD::forward<_Vp>(__v));\n     }\n\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(map& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const {return __tree_.__count_unique(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_base_pointer       __node_base_pointer;\n\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifdef _LIBCPP_CXX03_LANG\n    __node_holder __construct_node_with_key(const key_type& __k);\n#endif\n\n    __node_base_pointer const&\n    __find_equal_key(__node_base_pointer& __parent, const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_base_pointer&\n    __find_equal_key(__node_base_pointer& __parent, const key_type& __k) {\n        map const* __const_this = this;\n        return const_cast<__node_base_pointer&>(\n            __const_this->__find_equal_key(__parent, __k));\n    }\n};\n\n\n// Find __k\n// Set __parent to parent of null leaf and\n//    return reference to null leaf iv __k does not exist.\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer const&\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_pointer& __parent,\n                                                       const key_type& __k) const\n{\n    __node_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return __parent->__left_;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmap<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_unique(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));\n    }\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\n\n#ifdef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(__k);\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#else\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    return __tree_.__emplace_unique_key_args(__k,\n        _VSTD::piecewise_construct,\n        _VSTD::forward_as_tuple(__k),\n        _VSTD::forward_as_tuple()).first->__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)\n{\n    return __tree_.__emplace_unique_key_args(__k,\n        _VSTD::piecewise_construct,\n        _VSTD::forward_as_tuple(_VSTD::move(__k)),\n        _VSTD::forward_as_tuple()).first->__cc.second;\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nconst _Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const\n{\n    __node_base_pointer __parent;\n    __node_base_pointer __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(map<_Key, _Tp, _Compare, _Allocator>& __x,\n     map<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY multimap\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY\n        value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>            __base;\n    typedef typename __base::__node_traits                          __node_traits;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : multimap(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m)\n        : __tree_(__m.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(const multimap& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    multimap(multimap&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(initializer_list<value_type> __il, const allocator_type& __a)\n        : multimap(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp() const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp() const\n        {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_CXX03_LANG\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace(_Args&& ...__args) {\n        return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {\n        return __tree_.__emplace_hint_multi(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __p)\n            {return __tree_.__insert_multi(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_multi(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_multi(__p.__i_, _VSTD::move(__v));}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_multi(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multimap& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const {return __tree_.__count_multi(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmultimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_multi(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));\n    }\n}\n#endif\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n     multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MAP\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#ifndef GUETZLI_STATS_H_\r\n#define GUETZLI_STATS_H_\r\n\r\n#include <cstdio>\r\n#include <map>\r\n#include <string>\r\n#include <utility>\r\n#include <vector>\r\n\r\n\r\nnamespace guetzli {\r\n\r\nstatic const char* const  kNumItersCnt = \"number of iterations\";\r\nstatic const char* const kNumItersUpCnt = \"number of iterations up\";\r\nstatic const char* const kNumItersDownCnt = \"number of iterations down\";\r\n\r\nstruct ProcessStats {\r\n  ProcessStats() {}\r\n  std::map<std::string, int> counters;\r\n  std::string* debug_output = nullptr;\r\n  FILE* debug_output_file = nullptr;\r\n\r\n  std::string filename;\r\n};\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_STATS_H_\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include \"guetzli/quality.h\"\r\n\r\nnamespace guetzli {\r\n\r\nnamespace {\r\n\r\nconstexpr int kLowestQuality = 70;\r\nconstexpr int kHighestQuality = 110;\r\n\r\n// Butteraugli scores that correspond to JPEG quality levels, starting at\r\n// kLowestQuality. They were computed by taking median BA scores of JPEGs\r\n// generated using libjpeg-turbo at given quality from a set of PNGs.\r\n// The scores above quality level 100 are just linearly decreased so that score\r\n// for 110 is 90% of the score for 100.\r\nconst double kScoreForQuality[] = {\r\n  2.810761,  // 70\r\n  2.729300,\r\n  2.689687,\r\n  2.636811,\r\n  2.547863,\r\n  2.525400,\r\n  2.473416,\r\n  2.366133,\r\n  2.338078,\r\n  2.318654,\r\n  2.201674,  // 80\r\n  2.145517,\r\n  2.087322,\r\n  2.009328,\r\n  1.945456,\r\n  1.900112,\r\n  1.805701,\r\n  1.750194,\r\n  1.644175,\r\n  1.562165,\r\n  1.473608,  // 90\r\n  1.382021,\r\n  1.294298,\r\n  1.185402,\r\n  1.066781,\r\n  0.971769,  // 95\r\n  0.852901,\r\n  0.724544,\r\n  0.611302,\r\n  0.443185,\r\n  0.211578,  // 100\r\n  0.209462,\r\n  0.207346,\r\n  0.205230,\r\n  0.203114,\r\n  0.200999,  // 105\r\n  0.198883,\r\n  0.196767,\r\n  0.194651,\r\n  0.192535,\r\n  0.190420,  // 110\r\n  0.190420,\r\n};\r\n\r\n}  // namespace\r\n\r\ndouble ButteraugliScoreForQuality(double quality) {\r\n  if (quality < kLowestQuality) quality = kLowestQuality;\r\n  if (quality > kHighestQuality) quality = kHighestQuality;\r\n  int index = static_cast<int>(quality);\r\n  double mix = quality - index;\r\n  return kScoreForQuality[index - kLowestQuality] * (1 - mix) +\r\n      kScoreForQuality[index - kLowestQuality + 1] * mix;\r\n}\r\n\r\n}  // namespace guetzli\r\n","// -*- C++ -*-\n//===---------------------------- array -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ARRAY\n#define _LIBCPP_ARRAY\n\n/*\n    array synopsis\n\nnamespace std\n{\ntemplate <class T, size_t N >\nstruct array\n{\n    // types:\n    typedef T & reference;\n    typedef const T & const_reference;\n    typedef implementation defined iterator;\n    typedef implementation defined const_iterator;\n    typedef size_t size_type;\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef const T* const_pointer;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    // No explicit construct/copy/destroy for aggregate type\n    void fill(const T& u);\n    void swap(array& a) noexcept(is_nothrow_swappable_v<T>);\n\n    // iterators:\n    iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator cbegin() const noexcept;\n    const_iterator cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    // capacity:\n    constexpr size_type size() const noexcept;\n    constexpr size_type max_size() const noexcept;\n    constexpr bool empty() const noexcept;\n\n    // element access:\n    reference operator[](size_type n);\n    const_reference operator[](size_type n) const; // constexpr in C++14\n    const_reference at(size_type n) const; // constexpr in C++14\n    reference at(size_type n);\n\n    reference front();\n    const_reference front() const; // constexpr in C++14\n    reference back();\n    const_reference back() const; // constexpr in C++14\n\n    T* data() noexcept;\n    const T* data() const noexcept;\n};\n\ntemplate <class T, size_t N>\n  bool operator==(const array<T,N>& x, const array<T,N>& y);\ntemplate <class T, size_t N>\n  bool operator!=(const array<T,N>& x, const array<T,N>& y);\ntemplate <class T, size_t N>\n  bool operator<(const array<T,N>& x, const array<T,N>& y);\ntemplate <class T, size_t N>\n  bool operator>(const array<T,N>& x, const array<T,N>& y);\ntemplate <class T, size_t N>\n  bool operator<=(const array<T,N>& x, const array<T,N>& y);\ntemplate <class T, size_t N>\n  bool operator>=(const array<T,N>& x, const array<T,N>& y);\n\ntemplate <class T, size_t N >\n  void swap(array<T,N>& x, array<T,N>& y) noexcept(noexcept(x.swap(y)));\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\ntemplate <class T, size_t N> struct tuple_size<array<T, N>>;\ntemplate <size_t I, class T, size_t N> struct tuple_element<I, array<T, N>>;\ntemplate <size_t I, class T, size_t N> T& get(array<T, N>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class T, size_t N> const T& get(const array<T, N>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class T, size_t N> T&& get(array<T, N>&&) noexcept; // constexpr in C++14\ntemplate <size_t I, class T, size_t N> const T&& get(const array<T, N>&&) noexcept; // constexpr in C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n#include <utility>\n#include <iterator>\n#include <algorithm>\n#include <stdexcept>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, size_t _Size>\nstruct _LIBCPP_TYPE_VIS_ONLY array\n{\n    // types:\n    typedef array __self;\n    typedef _Tp                                   value_type;\n    typedef value_type&                           reference;\n    typedef const value_type&                     const_reference;\n    typedef value_type*                           iterator;\n    typedef const value_type*                     const_iterator;\n    typedef value_type*                           pointer;\n    typedef const value_type*                     const_pointer;\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef std::reverse_iterator<iterator>       reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    value_type __elems_[_Size > 0 ? _Size : 1];\n\n    // No explicit construct/copy/destroy for aggregate type\n    _LIBCPP_INLINE_VISIBILITY void fill(const value_type& __u)\n        {_VSTD::fill_n(__elems_, _Size, __u);}\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(array& __a) _NOEXCEPT_(_Size == 0 || __is_nothrow_swappable<_Tp>::value)\n        { __swap_dispatch((std::integral_constant<bool, _Size == 0>()), __a); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __swap_dispatch(std::true_type, array&) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __swap_dispatch(std::false_type, array& __a)\n        { _VSTD::swap_ranges(__elems_, __elems_ + _Size, __a.__elems_);}\n\n    // iterators:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT {return iterator(__elems_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__elems_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT {return iterator(__elems_ + _Size);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__elems_ + _Size);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    // capacity:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR size_type size() const _NOEXCEPT {return _Size;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR size_type max_size() const _NOEXCEPT {return _Size;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR bool empty() const _NOEXCEPT {return _Size == 0;}\n\n    // element access:\n    _LIBCPP_INLINE_VISIBILITY reference operator[](size_type __n)             {return __elems_[__n];}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const_reference operator[](size_type __n) const {return __elems_[__n];}\n    reference at(size_type __n);\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference front()             {return __elems_[0];}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const_reference front() const {return __elems_[0];}\n    _LIBCPP_INLINE_VISIBILITY reference back()              {return __elems_[_Size > 0 ? _Size-1 : 0];}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const_reference back() const  {return __elems_[_Size > 0 ? _Size-1 : 0];}\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data() _NOEXCEPT {return __elems_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT {return __elems_;}\n};\n\ntemplate <class _Tp, size_t _Size>\ntypename array<_Tp, _Size>::reference\narray<_Tp, _Size>::at(size_type __n)\n{\n    if (__n >= _Size)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw out_of_range(\"array::at\");\n#else\n        assert(!\"array::at out_of_range\");\n#endif\n    return __elems_[__n];\n}\n\ntemplate <class _Tp, size_t _Size>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename array<_Tp, _Size>::const_reference\narray<_Tp, _Size>::at(size_type __n) const\n{\n    if (__n >= _Size)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw out_of_range(\"array::at\");\n#else\n        assert(!\"array::at out_of_range\");\n#endif\n    return __elems_[__n];\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return _VSTD::equal(__x.__elems_, __x.__elems_ + _Size, __y.__elems_);\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.__elems_, __x.__elems_ + _Size, __y.__elems_, __y.__elems_ + _Size);\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    _Size == 0 ||\n    __is_swappable<_Tp>::value,\n    void\n>::type\nswap(array<_Tp, _Size>& __x, array<_Tp, _Size>& __y)\n                                  _NOEXCEPT_(noexcept(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Tp, size_t _Size>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_size<array<_Tp, _Size> >\n    : public integral_constant<size_t, _Size> {};\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, array<_Tp, _Size> >\n{\npublic:\n    typedef _Tp type;\n};\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&\nget(array<_Tp, _Size>& __a) _NOEXCEPT\n{\n    static_assert(_Ip < _Size, \"Index out of bounds in std::get<> (std::array)\");\n    return __a.__elems_[_Ip];\n}\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nget(const array<_Tp, _Size>& __a) _NOEXCEPT\n{\n    static_assert(_Ip < _Size, \"Index out of bounds in std::get<> (const std::array)\");\n    return __a.__elems_[_Ip];\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nget(array<_Tp, _Size>&& __a) _NOEXCEPT\n{\n    static_assert(_Ip < _Size, \"Index out of bounds in std::get<> (std::array &&)\");\n    return _VSTD::move(__a.__elems_[_Ip]);\n}\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&&\nget(const array<_Tp, _Size>&& __a) _NOEXCEPT\n{\n    static_assert(_Ip < _Size, \"Index out of bounds in std::get<> (const std::array &&)\");\n    return _VSTD::move(__a.__elems_[_Ip]);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ARRAY\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n    \n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class, class R = void> struct is_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_callable<Fn(ArgTypes...), R>;\n\n    template <class, class R = void> struct is_nothrow_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_nothrow_callable<Fn(ArgTypes...), R>;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n    template <class...>\n      using void_t = void;   // C++17\n      \n      // See C++14 20.10.4.1, primary type categories\n      template <class T> constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n\n      // See C++14 20.10.5, type property queries\n      template <class T> constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class T, class R = void> constexpr bool is_callable_v\n        = is_callable<T, R>::value;                                      // C++17\n      template <class T, class R = void> constexpr bool is_nothrow_callable_v\n        = is_nothrow_callable<T, R>::value;                              // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B> \n        constexpr bool conjunction_v = conjunction<B...>::value;         // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        constexpr bool disjunction_v = disjunction<B...>::value;         // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B> \n        constexpr bool negation_v = negation<B>::value;                  // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY pair;\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TYPE_VIS_ONLY __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#if __has_builtin(__builtin_addressof)\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n}\n\n#endif // __has_builtin(__builtin_addressof)\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TYPE_VIS_ONLY integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp> \nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_HAS_NO_VARIADICS)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : std::integral_constant<bool,\n    !std::is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_rvalue_reference<_Tp>::type\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp, \n        bool = __is_referenceable<_Tp>::value || \n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> \n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\nnamespace __is_abstract_imp\n{\ntemplate <class _Tp> char  __test(_Tp (*)[1]);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};\n\ntemplate <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};\n\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<const _T1, const _T1&, 1, 0> : true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};\n#endif\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_MSVC)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !_LIBCPP_MSVC\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2 {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n    typedef typename common_type<\n        typename common_type<_Tp, _Up>::type, _Vp...\n    >::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(_Tp&&, _Arg&&);\n#else\n__is_assignable_test(_Tp, _Arg&);\n#endif\n\ntemplate <class _Arg>\nfalse_type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(__any, _Arg&&);\n#else\n__is_assignable_test(__any, _Arg&);\n#endif\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public common_type\n        <\n            decltype(_VSTD::__is_assignable_test(declval<_Tp>(), declval<_Arg>()))\n        >::type {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n    \n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!std::is_lvalue_reference<_Tp>::value,\n                  \"Can not forward an rvalue as an lvalue.\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if __has_feature(is_constructible)\n\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n//      main is_constructible test\n\ntemplate <class _Tp, class ..._Args>\ntypename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type\n__is_constructible_test(_Tp&&, _Args&& ...);\n\ntemplate <class ..._Args>\nfalse_type\n__is_constructible_test(__any, _Args&& ...);\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __libcpp_is_constructible // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))\n             >::type\n    {};\n\n//      function types are not constructible\n\ntemplate <class _Rp, class... _A1, class... _A2>\nstruct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>\n    : public false_type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\n//      Scalars and references are constructible from one arg if that arg is\n//          implicitly convertible to the scalar or reference.\n\ntemplate <class _Tp>\nstruct __is_constructible_ref\n{\n    true_type static __lxx(_Tp);\n    false_type static __lxx(...);\n};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<true, _Tp, _A0>\n    : public common_type\n             <\n                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))\n             >::type\n    {};\n\n//      Scalars and references are not constructible from multiple args.\n\ntemplate <class _Tp, class _A0, class ..._Args>\nstruct __libcpp_is_constructible<true, _Tp, _A0, _Args...>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible_void_check\n    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _Args...>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp, class... _Args>\nstruct __is_constructible_void_check<true, _Tp, _Args...>\n    : public false_type\n    {};\n\ntemplate <class ..._Args> struct __contains_void;\n\ntemplate <> struct __contains_void<> : false_type {};\n\ntemplate <class _A0, class ..._Args>\nstruct __contains_void<_A0, _Args...>\n{\n    static const bool value = is_void<_A0>::value ||\n                              __contains_void<_Args...>::value;\n};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value\n                                        || is_abstract<_Tp>::value,\n                                           _Tp, _Args...>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __libcpp_is_constructible<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\n//      Otherwise array types are not constructible by this syntax\n\ntemplate <class _Ap, size_t _Np, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[_Np], _Args...>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[], _Args...>\n    : public false_type\n    {};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n    : private __check_complete<_Fp>\n{\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    static const bool value =\n        conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// is_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TYPE_VIS_ONLY is_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TYPE_VIS_ONLY is_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;\n\n// is_nothrow_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>\n{};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\nusing _VSTD::swap;\n__nat swap(__any, __any);\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    typedef decltype(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>())) __swap1;\n    typedef decltype(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>())) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_swappable_v = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = std::is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp> constexpr bool negation_v = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","/*\r\nLodePNG version 20161127\r\n\r\nCopyright (c) 2005-2016 Lode Vandevenne\r\n\r\nThis software is provided 'as-is', without any express or implied\r\nwarranty. In no event will the authors be held liable for any damages\r\narising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any purpose,\r\nincluding commercial applications, and to alter it and redistribute it\r\nfreely, subject to the following restrictions:\r\n\r\n    1. The origin of this software must not be misrepresented; you must not\r\n    claim that you wrote the original software. If you use this software\r\n    in a product, an acknowledgment in the product documentation would be\r\n    appreciated but is not required.\r\n\r\n    2. Altered source versions must be plainly marked as such, and must not be\r\n    misrepresented as being the original software.\r\n\r\n    3. This notice may not be removed or altered from any source\r\n    distribution.\r\n*/\r\n\r\n/*\r\nThe manual and changelog are in the header file \"lodepng.h\"\r\nRename this file to lodepng.cpp to use it for C++, or to lodepng.c to use it for C.\r\n*/\r\n\r\n#include \"lodepng.h\"\r\n\r\n#include <limits.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#if defined(_MSC_VER) && (_MSC_VER >= 1310) /*Visual Studio: A few warning types are not desired here.*/\r\n#pragma warning( disable : 4244 ) /*implicit conversions: not warned by gcc -Wall -Wextra and requires too much casts*/\r\n#pragma warning( disable : 4996 ) /*VS does not like fopen, but fopen_s is not standard C so unusable here*/\r\n#endif /*_MSC_VER */\r\n\r\nconst char* LODEPNG_VERSION_STRING = \"20161127\";\r\n\r\n/*\r\nThis source file is built up in the following large parts. The code sections\r\nwith the \"LODEPNG_COMPILE_\" #defines divide this up further in an intermixed way.\r\n-Tools for C and common code for PNG and Zlib\r\n-C Code for Zlib (huffman, deflate, ...)\r\n-C Code for PNG (file format chunks, adam7, PNG filters, color conversions, ...)\r\n-The C++ wrapper around all of the above\r\n*/\r\n\r\n/*The malloc, realloc and free functions defined here with \"lodepng_\" in front\r\nof the name, so that you can easily change them to others related to your\r\nplatform if needed. Everything else in the code calls these. Pass\r\n-DLODEPNG_NO_COMPILE_ALLOCATORS to the compiler, or comment out\r\n#define LODEPNG_COMPILE_ALLOCATORS in the header, to disable the ones here and\r\ndefine them in your own project's source files without needing to change\r\nlodepng source code. Don't forget to remove \"static\" if you copypaste them\r\nfrom here.*/\r\n\r\n#ifdef LODEPNG_COMPILE_ALLOCATORS\r\nstatic void* lodepng_malloc(size_t size)\r\n{\r\n  return malloc(size);\r\n}\r\n\r\nstatic void* lodepng_realloc(void* ptr, size_t new_size)\r\n{\r\n  return realloc(ptr, new_size);\r\n}\r\n\r\nstatic void lodepng_free(void* ptr)\r\n{\r\n  free(ptr);\r\n}\r\n#else /*LODEPNG_COMPILE_ALLOCATORS*/\r\nvoid* lodepng_malloc(size_t size);\r\nvoid* lodepng_realloc(void* ptr, size_t new_size);\r\nvoid lodepng_free(void* ptr);\r\n#endif /*LODEPNG_COMPILE_ALLOCATORS*/\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* // Tools for C, and common code for PNG and Zlib.                       // */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n/*\r\nOften in case of an error a value is assigned to a variable and then it breaks\r\nout of a loop (to go to the cleanup phase of a function). This macro does that.\r\nIt makes the error handling code shorter and more readable.\r\n\r\nExample: if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83);\r\n*/\r\n#define CERROR_BREAK(errorvar, code)\\\r\n{\\\r\n  errorvar = code;\\\r\n  break;\\\r\n}\r\n\r\n/*version of CERROR_BREAK that assumes the common case where the error variable is named \"error\"*/\r\n#define ERROR_BREAK(code) CERROR_BREAK(error, code)\r\n\r\n/*Set error var to the error code, and return it.*/\r\n#define CERROR_RETURN_ERROR(errorvar, code)\\\r\n{\\\r\n  errorvar = code;\\\r\n  return code;\\\r\n}\r\n\r\n/*Try the code, if it returns error, also return the error.*/\r\n#define CERROR_TRY_RETURN(call)\\\r\n{\\\r\n  unsigned error = call;\\\r\n  if(error) return error;\\\r\n}\r\n\r\n/*Set error var to the error code, and return from the void function.*/\r\n#define CERROR_RETURN(errorvar, code)\\\r\n{\\\r\n  errorvar = code;\\\r\n  return;\\\r\n}\r\n\r\n/*\r\nAbout uivector, ucvector and string:\r\n-All of them wrap dynamic arrays or text strings in a similar way.\r\n-LodePNG was originally written in C++. The vectors replace the std::vectors that were used in the C++ version.\r\n-The string tools are made to avoid problems with compilers that declare things like strncat as deprecated.\r\n-They're not used in the interface, only internally in this file as static functions.\r\n-As with many other structs in this file, the init and cleanup functions serve as ctor and dtor.\r\n*/\r\n\r\n#ifdef LODEPNG_COMPILE_ZLIB\r\n/*dynamic vector of unsigned ints*/\r\ntypedef struct uivector\r\n{\r\n  unsigned* data;\r\n  size_t size; /*size in number of unsigned longs*/\r\n  size_t allocsize; /*allocated size in bytes*/\r\n} uivector;\r\n\r\nstatic void uivector_cleanup(void* p)\r\n{\r\n  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;\r\n  lodepng_free(((uivector*)p)->data);\r\n  ((uivector*)p)->data = NULL;\r\n}\r\n\r\n/*returns 1 if success, 0 if failure ==> nothing done*/\r\nstatic unsigned uivector_reserve(uivector* p, size_t allocsize)\r\n{\r\n  if(allocsize > p->allocsize)\r\n  {\r\n    size_t newsize = (allocsize > p->allocsize * 2) ? allocsize : (allocsize * 3 / 2);\r\n    void* data = lodepng_realloc(p->data, newsize);\r\n    if(data)\r\n    {\r\n      p->allocsize = newsize;\r\n      p->data = (unsigned*)data;\r\n    }\r\n    else return 0; /*error: not enough memory*/\r\n  }\r\n  return 1;\r\n}\r\n\r\n/*returns 1 if success, 0 if failure ==> nothing done*/\r\nstatic unsigned uivector_resize(uivector* p, size_t size)\r\n{\r\n  if(!uivector_reserve(p, size * sizeof(unsigned))) return 0;\r\n  p->size = size;\r\n  return 1; /*success*/\r\n}\r\n\r\n/*resize and give all new elements the value*/\r\nstatic unsigned uivector_resizev(uivector* p, size_t size, unsigned value)\r\n{\r\n  size_t oldsize = p->size, i;\r\n  if(!uivector_resize(p, size)) return 0;\r\n  for(i = oldsize; i < size; ++i) p->data[i] = value;\r\n  return 1;\r\n}\r\n\r\nstatic void uivector_init(uivector* p)\r\n{\r\n  p->data = NULL;\r\n  p->size = p->allocsize = 0;\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n/*returns 1 if success, 0 if failure ==> nothing done*/\r\nstatic unsigned uivector_push_back(uivector* p, unsigned c)\r\n{\r\n  if(!uivector_resize(p, p->size + 1)) return 0;\r\n  p->data[p->size - 1] = c;\r\n  return 1;\r\n}\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n#endif /*LODEPNG_COMPILE_ZLIB*/\r\n\r\n/* /////////////////////////////////////////////////////////////////////////// */\r\n\r\n/*dynamic vector of unsigned chars*/\r\ntypedef struct ucvector\r\n{\r\n  unsigned char* data;\r\n  size_t size; /*used size*/\r\n  size_t allocsize; /*allocated size*/\r\n} ucvector;\r\n\r\n/*returns 1 if success, 0 if failure ==> nothing done*/\r\nstatic unsigned ucvector_reserve(ucvector* p, size_t allocsize)\r\n{\r\n  if(allocsize > p->allocsize)\r\n  {\r\n    size_t newsize = (allocsize > p->allocsize * 2) ? allocsize : (allocsize * 3 / 2);\r\n    void* data = lodepng_realloc(p->data, newsize);\r\n    if(data)\r\n    {\r\n      p->allocsize = newsize;\r\n      p->data = (unsigned char*)data;\r\n    }\r\n    else return 0; /*error: not enough memory*/\r\n  }\r\n  return 1;\r\n}\r\n\r\n/*returns 1 if success, 0 if failure ==> nothing done*/\r\nstatic unsigned ucvector_resize(ucvector* p, size_t size)\r\n{\r\n  if(!ucvector_reserve(p, size * sizeof(unsigned char))) return 0;\r\n  p->size = size;\r\n  return 1; /*success*/\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_PNG\r\n\r\nstatic void ucvector_cleanup(void* p)\r\n{\r\n  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;\r\n  lodepng_free(((ucvector*)p)->data);\r\n  ((ucvector*)p)->data = NULL;\r\n}\r\n\r\nstatic void ucvector_init(ucvector* p)\r\n{\r\n  p->data = NULL;\r\n  p->size = p->allocsize = 0;\r\n}\r\n#endif /*LODEPNG_COMPILE_PNG*/\r\n\r\n#ifdef LODEPNG_COMPILE_ZLIB\r\n/*you can both convert from vector to buffer&size and vica versa. If you use\r\ninit_buffer to take over a buffer and size, it is not needed to use cleanup*/\r\nstatic void ucvector_init_buffer(ucvector* p, unsigned char* buffer, size_t size)\r\n{\r\n  p->data = buffer;\r\n  p->allocsize = p->size = size;\r\n}\r\n#endif /*LODEPNG_COMPILE_ZLIB*/\r\n\r\n#if (defined(LODEPNG_COMPILE_PNG) && defined(LODEPNG_COMPILE_ANCILLARY_CHUNKS)) || defined(LODEPNG_COMPILE_ENCODER)\r\n/*returns 1 if success, 0 if failure ==> nothing done*/\r\nstatic unsigned ucvector_push_back(ucvector* p, unsigned char c)\r\n{\r\n  if(!ucvector_resize(p, p->size + 1)) return 0;\r\n  p->data[p->size - 1] = c;\r\n  return 1;\r\n}\r\n#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/\r\n\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n#ifdef LODEPNG_COMPILE_PNG\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n/*returns 1 if success, 0 if failure ==> nothing done*/\r\nstatic unsigned string_resize(char** out, size_t size)\r\n{\r\n  char* data = (char*)lodepng_realloc(*out, size + 1);\r\n  if(data)\r\n  {\r\n    data[size] = 0; /*null termination char*/\r\n    *out = data;\r\n  }\r\n  return data != 0;\r\n}\r\n\r\n/*init a {char*, size_t} pair for use as string*/\r\nstatic void string_init(char** out)\r\n{\r\n  *out = NULL;\r\n  string_resize(out, 0);\r\n}\r\n\r\n/*free the above pair again*/\r\nstatic void string_cleanup(char** out)\r\n{\r\n  lodepng_free(*out);\r\n  *out = NULL;\r\n}\r\n\r\nstatic void string_set(char** out, const char* in)\r\n{\r\n  size_t insize = strlen(in), i;\r\n  if(string_resize(out, insize))\r\n  {\r\n    for(i = 0; i != insize; ++i)\r\n    {\r\n      (*out)[i] = in[i];\r\n    }\r\n  }\r\n}\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n#endif /*LODEPNG_COMPILE_PNG*/\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\nunsigned lodepng_read32bitInt(const unsigned char* buffer)\r\n{\r\n  return (unsigned)((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]);\r\n}\r\n\r\n#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)\r\n/*buffer must have at least 4 allocated bytes available*/\r\nstatic void lodepng_set32bitInt(unsigned char* buffer, unsigned value)\r\n{\r\n  buffer[0] = (unsigned char)((value >> 24) & 0xff);\r\n  buffer[1] = (unsigned char)((value >> 16) & 0xff);\r\n  buffer[2] = (unsigned char)((value >>  8) & 0xff);\r\n  buffer[3] = (unsigned char)((value      ) & 0xff);\r\n}\r\n#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\nstatic void lodepng_add32bitInt(ucvector* buffer, unsigned value)\r\n{\r\n  ucvector_resize(buffer, buffer->size + 4); /*todo: give error if resize failed*/\r\n  lodepng_set32bitInt(&buffer->data[buffer->size - 4], value);\r\n}\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / File IO                                                                / */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n#ifdef LODEPNG_COMPILE_DISK\r\n\r\n/* returns negative value on error. This should be pure C compatible, so no fstat. */\r\nstatic long lodepng_filesize(const char* filename)\r\n{\r\n  FILE* file;\r\n  long size;\r\n  file = fopen(filename, \"rb\");\r\n  if(!file) return -1;\r\n\r\n  if(fseek(file, 0, SEEK_END) != 0)\r\n  {\r\n    fclose(file);\r\n    return -1;\r\n  }\r\n\r\n  size = ftell(file);\r\n  /* It may give LONG_MAX as directory size, this is invalid for us. */\r\n  if(size == LONG_MAX) size = -1;\r\n\r\n  fclose(file);\r\n  return size;\r\n}\r\n\r\n/* load file into buffer that already has the correct allocated size. Returns error code.*/\r\nstatic unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename)\r\n{\r\n  FILE* file;\r\n  size_t readsize;\r\n  file = fopen(filename, \"rb\");\r\n  if(!file) return 78;\r\n\r\n  readsize = fread(out, 1, size, file);\r\n  fclose(file);\r\n\r\n  if (readsize != size) return 78;\r\n  return 0;\r\n}\r\n\r\nunsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename)\r\n{\r\n  long size = lodepng_filesize(filename);\r\n  if (size < 0) return 78;\r\n  *outsize = (size_t)size;\r\n\r\n  *out = (unsigned char*)lodepng_malloc((size_t)size);\r\n  if(!(*out) && size > 0) return 83; /*the above malloc failed*/\r\n\r\n  return lodepng_buffer_file(*out, (size_t)size, filename);\r\n}\r\n\r\n/*write given buffer to the file, overwriting the file, it doesn't append to it.*/\r\nunsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename)\r\n{\r\n  FILE* file;\r\n  file = fopen(filename, \"wb\" );\r\n  if(!file) return 79;\r\n  fwrite((char*)buffer , 1 , buffersize, file);\r\n  fclose(file);\r\n  return 0;\r\n}\r\n\r\n#endif /*LODEPNG_COMPILE_DISK*/\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* // End of common code and tools. Begin of Zlib related code.            // */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n#ifdef LODEPNG_COMPILE_ZLIB\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n/*TODO: this ignores potential out of memory errors*/\r\n#define addBitToStream(/*size_t**/ bitpointer, /*ucvector**/ bitstream, /*unsigned char*/ bit)\\\r\n{\\\r\n  /*add a new byte at the end*/\\\r\n  if(((*bitpointer) & 7) == 0) ucvector_push_back(bitstream, (unsigned char)0);\\\r\n  /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/\\\r\n  (bitstream->data[bitstream->size - 1]) |= (bit << ((*bitpointer) & 0x7));\\\r\n  ++(*bitpointer);\\\r\n}\r\n\r\nstatic void addBitsToStream(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)\r\n{\r\n  size_t i;\r\n  for(i = 0; i != nbits; ++i) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> i) & 1));\r\n}\r\n\r\nstatic void addBitsToStreamReversed(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)\r\n{\r\n  size_t i;\r\n  for(i = 0; i != nbits; ++i) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> (nbits - 1 - i)) & 1));\r\n}\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n\r\n#define READBIT(bitpointer, bitstream) ((bitstream[bitpointer >> 3] >> (bitpointer & 0x7)) & (unsigned char)1)\r\n\r\nstatic unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)\r\n{\r\n  unsigned char result = (unsigned char)(READBIT(*bitpointer, bitstream));\r\n  ++(*bitpointer);\r\n  return result;\r\n}\r\n\r\nstatic unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)\r\n{\r\n  unsigned result = 0, i;\r\n  for(i = 0; i != nbits; ++i)\r\n  {\r\n    result += ((unsigned)READBIT(*bitpointer, bitstream)) << i;\r\n    ++(*bitpointer);\r\n  }\r\n  return result;\r\n}\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / Deflate - Huffman                                                      / */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n#define FIRST_LENGTH_CODE_INDEX 257\r\n#define LAST_LENGTH_CODE_INDEX 285\r\n/*256 literals, the end code, some length codes, and 2 unused codes*/\r\n#define NUM_DEFLATE_CODE_SYMBOLS 288\r\n/*the distance codes have their own symbols, 30 used, 2 unused*/\r\n#define NUM_DISTANCE_SYMBOLS 32\r\n/*the code length codes. 0-15: code lengths, 16: copy previous 3-6 times, 17: 3-10 zeros, 18: 11-138 zeros*/\r\n#define NUM_CODE_LENGTH_CODES 19\r\n\r\n/*the base lengths represented by codes 257-285*/\r\nstatic const unsigned LENGTHBASE[29]\r\n  = {3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,\r\n     67, 83, 99, 115, 131, 163, 195, 227, 258};\r\n\r\n/*the extra bits used by codes 257-285 (added to base length)*/\r\nstatic const unsigned LENGTHEXTRA[29]\r\n  = {0, 0, 0, 0, 0, 0, 0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,\r\n      4,  4,  4,   4,   5,   5,   5,   5,   0};\r\n\r\n/*the base backwards distances (the bits of distance codes appear after length codes and use their own huffman tree)*/\r\nstatic const unsigned DISTANCEBASE[30]\r\n  = {1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,\r\n     769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};\r\n\r\n/*the extra bits of backwards distances (added to base)*/\r\nstatic const unsigned DISTANCEEXTRA[30]\r\n  = {0, 0, 0, 0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,   6,   6,   7,   7,   8,\r\n       8,    9,    9,   10,   10,   11,   11,   12,    12,    13,    13};\r\n\r\n/*the order in which \"code length alphabet code lengths\" are stored, out of this\r\nthe huffman tree of the dynamic huffman tree lengths is generated*/\r\nstatic const unsigned CLCL_ORDER[NUM_CODE_LENGTH_CODES]\r\n  = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n/*\r\nHuffman tree struct, containing multiple representations of the tree\r\n*/\r\ntypedef struct HuffmanTree\r\n{\r\n  unsigned* tree2d;\r\n  unsigned* tree1d;\r\n  unsigned* lengths; /*the lengths of the codes of the 1d-tree*/\r\n  unsigned maxbitlen; /*maximum number of bits a single code can get*/\r\n  unsigned numcodes; /*number of symbols in the alphabet = number of codes*/\r\n} HuffmanTree;\r\n\r\n/*function used for debug purposes to draw the tree in ascii art with C++*/\r\n/*\r\nstatic void HuffmanTree_draw(HuffmanTree* tree)\r\n{\r\n  std::cout << \"tree. length: \" << tree->numcodes << \" maxbitlen: \" << tree->maxbitlen << std::endl;\r\n  for(size_t i = 0; i != tree->tree1d.size; ++i)\r\n  {\r\n    if(tree->lengths.data[i])\r\n      std::cout << i << \" \" << tree->tree1d.data[i] << \" \" << tree->lengths.data[i] << std::endl;\r\n  }\r\n  std::cout << std::endl;\r\n}*/\r\n\r\nstatic void HuffmanTree_init(HuffmanTree* tree)\r\n{\r\n  tree->tree2d = 0;\r\n  tree->tree1d = 0;\r\n  tree->lengths = 0;\r\n}\r\n\r\nstatic void HuffmanTree_cleanup(HuffmanTree* tree)\r\n{\r\n  lodepng_free(tree->tree2d);\r\n  lodepng_free(tree->tree1d);\r\n  lodepng_free(tree->lengths);\r\n}\r\n\r\n/*the tree representation used by the decoder. return value is error*/\r\nstatic unsigned HuffmanTree_make2DTree(HuffmanTree* tree)\r\n{\r\n  unsigned nodefilled = 0; /*up to which node it is filled*/\r\n  unsigned treepos = 0; /*position in the tree (1 of the numcodes columns)*/\r\n  unsigned n, i;\r\n\r\n  tree->tree2d = (unsigned*)lodepng_malloc(tree->numcodes * 2 * sizeof(unsigned));\r\n  if(!tree->tree2d) return 83; /*alloc fail*/\r\n\r\n  /*\r\n  convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means\r\n  uninited, a value >= numcodes is an address to another bit, a value < numcodes\r\n  is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as\r\n  many columns as codes - 1.\r\n  A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.\r\n  Here, the internal nodes are stored (what their 0 and 1 option point to).\r\n  There is only memory for such good tree currently, if there are more nodes\r\n  (due to too long length codes), error 55 will happen\r\n  */\r\n  for(n = 0; n < tree->numcodes * 2; ++n)\r\n  {\r\n    tree->tree2d[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/\r\n  }\r\n\r\n  for(n = 0; n < tree->numcodes; ++n) /*the codes*/\r\n  {\r\n    for(i = 0; i != tree->lengths[n]; ++i) /*the bits for this code*/\r\n    {\r\n      unsigned char bit = (unsigned char)((tree->tree1d[n] >> (tree->lengths[n] - i - 1)) & 1);\r\n      /*oversubscribed, see comment in lodepng_error_text*/\r\n      if(treepos > 2147483647 || treepos + 2 > tree->numcodes) return 55;\r\n      if(tree->tree2d[2 * treepos + bit] == 32767) /*not yet filled in*/\r\n      {\r\n        if(i + 1 == tree->lengths[n]) /*last bit*/\r\n        {\r\n          tree->tree2d[2 * treepos + bit] = n; /*put the current code in it*/\r\n          treepos = 0;\r\n        }\r\n        else\r\n        {\r\n          /*put address of the next step in here, first that address has to be found of course\r\n          (it's just nodefilled + 1)...*/\r\n          ++nodefilled;\r\n          /*addresses encoded with numcodes added to it*/\r\n          tree->tree2d[2 * treepos + bit] = nodefilled + tree->numcodes;\r\n          treepos = nodefilled;\r\n        }\r\n      }\r\n      else treepos = tree->tree2d[2 * treepos + bit] - tree->numcodes;\r\n    }\r\n  }\r\n\r\n  for(n = 0; n < tree->numcodes * 2; ++n)\r\n  {\r\n    if(tree->tree2d[n] == 32767) tree->tree2d[n] = 0; /*remove possible remaining 32767's*/\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/*\r\nSecond step for the ...makeFromLengths and ...makeFromFrequencies functions.\r\nnumcodes, lengths and maxbitlen must already be filled in correctly. return\r\nvalue is error.\r\n*/\r\nstatic unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree)\r\n{\r\n  uivector blcount;\r\n  uivector nextcode;\r\n  unsigned error = 0;\r\n  unsigned bits, n;\r\n\r\n  uivector_init(&blcount);\r\n  uivector_init(&nextcode);\r\n\r\n  tree->tree1d = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));\r\n  if(!tree->tree1d) error = 83; /*alloc fail*/\r\n\r\n  if(!uivector_resizev(&blcount, tree->maxbitlen + 1, 0)\r\n  || !uivector_resizev(&nextcode, tree->maxbitlen + 1, 0))\r\n    error = 83; /*alloc fail*/\r\n\r\n  if(!error)\r\n  {\r\n    /*step 1: count number of instances of each code length*/\r\n    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount.data[tree->lengths[bits]];\r\n    /*step 2: generate the nextcode values*/\r\n    for(bits = 1; bits <= tree->maxbitlen; ++bits)\r\n    {\r\n      nextcode.data[bits] = (nextcode.data[bits - 1] + blcount.data[bits - 1]) << 1;\r\n    }\r\n    /*step 3: generate all the codes*/\r\n    for(n = 0; n != tree->numcodes; ++n)\r\n    {\r\n      if(tree->lengths[n] != 0) tree->tree1d[n] = nextcode.data[tree->lengths[n]]++;\r\n    }\r\n  }\r\n\r\n  uivector_cleanup(&blcount);\r\n  uivector_cleanup(&nextcode);\r\n\r\n  if(!error) return HuffmanTree_make2DTree(tree);\r\n  else return error;\r\n}\r\n\r\n/*\r\ngiven the code lengths (as stored in the PNG file), generate the tree as defined\r\nby Deflate. maxbitlen is the maximum bits that a code in the tree can have.\r\nreturn value is error.\r\n*/\r\nstatic unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,\r\n                                            size_t numcodes, unsigned maxbitlen)\r\n{\r\n  unsigned i;\r\n  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));\r\n  if(!tree->lengths) return 83; /*alloc fail*/\r\n  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];\r\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\r\n  tree->maxbitlen = maxbitlen;\r\n  return HuffmanTree_makeFromLengths2(tree);\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n\r\n/*BPM: Boundary Package Merge, see \"A Fast and Space-Economical Algorithm for Length-Limited Coding\",\r\nJyrki Katajainen, Alistair Moffat, Andrew Turpin, 1995.*/\r\n\r\n/*chain node for boundary package merge*/\r\ntypedef struct BPMNode\r\n{\r\n  int weight; /*the sum of all weights in this chain*/\r\n  unsigned index; /*index of this leaf node (called \"count\" in the paper)*/\r\n  struct BPMNode* tail; /*the next nodes in this chain (null if last)*/\r\n  int in_use;\r\n} BPMNode;\r\n\r\n/*lists of chains*/\r\ntypedef struct BPMLists\r\n{\r\n  /*memory pool*/\r\n  unsigned memsize;\r\n  BPMNode* memory;\r\n  unsigned numfree;\r\n  unsigned nextfree;\r\n  BPMNode** freelist;\r\n  /*two heads of lookahead chains per list*/\r\n  unsigned listsize;\r\n  BPMNode** chains0;\r\n  BPMNode** chains1;\r\n} BPMLists;\r\n\r\n/*creates a new chain node with the given parameters, from the memory in the lists */\r\nstatic BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail)\r\n{\r\n  unsigned i;\r\n  BPMNode* result;\r\n\r\n  /*memory full, so garbage collect*/\r\n  if(lists->nextfree >= lists->numfree)\r\n  {\r\n    /*mark only those that are in use*/\r\n    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;\r\n    for(i = 0; i != lists->listsize; ++i)\r\n    {\r\n      BPMNode* node;\r\n      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;\r\n      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;\r\n    }\r\n    /*collect those that are free*/\r\n    lists->numfree = 0;\r\n    for(i = 0; i != lists->memsize; ++i)\r\n    {\r\n      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];\r\n    }\r\n    lists->nextfree = 0;\r\n  }\r\n\r\n  result = lists->freelist[lists->nextfree++];\r\n  result->weight = weight;\r\n  result->index = index;\r\n  result->tail = tail;\r\n  return result;\r\n}\r\n\r\n/*sort the leaves with stable mergesort*/\r\nstatic void bpmnode_sort(BPMNode* leaves, size_t num)\r\n{\r\n  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);\r\n  size_t width, counter = 0;\r\n  for(width = 1; width < num; width *= 2)\r\n  {\r\n    BPMNode* a = (counter & 1) ? mem : leaves;\r\n    BPMNode* b = (counter & 1) ? leaves : mem;\r\n    size_t p;\r\n    for(p = 0; p < num; p += 2 * width)\r\n    {\r\n      size_t q = (p + width > num) ? num : (p + width);\r\n      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);\r\n      size_t i = p, j = q, k;\r\n      for(k = p; k < r; k++)\r\n      {\r\n        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];\r\n        else b[k] = a[j++];\r\n      }\r\n    }\r\n    counter++;\r\n  }\r\n  if(counter & 1) memcpy(leaves, mem, sizeof(*leaves) * num);\r\n  lodepng_free(mem);\r\n}\r\n\r\n/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/\r\nstatic void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num)\r\n{\r\n  unsigned lastindex = lists->chains1[c]->index;\r\n\r\n  if(c == 0)\r\n  {\r\n    if(lastindex >= numpresent) return;\r\n    lists->chains0[c] = lists->chains1[c];\r\n    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);\r\n  }\r\n  else\r\n  {\r\n    /*sum of the weights of the head nodes of the previous lookahead chains.*/\r\n    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;\r\n    lists->chains0[c] = lists->chains1[c];\r\n    if(lastindex < numpresent && sum > leaves[lastindex].weight)\r\n    {\r\n      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);\r\n      return;\r\n    }\r\n    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);\r\n    /*in the end we are only interested in the chain of the last list, so no\r\n    need to recurse if we're at the last one (this gives measurable speedup)*/\r\n    if(num + 1 < (int)(2 * numpresent - 2))\r\n    {\r\n      boundaryPM(lists, leaves, numpresent, c - 1, num);\r\n      boundaryPM(lists, leaves, numpresent, c - 1, num);\r\n    }\r\n  }\r\n}\r\n\r\nunsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,\r\n                                      size_t numcodes, unsigned maxbitlen)\r\n{\r\n  unsigned error = 0;\r\n  unsigned i;\r\n  size_t numpresent = 0; /*number of symbols with non-zero frequency*/\r\n  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/\r\n\r\n  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/\r\n  if((1u << maxbitlen) < numcodes) return 80; /*error: represent all symbols*/\r\n\r\n  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));\r\n  if(!leaves) return 83; /*alloc fail*/\r\n\r\n  for(i = 0; i != numcodes; ++i)\r\n  {\r\n    if(frequencies[i] > 0)\r\n    {\r\n      leaves[numpresent].weight = (int)frequencies[i];\r\n      leaves[numpresent].index = i;\r\n      ++numpresent;\r\n    }\r\n  }\r\n\r\n  for(i = 0; i != numcodes; ++i) lengths[i] = 0;\r\n\r\n  /*ensure at least two present symbols. There should be at least one symbol\r\n  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To\r\n  make these work as well ensure there are at least two symbols. The\r\n  Package-Merge code below also doesn't work correctly if there's only one\r\n  symbol, it'd give it the theoritical 0 bits but in practice zlib wants 1 bit*/\r\n  if(numpresent == 0)\r\n  {\r\n    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/\r\n  }\r\n  else if(numpresent == 1)\r\n  {\r\n    lengths[leaves[0].index] = 1;\r\n    lengths[leaves[0].index == 0 ? 1 : 0] = 1;\r\n  }\r\n  else\r\n  {\r\n    BPMLists lists;\r\n    BPMNode* node;\r\n\r\n    bpmnode_sort(leaves, numpresent);\r\n\r\n    lists.listsize = maxbitlen;\r\n    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);\r\n    lists.nextfree = 0;\r\n    lists.numfree = lists.memsize;\r\n    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));\r\n    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));\r\n    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));\r\n    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));\r\n    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/\r\n\r\n    if(!error)\r\n    {\r\n      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];\r\n\r\n      bpmnode_create(&lists, leaves[0].weight, 1, 0);\r\n      bpmnode_create(&lists, leaves[1].weight, 2, 0);\r\n\r\n      for(i = 0; i != lists.listsize; ++i)\r\n      {\r\n        lists.chains0[i] = &lists.memory[0];\r\n        lists.chains1[i] = &lists.memory[1];\r\n      }\r\n\r\n      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/\r\n      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);\r\n\r\n      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail)\r\n      {\r\n        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];\r\n      }\r\n    }\r\n\r\n    lodepng_free(lists.memory);\r\n    lodepng_free(lists.freelist);\r\n    lodepng_free(lists.chains0);\r\n    lodepng_free(lists.chains1);\r\n  }\r\n\r\n  lodepng_free(leaves);\r\n  return error;\r\n}\r\n\r\n/*Create the Huffman tree given the symbol frequencies*/\r\nstatic unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\r\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)\r\n{\r\n  unsigned error = 0;\r\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/\r\n  tree->maxbitlen = maxbitlen;\r\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\r\n  tree->lengths = (unsigned*)lodepng_realloc(tree->lengths, numcodes * sizeof(unsigned));\r\n  if(!tree->lengths) return 83; /*alloc fail*/\r\n  /*initialize all lengths to 0*/\r\n  memset(tree->lengths, 0, numcodes * sizeof(unsigned));\r\n\r\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\r\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\r\n  return error;\r\n}\r\n\r\nstatic unsigned HuffmanTree_getCode(const HuffmanTree* tree, unsigned index)\r\n{\r\n  return tree->tree1d[index];\r\n}\r\n\r\nstatic unsigned HuffmanTree_getLength(const HuffmanTree* tree, unsigned index)\r\n{\r\n  return tree->lengths[index];\r\n}\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/\r\nstatic unsigned generateFixedLitLenTree(HuffmanTree* tree)\r\n{\r\n  unsigned i, error = 0;\r\n  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));\r\n  if(!bitlen) return 83; /*alloc fail*/\r\n\r\n  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/\r\n  for(i =   0; i <= 143; ++i) bitlen[i] = 8;\r\n  for(i = 144; i <= 255; ++i) bitlen[i] = 9;\r\n  for(i = 256; i <= 279; ++i) bitlen[i] = 7;\r\n  for(i = 280; i <= 287; ++i) bitlen[i] = 8;\r\n\r\n  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);\r\n\r\n  lodepng_free(bitlen);\r\n  return error;\r\n}\r\n\r\n/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/\r\nstatic unsigned generateFixedDistanceTree(HuffmanTree* tree)\r\n{\r\n  unsigned i, error = 0;\r\n  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));\r\n  if(!bitlen) return 83; /*alloc fail*/\r\n\r\n  /*there are 32 distance codes, but 30-31 are unused*/\r\n  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;\r\n  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);\r\n\r\n  lodepng_free(bitlen);\r\n  return error;\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n\r\n/*\r\nreturns the code, or (unsigned)(-1) if error happened\r\ninbitlength is the length of the complete buffer, in bits (so its byte length times 8)\r\n*/\r\nstatic unsigned huffmanDecodeSymbol(const unsigned char* in, size_t* bp,\r\n                                    const HuffmanTree* codetree, size_t inbitlength)\r\n{\r\n  unsigned treepos = 0, ct;\r\n  for(;;)\r\n  {\r\n    if(*bp >= inbitlength) return (unsigned)(-1); /*error: end of input memory reached without endcode*/\r\n    /*\r\n    decode the symbol from the tree. The \"readBitFromStream\" code is inlined in\r\n    the expression below because this is the biggest bottleneck while decoding\r\n    */\r\n    ct = codetree->tree2d[(treepos << 1) + READBIT(*bp, in)];\r\n    ++(*bp);\r\n    if(ct < codetree->numcodes) return ct; /*the symbol is decoded, return it*/\r\n    else treepos = ct - codetree->numcodes; /*symbol not yet decoded, instead move tree position*/\r\n\r\n    if(treepos >= codetree->numcodes) return (unsigned)(-1); /*error: it appeared outside the codetree*/\r\n  }\r\n}\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / Inflator (Decompressor)                                                / */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n/*get the tree of a deflated block with fixed tree, as specified in the deflate specification*/\r\nstatic void getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d)\r\n{\r\n  /*TODO: check for out of memory errors*/\r\n  generateFixedLitLenTree(tree_ll);\r\n  generateFixedDistanceTree(tree_d);\r\n}\r\n\r\n/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/\r\nstatic unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,\r\n                                      const unsigned char* in, size_t* bp, size_t inlength)\r\n{\r\n  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/\r\n  unsigned error = 0;\r\n  unsigned n, HLIT, HDIST, HCLEN, i;\r\n  size_t inbitlength = inlength * 8;\r\n\r\n  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/\r\n  unsigned* bitlen_ll = 0; /*lit,len code lengths*/\r\n  unsigned* bitlen_d = 0; /*dist code lengths*/\r\n  /*code length code lengths (\"clcl\"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/\r\n  unsigned* bitlen_cl = 0;\r\n  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/\r\n\r\n  if((*bp) + 14 > (inlength << 3)) return 49; /*error: the bit pointer is or will go past the memory*/\r\n\r\n  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/\r\n  HLIT =  readBitsFromStream(bp, in, 5) + 257;\r\n  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/\r\n  HDIST = readBitsFromStream(bp, in, 5) + 1;\r\n  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/\r\n  HCLEN = readBitsFromStream(bp, in, 4) + 4;\r\n\r\n  if((*bp) + HCLEN * 3 > (inlength << 3)) return 50; /*error: the bit pointer is or will go past the memory*/\r\n\r\n  HuffmanTree_init(&tree_cl);\r\n\r\n  while(!error)\r\n  {\r\n    /*read the code length codes out of 3 * (amount of code length codes) bits*/\r\n\r\n    bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));\r\n    if(!bitlen_cl) ERROR_BREAK(83 /*alloc fail*/);\r\n\r\n    for(i = 0; i != NUM_CODE_LENGTH_CODES; ++i)\r\n    {\r\n      if(i < HCLEN) bitlen_cl[CLCL_ORDER[i]] = readBitsFromStream(bp, in, 3);\r\n      else bitlen_cl[CLCL_ORDER[i]] = 0; /*if not, it must stay 0*/\r\n    }\r\n\r\n    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);\r\n    if(error) break;\r\n\r\n    /*now we can use this tree to read the lengths for the tree that this function will return*/\r\n    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));\r\n    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));\r\n    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);\r\n    for(i = 0; i != NUM_DEFLATE_CODE_SYMBOLS; ++i) bitlen_ll[i] = 0;\r\n    for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen_d[i] = 0;\r\n\r\n    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/\r\n    i = 0;\r\n    while(i < HLIT + HDIST)\r\n    {\r\n      unsigned code = huffmanDecodeSymbol(in, bp, &tree_cl, inbitlength);\r\n      if(code <= 15) /*a length code*/\r\n      {\r\n        if(i < HLIT) bitlen_ll[i] = code;\r\n        else bitlen_d[i - HLIT] = code;\r\n        ++i;\r\n      }\r\n      else if(code == 16) /*repeat previous*/\r\n      {\r\n        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/\r\n        unsigned value; /*set value to the previous code*/\r\n\r\n        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/\r\n\r\n        if((*bp + 2) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/\r\n        replength += readBitsFromStream(bp, in, 2);\r\n\r\n        if(i < HLIT + 1) value = bitlen_ll[i - 1];\r\n        else value = bitlen_d[i - HLIT - 1];\r\n        /*repeat this value in the next lengths*/\r\n        for(n = 0; n < replength; ++n)\r\n        {\r\n          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/\r\n          if(i < HLIT) bitlen_ll[i] = value;\r\n          else bitlen_d[i - HLIT] = value;\r\n          ++i;\r\n        }\r\n      }\r\n      else if(code == 17) /*repeat \"0\" 3-10 times*/\r\n      {\r\n        unsigned replength = 3; /*read in the bits that indicate repeat length*/\r\n        if((*bp + 3) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/\r\n        replength += readBitsFromStream(bp, in, 3);\r\n\r\n        /*repeat this value in the next lengths*/\r\n        for(n = 0; n < replength; ++n)\r\n        {\r\n          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/\r\n\r\n          if(i < HLIT) bitlen_ll[i] = 0;\r\n          else bitlen_d[i - HLIT] = 0;\r\n          ++i;\r\n        }\r\n      }\r\n      else if(code == 18) /*repeat \"0\" 11-138 times*/\r\n      {\r\n        unsigned replength = 11; /*read in the bits that indicate repeat length*/\r\n        if((*bp + 7) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/\r\n        replength += readBitsFromStream(bp, in, 7);\r\n\r\n        /*repeat this value in the next lengths*/\r\n        for(n = 0; n < replength; ++n)\r\n        {\r\n          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/\r\n\r\n          if(i < HLIT) bitlen_ll[i] = 0;\r\n          else bitlen_d[i - HLIT] = 0;\r\n          ++i;\r\n        }\r\n      }\r\n      else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/\r\n      {\r\n        if(code == (unsigned)(-1))\r\n        {\r\n          /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\r\n          (10=no endcode, 11=wrong jump outside of tree)*/\r\n          error = (*bp) > inbitlength ? 10 : 11;\r\n        }\r\n        else error = 16; /*unexisting code, this can never happen*/\r\n        break;\r\n      }\r\n    }\r\n    if(error) break;\r\n\r\n    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/\r\n\r\n    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/\r\n    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);\r\n    if(error) break;\r\n    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);\r\n\r\n    break; /*end of error-while*/\r\n  }\r\n\r\n  lodepng_free(bitlen_cl);\r\n  lodepng_free(bitlen_ll);\r\n  lodepng_free(bitlen_d);\r\n  HuffmanTree_cleanup(&tree_cl);\r\n\r\n  return error;\r\n}\r\n\r\n/*inflate a block with dynamic of fixed Huffman tree*/\r\nstatic unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp,\r\n                                    size_t* pos, size_t inlength, unsigned btype)\r\n{\r\n  unsigned error = 0;\r\n  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/\r\n  HuffmanTree tree_d; /*the huffman tree for distance codes*/\r\n  size_t inbitlength = inlength * 8;\r\n\r\n  HuffmanTree_init(&tree_ll);\r\n  HuffmanTree_init(&tree_d);\r\n\r\n  if(btype == 1) getTreeInflateFixed(&tree_ll, &tree_d);\r\n  else if(btype == 2) error = getTreeInflateDynamic(&tree_ll, &tree_d, in, bp, inlength);\r\n\r\n  while(!error) /*decode all symbols until end reached, breaks at end code*/\r\n  {\r\n    /*code_ll is literal, length or end code*/\r\n    unsigned code_ll = huffmanDecodeSymbol(in, bp, &tree_ll, inbitlength);\r\n    if(code_ll <= 255) /*literal symbol*/\r\n    {\r\n      /*ucvector_push_back would do the same, but for some reason the two lines below run 10% faster*/\r\n      if(!ucvector_resize(out, (*pos) + 1)) ERROR_BREAK(83 /*alloc fail*/);\r\n      out->data[*pos] = (unsigned char)code_ll;\r\n      ++(*pos);\r\n    }\r\n    else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/\r\n    {\r\n      unsigned code_d, distance;\r\n      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/\r\n      size_t start, forward, backward, length;\r\n\r\n      /*part 1: get length base*/\r\n      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];\r\n\r\n      /*part 2: get extra bits and add the value of that to length*/\r\n      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];\r\n      if((*bp + numextrabits_l) > inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/\r\n      length += readBitsFromStream(bp, in, numextrabits_l);\r\n\r\n      /*part 3: get distance code*/\r\n      code_d = huffmanDecodeSymbol(in, bp, &tree_d, inbitlength);\r\n      if(code_d > 29)\r\n      {\r\n        if(code_ll == (unsigned)(-1)) /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/\r\n        {\r\n          /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\r\n          (10=no endcode, 11=wrong jump outside of tree)*/\r\n          error = (*bp) > inlength * 8 ? 10 : 11;\r\n        }\r\n        else error = 18; /*error: invalid distance code (30-31 are never used)*/\r\n        break;\r\n      }\r\n      distance = DISTANCEBASE[code_d];\r\n\r\n      /*part 4: get extra bits from distance*/\r\n      numextrabits_d = DISTANCEEXTRA[code_d];\r\n      if((*bp + numextrabits_d) > inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/\r\n      distance += readBitsFromStream(bp, in, numextrabits_d);\r\n\r\n      /*part 5: fill in all the out[n] values based on the length and dist*/\r\n      start = (*pos);\r\n      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/\r\n      backward = start - distance;\r\n\r\n      if(!ucvector_resize(out, (*pos) + length)) ERROR_BREAK(83 /*alloc fail*/);\r\n      if (distance < length) {\r\n        for(forward = 0; forward < length; ++forward)\r\n        {\r\n          out->data[(*pos)++] = out->data[backward++];\r\n        }\r\n      } else {\r\n        memcpy(out->data + *pos, out->data + backward, length);\r\n        *pos += length;\r\n      }\r\n    }\r\n    else if(code_ll == 256)\r\n    {\r\n      break; /*end code, break the loop*/\r\n    }\r\n    else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/\r\n    {\r\n      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\r\n      (10=no endcode, 11=wrong jump outside of tree)*/\r\n      error = ((*bp) > inlength * 8) ? 10 : 11;\r\n      break;\r\n    }\r\n  }\r\n\r\n  HuffmanTree_cleanup(&tree_ll);\r\n  HuffmanTree_cleanup(&tree_d);\r\n\r\n  return error;\r\n}\r\n\r\nstatic unsigned inflateNoCompression(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength)\r\n{\r\n  size_t p;\r\n  unsigned LEN, NLEN, n, error = 0;\r\n\r\n  /*go to first boundary of byte*/\r\n  while(((*bp) & 0x7) != 0) ++(*bp);\r\n  p = (*bp) / 8; /*byte position*/\r\n\r\n  /*read LEN (2 bytes) and NLEN (2 bytes)*/\r\n  if(p + 4 >= inlength) return 52; /*error, bit pointer will jump past memory*/\r\n  LEN = in[p] + 256u * in[p + 1]; p += 2;\r\n  NLEN = in[p] + 256u * in[p + 1]; p += 2;\r\n\r\n  /*check if 16-bit NLEN is really the one's complement of LEN*/\r\n  if(LEN + NLEN != 65535) return 21; /*error: NLEN is not one's complement of LEN*/\r\n\r\n  if(!ucvector_resize(out, (*pos) + LEN)) return 83; /*alloc fail*/\r\n\r\n  /*read the literal data: LEN bytes are now stored in the out buffer*/\r\n  if(p + LEN > inlength) return 23; /*error: reading outside of in buffer*/\r\n  for(n = 0; n < LEN; ++n) out->data[(*pos)++] = in[p++];\r\n\r\n  (*bp) = p * 8;\r\n\r\n  return error;\r\n}\r\n\r\nstatic unsigned lodepng_inflatev(ucvector* out,\r\n                                 const unsigned char* in, size_t insize,\r\n                                 const LodePNGDecompressSettings* settings)\r\n{\r\n  /*bit pointer in the \"in\" data, current byte is bp >> 3, current bit is bp & 0x7 (from lsb to msb of the byte)*/\r\n  size_t bp = 0;\r\n  unsigned BFINAL = 0;\r\n  size_t pos = 0; /*byte position in the out buffer*/\r\n  unsigned error = 0;\r\n\r\n  (void)settings;\r\n\r\n  while(!BFINAL)\r\n  {\r\n    unsigned BTYPE;\r\n    if(bp + 2 >= insize * 8) return 52; /*error, bit pointer will jump past memory*/\r\n    BFINAL = readBitFromStream(&bp, in);\r\n    BTYPE = 1u * readBitFromStream(&bp, in);\r\n    BTYPE += 2u * readBitFromStream(&bp, in);\r\n\r\n    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/\r\n    else if(BTYPE == 0) error = inflateNoCompression(out, in, &bp, &pos, insize); /*no compression*/\r\n    else error = inflateHuffmanBlock(out, in, &bp, &pos, insize, BTYPE); /*compression, BTYPE 01 or 10*/\r\n\r\n    if(error) return error;\r\n  }\r\n\r\n  return error;\r\n}\r\n\r\nunsigned lodepng_inflate(unsigned char** out, size_t* outsize,\r\n                         const unsigned char* in, size_t insize,\r\n                         const LodePNGDecompressSettings* settings)\r\n{\r\n  unsigned error;\r\n  ucvector v;\r\n  ucvector_init_buffer(&v, *out, *outsize);\r\n  error = lodepng_inflatev(&v, in, insize, settings);\r\n  *out = v.data;\r\n  *outsize = v.size;\r\n  return error;\r\n}\r\n\r\nstatic unsigned inflate(unsigned char** out, size_t* outsize,\r\n                        const unsigned char* in, size_t insize,\r\n                        const LodePNGDecompressSettings* settings)\r\n{\r\n  if(settings->custom_inflate)\r\n  {\r\n    return settings->custom_inflate(out, outsize, in, insize, settings);\r\n  }\r\n  else\r\n  {\r\n    return lodepng_inflate(out, outsize, in, insize, settings);\r\n  }\r\n}\r\n\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / Deflator (Compressor)                                                  / */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\nstatic const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;\r\n\r\n/*bitlen is the size in bits of the code*/\r\nstatic void addHuffmanSymbol(size_t* bp, ucvector* compressed, unsigned code, unsigned bitlen)\r\n{\r\n  addBitsToStreamReversed(bp, compressed, code, bitlen);\r\n}\r\n\r\n/*search the index in the array, that has the largest value smaller than or equal to the given value,\r\ngiven array must be sorted (if no value is smaller, it returns the size of the given array)*/\r\nstatic size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value)\r\n{\r\n  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/\r\n  size_t left = 1;\r\n  size_t right = array_size - 1;\r\n\r\n  while(left <= right) {\r\n    size_t mid = (left + right) >> 1;\r\n    if (array[mid] >= value) right = mid - 1;\r\n    else left = mid + 1;\r\n  }\r\n  if(left >= array_size || array[left] > value) left--;\r\n  return left;\r\n}\r\n\r\nstatic void addLengthDistance(uivector* values, size_t length, size_t distance)\r\n{\r\n  /*values in encoded vector are those used by deflate:\r\n  0-255: literal bytes\r\n  256: end\r\n  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)\r\n  286-287: invalid*/\r\n\r\n  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);\r\n  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);\r\n  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);\r\n  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);\r\n\r\n  uivector_push_back(values, length_code + FIRST_LENGTH_CODE_INDEX);\r\n  uivector_push_back(values, extra_length);\r\n  uivector_push_back(values, dist_code);\r\n  uivector_push_back(values, extra_distance);\r\n}\r\n\r\n/*3 bytes of data get encoded into two bytes. The hash cannot use more than 3\r\nbytes as input because 3 is the minimum match length for deflate*/\r\nstatic const unsigned HASH_NUM_VALUES = 65536;\r\nstatic const unsigned HASH_BIT_MASK = 65535; /*HASH_NUM_VALUES - 1, but C90 does not like that as initializer*/\r\n\r\ntypedef struct Hash\r\n{\r\n  int* head; /*hash value to head circular pos - can be outdated if went around window*/\r\n  /*circular pos to prev circular pos*/\r\n  unsigned short* chain;\r\n  int* val; /*circular pos to hash value*/\r\n\r\n  /*TODO: do this not only for zeros but for any repeated byte. However for PNG\r\n  it's always going to be the zeros that dominate, so not important for PNG*/\r\n  int* headz; /*similar to head, but for chainz*/\r\n  unsigned short* chainz; /*those with same amount of zeros*/\r\n  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/\r\n} Hash;\r\n\r\nstatic unsigned hash_init(Hash* hash, unsigned windowsize)\r\n{\r\n  unsigned i;\r\n  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);\r\n  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);\r\n  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\r\n\r\n  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\r\n  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));\r\n  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\r\n\r\n  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros)\r\n  {\r\n    return 83; /*alloc fail*/\r\n  }\r\n\r\n  /*initialize hash table*/\r\n  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;\r\n  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;\r\n  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/\r\n\r\n  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;\r\n  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/\r\n\r\n  return 0;\r\n}\r\n\r\nstatic void hash_cleanup(Hash* hash)\r\n{\r\n  lodepng_free(hash->head);\r\n  lodepng_free(hash->val);\r\n  lodepng_free(hash->chain);\r\n\r\n  lodepng_free(hash->zeros);\r\n  lodepng_free(hash->headz);\r\n  lodepng_free(hash->chainz);\r\n}\r\n\r\n\r\n\r\nstatic unsigned getHash(const unsigned char* data, size_t size, size_t pos)\r\n{\r\n  unsigned result = 0;\r\n  if(pos + 2 < size)\r\n  {\r\n    /*A simple shift and xor hash is used. Since the data of PNGs is dominated\r\n    by zeroes due to the filters, a better hash does not have a significant\r\n    effect on speed in traversing the chain, and causes more time spend on\r\n    calculating the hash.*/\r\n    result ^= (unsigned)(data[pos + 0] << 0u);\r\n    result ^= (unsigned)(data[pos + 1] << 4u);\r\n    result ^= (unsigned)(data[pos + 2] << 8u);\r\n  } else {\r\n    size_t amount, i;\r\n    if(pos >= size) return 0;\r\n    amount = size - pos;\r\n    for(i = 0; i != amount; ++i) result ^= (unsigned)(data[pos + i] << (i * 8u));\r\n  }\r\n  return result & HASH_BIT_MASK;\r\n}\r\n\r\nstatic unsigned countZeros(const unsigned char* data, size_t size, size_t pos)\r\n{\r\n  const unsigned char* start = data + pos;\r\n  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;\r\n  if(end > data + size) end = data + size;\r\n  data = start;\r\n  while(data != end && *data == 0) ++data;\r\n  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/\r\n  return (unsigned)(data - start);\r\n}\r\n\r\n/*wpos = pos & (windowsize - 1)*/\r\nstatic void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros)\r\n{\r\n  hash->val[wpos] = (int)hashval;\r\n  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];\r\n  hash->head[hashval] = wpos;\r\n\r\n  hash->zeros[wpos] = numzeros;\r\n  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];\r\n  hash->headz[numzeros] = wpos;\r\n}\r\n\r\n/*\r\nLZ77-encode the data. Return value is error code. The input are raw bytes, the output\r\nis in the form of unsigned integers with codes representing for example literal bytes, or\r\nlength/distance pairs.\r\nIt uses a hash table technique to let it encode faster. When doing LZ77 encoding, a\r\nsliding window (of windowsize) is used, and all past bytes in that window can be used as\r\nthe \"dictionary\". A brute force search through all possible distances would be slow, and\r\nthis hash technique is one out of several ways to speed this up.\r\n*/\r\nstatic unsigned encodeLZ77(uivector* out, Hash* hash,\r\n                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,\r\n                           unsigned minmatch, unsigned nicematch, unsigned lazymatching)\r\n{\r\n  size_t pos;\r\n  unsigned i, error = 0;\r\n  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/\r\n  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8;\r\n  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;\r\n\r\n  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/\r\n  unsigned numzeros = 0;\r\n\r\n  unsigned offset; /*the offset represents the distance in LZ77 terminology*/\r\n  unsigned length;\r\n  unsigned lazy = 0;\r\n  unsigned lazylength = 0, lazyoffset = 0;\r\n  unsigned hashval;\r\n  unsigned current_offset, current_length;\r\n  unsigned prev_offset;\r\n  const unsigned char *lastptr, *foreptr, *backptr;\r\n  unsigned hashpos;\r\n\r\n  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/\r\n  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/\r\n\r\n  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;\r\n\r\n  for(pos = inpos; pos < insize; ++pos)\r\n  {\r\n    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/\r\n    unsigned chainlength = 0;\r\n\r\n    hashval = getHash(in, insize, pos);\r\n\r\n    if(usezeros && hashval == 0)\r\n    {\r\n      if(numzeros == 0) numzeros = countZeros(in, insize, pos);\r\n      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;\r\n    }\r\n    else\r\n    {\r\n      numzeros = 0;\r\n    }\r\n\r\n    updateHashChain(hash, wpos, hashval, numzeros);\r\n\r\n    /*the length and offset found for the current position*/\r\n    length = 0;\r\n    offset = 0;\r\n\r\n    hashpos = hash->chain[wpos];\r\n\r\n    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];\r\n\r\n    /*search for the longest string*/\r\n    prev_offset = 0;\r\n    for(;;)\r\n    {\r\n      if(chainlength++ >= maxchainlength) break;\r\n      current_offset = hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize;\r\n\r\n      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/\r\n      prev_offset = current_offset;\r\n      if(current_offset > 0)\r\n      {\r\n        /*test the next characters*/\r\n        foreptr = &in[pos];\r\n        backptr = &in[pos - current_offset];\r\n\r\n        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/\r\n        if(numzeros >= 3)\r\n        {\r\n          unsigned skip = hash->zeros[hashpos];\r\n          if(skip > numzeros) skip = numzeros;\r\n          backptr += skip;\r\n          foreptr += skip;\r\n        }\r\n\r\n        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/\r\n        {\r\n          ++backptr;\r\n          ++foreptr;\r\n        }\r\n        current_length = (unsigned)(foreptr - &in[pos]);\r\n\r\n        if(current_length > length)\r\n        {\r\n          length = current_length; /*the longest length*/\r\n          offset = current_offset; /*the offset that is related to this longest length*/\r\n          /*jump out once a length of max length is found (speed gain). This also jumps\r\n          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/\r\n          if(current_length >= nicematch) break;\r\n        }\r\n      }\r\n\r\n      if(hashpos == hash->chain[hashpos]) break;\r\n\r\n      if(numzeros >= 3 && length > numzeros)\r\n      {\r\n        hashpos = hash->chainz[hashpos];\r\n        if(hash->zeros[hashpos] != numzeros) break;\r\n      }\r\n      else\r\n      {\r\n        hashpos = hash->chain[hashpos];\r\n        /*outdated hash value, happens if particular value was not encountered in whole last window*/\r\n        if(hash->val[hashpos] != (int)hashval) break;\r\n      }\r\n    }\r\n\r\n    if(lazymatching)\r\n    {\r\n      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH)\r\n      {\r\n        lazy = 1;\r\n        lazylength = length;\r\n        lazyoffset = offset;\r\n        continue; /*try the next byte*/\r\n      }\r\n      if(lazy)\r\n      {\r\n        lazy = 0;\r\n        if(pos == 0) ERROR_BREAK(81);\r\n        if(length > lazylength + 1)\r\n        {\r\n          /*push the previous character as literal*/\r\n          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);\r\n        }\r\n        else\r\n        {\r\n          length = lazylength;\r\n          offset = lazyoffset;\r\n          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/\r\n          hash->headz[numzeros] = -1; /*idem*/\r\n          --pos;\r\n        }\r\n      }\r\n    }\r\n    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);\r\n\r\n    /*encode it as length/distance pair or literal value*/\r\n    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/\r\n    {\r\n      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);\r\n    }\r\n    else if(length < minmatch || (length == 3 && offset > 4096))\r\n    {\r\n      /*compensate for the fact that longer offsets have more extra bits, a\r\n      length of only 3 may be not worth it then*/\r\n      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);\r\n    }\r\n    else\r\n    {\r\n      addLengthDistance(out, length, offset);\r\n      for(i = 1; i < length; ++i)\r\n      {\r\n        ++pos;\r\n        wpos = pos & (windowsize - 1);\r\n        hashval = getHash(in, insize, pos);\r\n        if(usezeros && hashval == 0)\r\n        {\r\n          if(numzeros == 0) numzeros = countZeros(in, insize, pos);\r\n          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;\r\n        }\r\n        else\r\n        {\r\n          numzeros = 0;\r\n        }\r\n        updateHashChain(hash, wpos, hashval, numzeros);\r\n      }\r\n    }\r\n  } /*end of the loop through each character of input*/\r\n\r\n  return error;\r\n}\r\n\r\n/* /////////////////////////////////////////////////////////////////////////// */\r\n\r\nstatic unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize)\r\n{\r\n  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,\r\n  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/\r\n\r\n  size_t i, j, numdeflateblocks = (datasize + 65534) / 65535;\r\n  unsigned datapos = 0;\r\n  for(i = 0; i != numdeflateblocks; ++i)\r\n  {\r\n    unsigned BFINAL, BTYPE, LEN, NLEN;\r\n    unsigned char firstbyte;\r\n\r\n    BFINAL = (i == numdeflateblocks - 1);\r\n    BTYPE = 0;\r\n\r\n    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1) << 1) + ((BTYPE & 2) << 1));\r\n    ucvector_push_back(out, firstbyte);\r\n\r\n    LEN = 65535;\r\n    if(datasize - datapos < 65535) LEN = (unsigned)datasize - datapos;\r\n    NLEN = 65535 - LEN;\r\n\r\n    ucvector_push_back(out, (unsigned char)(LEN & 255));\r\n    ucvector_push_back(out, (unsigned char)(LEN >> 8));\r\n    ucvector_push_back(out, (unsigned char)(NLEN & 255));\r\n    ucvector_push_back(out, (unsigned char)(NLEN >> 8));\r\n\r\n    /*Decompressed data*/\r\n    for(j = 0; j < 65535 && datapos < datasize; ++j)\r\n    {\r\n      ucvector_push_back(out, data[datapos++]);\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/*\r\nwrite the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.\r\ntree_ll: the tree for lit and len codes.\r\ntree_d: the tree for distance codes.\r\n*/\r\nstatic void writeLZ77data(size_t* bp, ucvector* out, const uivector* lz77_encoded,\r\n                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d)\r\n{\r\n  size_t i = 0;\r\n  for(i = 0; i != lz77_encoded->size; ++i)\r\n  {\r\n    unsigned val = lz77_encoded->data[i];\r\n    addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_ll, val), HuffmanTree_getLength(tree_ll, val));\r\n    if(val > 256) /*for a length code, 3 more things have to be added*/\r\n    {\r\n      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;\r\n      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];\r\n      unsigned length_extra_bits = lz77_encoded->data[++i];\r\n\r\n      unsigned distance_code = lz77_encoded->data[++i];\r\n\r\n      unsigned distance_index = distance_code;\r\n      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];\r\n      unsigned distance_extra_bits = lz77_encoded->data[++i];\r\n\r\n      addBitsToStream(bp, out, length_extra_bits, n_length_extra_bits);\r\n      addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_d, distance_code),\r\n                       HuffmanTree_getLength(tree_d, distance_code));\r\n      addBitsToStream(bp, out, distance_extra_bits, n_distance_extra_bits);\r\n    }\r\n  }\r\n}\r\n\r\n/*Deflate for a block of type \"dynamic\", that is, with freely, optimally, created huffman trees*/\r\nstatic unsigned deflateDynamic(ucvector* out, size_t* bp, Hash* hash,\r\n                               const unsigned char* data, size_t datapos, size_t dataend,\r\n                               const LodePNGCompressSettings* settings, unsigned final)\r\n{\r\n  unsigned error = 0;\r\n\r\n  /*\r\n  A block is compressed as follows: The PNG data is lz77 encoded, resulting in\r\n  literal bytes and length/distance pairs. This is then huffman compressed with\r\n  two huffman trees. One huffman tree is used for the lit and len values (\"ll\"),\r\n  another huffman tree is used for the dist values (\"d\"). These two trees are\r\n  stored using their code lengths, and to compress even more these code lengths\r\n  are also run-length encoded and huffman compressed. This gives a huffman tree\r\n  of code lengths \"cl\". The code lenghts used to describe this third tree are\r\n  the code length code lengths (\"clcl\").\r\n  */\r\n\r\n  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/\r\n  uivector lz77_encoded;\r\n  HuffmanTree tree_ll; /*tree for lit,len values*/\r\n  HuffmanTree tree_d; /*tree for distance codes*/\r\n  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/\r\n  uivector frequencies_ll; /*frequency of lit,len codes*/\r\n  uivector frequencies_d; /*frequency of dist codes*/\r\n  uivector frequencies_cl; /*frequency of code length codes*/\r\n  uivector bitlen_lld; /*lit,len,dist code lenghts (int bits), literally (without repeat codes).*/\r\n  uivector bitlen_lld_e; /*bitlen_lld encoded with repeat codes (this is a rudemtary run length compression)*/\r\n  /*bitlen_cl is the code length code lengths (\"clcl\"). The bit lengths of codes to represent tree_cl\r\n  (these are written as is in the file, it would be crazy to compress these using yet another huffman\r\n  tree that needs to be represented by yet another set of code lengths)*/\r\n  uivector bitlen_cl;\r\n  size_t datasize = dataend - datapos;\r\n\r\n  /*\r\n  Due to the huffman compression of huffman tree representations (\"two levels\"), there are some anologies:\r\n  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.\r\n  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.\r\n  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.\r\n  */\r\n\r\n  unsigned BFINAL = final;\r\n  size_t numcodes_ll, numcodes_d, i;\r\n  unsigned HLIT, HDIST, HCLEN;\r\n\r\n  uivector_init(&lz77_encoded);\r\n  HuffmanTree_init(&tree_ll);\r\n  HuffmanTree_init(&tree_d);\r\n  HuffmanTree_init(&tree_cl);\r\n  uivector_init(&frequencies_ll);\r\n  uivector_init(&frequencies_d);\r\n  uivector_init(&frequencies_cl);\r\n  uivector_init(&bitlen_lld);\r\n  uivector_init(&bitlen_lld_e);\r\n  uivector_init(&bitlen_cl);\r\n\r\n  /*This while loop never loops due to a break at the end, it is here to\r\n  allow breaking out of it to the cleanup phase on error conditions.*/\r\n  while(!error)\r\n  {\r\n    if(settings->use_lz77)\r\n    {\r\n      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,\r\n                         settings->minmatch, settings->nicematch, settings->lazymatching);\r\n      if(error) break;\r\n    }\r\n    else\r\n    {\r\n      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);\r\n      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/\r\n    }\r\n\r\n    if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83 /*alloc fail*/);\r\n    if(!uivector_resizev(&frequencies_d, 30, 0)) ERROR_BREAK(83 /*alloc fail*/);\r\n\r\n    /*Count the frequencies of lit, len and dist codes*/\r\n    for(i = 0; i != lz77_encoded.size; ++i)\r\n    {\r\n      unsigned symbol = lz77_encoded.data[i];\r\n      ++frequencies_ll.data[symbol];\r\n      if(symbol > 256)\r\n      {\r\n        unsigned dist = lz77_encoded.data[i + 2];\r\n        ++frequencies_d.data[dist];\r\n        i += 3;\r\n      }\r\n    }\r\n    frequencies_ll.data[256] = 1; /*there will be exactly 1 end code, at the end of the block*/\r\n\r\n    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/\r\n    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll.data, 257, frequencies_ll.size, 15);\r\n    if(error) break;\r\n    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/\r\n    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d.data, 2, frequencies_d.size, 15);\r\n    if(error) break;\r\n\r\n    numcodes_ll = tree_ll.numcodes; if(numcodes_ll > 286) numcodes_ll = 286;\r\n    numcodes_d = tree_d.numcodes; if(numcodes_d > 30) numcodes_d = 30;\r\n    /*store the code lengths of both generated trees in bitlen_lld*/\r\n    for(i = 0; i != numcodes_ll; ++i) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_ll, (unsigned)i));\r\n    for(i = 0; i != numcodes_d; ++i) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_d, (unsigned)i));\r\n\r\n    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),\r\n    17 (3-10 zeroes), 18 (11-138 zeroes)*/\r\n    for(i = 0; i != (unsigned)bitlen_lld.size; ++i)\r\n    {\r\n      unsigned j = 0; /*amount of repititions*/\r\n      while(i + j + 1 < (unsigned)bitlen_lld.size && bitlen_lld.data[i + j + 1] == bitlen_lld.data[i]) ++j;\r\n\r\n      if(bitlen_lld.data[i] == 0 && j >= 2) /*repeat code for zeroes*/\r\n      {\r\n        ++j; /*include the first zero*/\r\n        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/\r\n        {\r\n          uivector_push_back(&bitlen_lld_e, 17);\r\n          uivector_push_back(&bitlen_lld_e, j - 3);\r\n        }\r\n        else /*repeat code 18 supports max 138 zeroes*/\r\n        {\r\n          if(j > 138) j = 138;\r\n          uivector_push_back(&bitlen_lld_e, 18);\r\n          uivector_push_back(&bitlen_lld_e, j - 11);\r\n        }\r\n        i += (j - 1);\r\n      }\r\n      else if(j >= 3) /*repeat code for value other than zero*/\r\n      {\r\n        size_t k;\r\n        unsigned num = j / 6, rest = j % 6;\r\n        uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);\r\n        for(k = 0; k < num; ++k)\r\n        {\r\n          uivector_push_back(&bitlen_lld_e, 16);\r\n          uivector_push_back(&bitlen_lld_e, 6 - 3);\r\n        }\r\n        if(rest >= 3)\r\n        {\r\n          uivector_push_back(&bitlen_lld_e, 16);\r\n          uivector_push_back(&bitlen_lld_e, rest - 3);\r\n        }\r\n        else j -= rest;\r\n        i += j;\r\n      }\r\n      else /*too short to benefit from repeat code*/\r\n      {\r\n        uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);\r\n      }\r\n    }\r\n\r\n    /*generate tree_cl, the huffmantree of huffmantrees*/\r\n\r\n    if(!uivector_resizev(&frequencies_cl, NUM_CODE_LENGTH_CODES, 0)) ERROR_BREAK(83 /*alloc fail*/);\r\n    for(i = 0; i != bitlen_lld_e.size; ++i)\r\n    {\r\n      ++frequencies_cl.data[bitlen_lld_e.data[i]];\r\n      /*after a repeat code come the bits that specify the number of repetitions,\r\n      those don't need to be in the frequencies_cl calculation*/\r\n      if(bitlen_lld_e.data[i] >= 16) ++i;\r\n    }\r\n\r\n    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl.data,\r\n                                            frequencies_cl.size, frequencies_cl.size, 7);\r\n    if(error) break;\r\n\r\n    if(!uivector_resize(&bitlen_cl, tree_cl.numcodes)) ERROR_BREAK(83 /*alloc fail*/);\r\n    for(i = 0; i != tree_cl.numcodes; ++i)\r\n    {\r\n      /*lenghts of code length tree is in the order as specified by deflate*/\r\n      bitlen_cl.data[i] = HuffmanTree_getLength(&tree_cl, CLCL_ORDER[i]);\r\n    }\r\n    while(bitlen_cl.data[bitlen_cl.size - 1] == 0 && bitlen_cl.size > 4)\r\n    {\r\n      /*remove zeros at the end, but minimum size must be 4*/\r\n      if(!uivector_resize(&bitlen_cl, bitlen_cl.size - 1)) ERROR_BREAK(83 /*alloc fail*/);\r\n    }\r\n    if(error) break;\r\n\r\n    /*\r\n    Write everything into the output\r\n\r\n    After the BFINAL and BTYPE, the dynamic block consists out of the following:\r\n    - 5 bits HLIT, 5 bits HDIST, 4 bits HCLEN\r\n    - (HCLEN+4)*3 bits code lengths of code length alphabet\r\n    - HLIT + 257 code lenghts of lit/length alphabet (encoded using the code length\r\n      alphabet, + possible repetition codes 16, 17, 18)\r\n    - HDIST + 1 code lengths of distance alphabet (encoded using the code length\r\n      alphabet, + possible repetition codes 16, 17, 18)\r\n    - compressed data\r\n    - 256 (end code)\r\n    */\r\n\r\n    /*Write block type*/\r\n    addBitToStream(bp, out, BFINAL);\r\n    addBitToStream(bp, out, 0); /*first bit of BTYPE \"dynamic\"*/\r\n    addBitToStream(bp, out, 1); /*second bit of BTYPE \"dynamic\"*/\r\n\r\n    /*write the HLIT, HDIST and HCLEN values*/\r\n    HLIT = (unsigned)(numcodes_ll - 257);\r\n    HDIST = (unsigned)(numcodes_d - 1);\r\n    HCLEN = (unsigned)bitlen_cl.size - 4;\r\n    /*trim zeroes for HCLEN. HLIT and HDIST were already trimmed at tree creation*/\r\n    while(!bitlen_cl.data[HCLEN + 4 - 1] && HCLEN > 0) --HCLEN;\r\n    addBitsToStream(bp, out, HLIT, 5);\r\n    addBitsToStream(bp, out, HDIST, 5);\r\n    addBitsToStream(bp, out, HCLEN, 4);\r\n\r\n    /*write the code lenghts of the code length alphabet*/\r\n    for(i = 0; i != HCLEN + 4; ++i) addBitsToStream(bp, out, bitlen_cl.data[i], 3);\r\n\r\n    /*write the lenghts of the lit/len AND the dist alphabet*/\r\n    for(i = 0; i != bitlen_lld_e.size; ++i)\r\n    {\r\n      addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_cl, bitlen_lld_e.data[i]),\r\n                       HuffmanTree_getLength(&tree_cl, bitlen_lld_e.data[i]));\r\n      /*extra bits of repeat codes*/\r\n      if(bitlen_lld_e.data[i] == 16) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 2);\r\n      else if(bitlen_lld_e.data[i] == 17) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 3);\r\n      else if(bitlen_lld_e.data[i] == 18) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 7);\r\n    }\r\n\r\n    /*write the compressed data symbols*/\r\n    writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);\r\n    /*error: the length of the end code 256 must be larger than 0*/\r\n    if(HuffmanTree_getLength(&tree_ll, 256) == 0) ERROR_BREAK(64);\r\n\r\n    /*write the end code*/\r\n    addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));\r\n\r\n    break; /*end of error-while*/\r\n  }\r\n\r\n  /*cleanup*/\r\n  uivector_cleanup(&lz77_encoded);\r\n  HuffmanTree_cleanup(&tree_ll);\r\n  HuffmanTree_cleanup(&tree_d);\r\n  HuffmanTree_cleanup(&tree_cl);\r\n  uivector_cleanup(&frequencies_ll);\r\n  uivector_cleanup(&frequencies_d);\r\n  uivector_cleanup(&frequencies_cl);\r\n  uivector_cleanup(&bitlen_lld_e);\r\n  uivector_cleanup(&bitlen_lld);\r\n  uivector_cleanup(&bitlen_cl);\r\n\r\n  return error;\r\n}\r\n\r\nstatic unsigned deflateFixed(ucvector* out, size_t* bp, Hash* hash,\r\n                             const unsigned char* data,\r\n                             size_t datapos, size_t dataend,\r\n                             const LodePNGCompressSettings* settings, unsigned final)\r\n{\r\n  HuffmanTree tree_ll; /*tree for literal values and length codes*/\r\n  HuffmanTree tree_d; /*tree for distance codes*/\r\n\r\n  unsigned BFINAL = final;\r\n  unsigned error = 0;\r\n  size_t i;\r\n\r\n  HuffmanTree_init(&tree_ll);\r\n  HuffmanTree_init(&tree_d);\r\n\r\n  generateFixedLitLenTree(&tree_ll);\r\n  generateFixedDistanceTree(&tree_d);\r\n\r\n  addBitToStream(bp, out, BFINAL);\r\n  addBitToStream(bp, out, 1); /*first bit of BTYPE*/\r\n  addBitToStream(bp, out, 0); /*second bit of BTYPE*/\r\n\r\n  if(settings->use_lz77) /*LZ77 encoded*/\r\n  {\r\n    uivector lz77_encoded;\r\n    uivector_init(&lz77_encoded);\r\n    error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,\r\n                       settings->minmatch, settings->nicematch, settings->lazymatching);\r\n    if(!error) writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);\r\n    uivector_cleanup(&lz77_encoded);\r\n  }\r\n  else /*no LZ77, but still will be Huffman compressed*/\r\n  {\r\n    for(i = datapos; i < dataend; ++i)\r\n    {\r\n      addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, data[i]), HuffmanTree_getLength(&tree_ll, data[i]));\r\n    }\r\n  }\r\n  /*add END code*/\r\n  if(!error) addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));\r\n\r\n  /*cleanup*/\r\n  HuffmanTree_cleanup(&tree_ll);\r\n  HuffmanTree_cleanup(&tree_d);\r\n\r\n  return error;\r\n}\r\n\r\nstatic unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,\r\n                                 const LodePNGCompressSettings* settings)\r\n{\r\n  unsigned error = 0;\r\n  size_t i, blocksize, numdeflateblocks;\r\n  size_t bp = 0; /*the bit pointer*/\r\n  Hash hash;\r\n\r\n  if(settings->btype > 2) return 61;\r\n  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);\r\n  else if(settings->btype == 1) blocksize = insize;\r\n  else /*if(settings->btype == 2)*/\r\n  {\r\n    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/\r\n    blocksize = insize / 8 + 8;\r\n    if(blocksize < 65536) blocksize = 65536;\r\n    if(blocksize > 262144) blocksize = 262144;\r\n  }\r\n\r\n  numdeflateblocks = (insize + blocksize - 1) / blocksize;\r\n  if(numdeflateblocks == 0) numdeflateblocks = 1;\r\n\r\n  error = hash_init(&hash, settings->windowsize);\r\n  if(error) return error;\r\n\r\n  for(i = 0; i != numdeflateblocks && !error; ++i)\r\n  {\r\n    unsigned final = (i == numdeflateblocks - 1);\r\n    size_t start = i * blocksize;\r\n    size_t end = start + blocksize;\r\n    if(end > insize) end = insize;\r\n\r\n    if(settings->btype == 1) error = deflateFixed(out, &bp, &hash, in, start, end, settings, final);\r\n    else if(settings->btype == 2) error = deflateDynamic(out, &bp, &hash, in, start, end, settings, final);\r\n  }\r\n\r\n  hash_cleanup(&hash);\r\n\r\n  return error;\r\n}\r\n\r\nunsigned lodepng_deflate(unsigned char** out, size_t* outsize,\r\n                         const unsigned char* in, size_t insize,\r\n                         const LodePNGCompressSettings* settings)\r\n{\r\n  unsigned error;\r\n  ucvector v;\r\n  ucvector_init_buffer(&v, *out, *outsize);\r\n  error = lodepng_deflatev(&v, in, insize, settings);\r\n  *out = v.data;\r\n  *outsize = v.size;\r\n  return error;\r\n}\r\n\r\nstatic unsigned deflate(unsigned char** out, size_t* outsize,\r\n                        const unsigned char* in, size_t insize,\r\n                        const LodePNGCompressSettings* settings)\r\n{\r\n  if(settings->custom_deflate)\r\n  {\r\n    return settings->custom_deflate(out, outsize, in, insize, settings);\r\n  }\r\n  else\r\n  {\r\n    return lodepng_deflate(out, outsize, in, insize, settings);\r\n  }\r\n}\r\n\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / Adler32                                                                  */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\nstatic unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)\r\n{\r\n   unsigned s1 = adler & 0xffff;\r\n   unsigned s2 = (adler >> 16) & 0xffff;\r\n\r\n  while(len > 0)\r\n  {\r\n    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/\r\n    unsigned amount = len > 5550 ? 5550 : len;\r\n    len -= amount;\r\n    while(amount > 0)\r\n    {\r\n      s1 += (*data++);\r\n      s2 += s1;\r\n      --amount;\r\n    }\r\n    s1 %= 65521;\r\n    s2 %= 65521;\r\n  }\r\n\r\n  return (s2 << 16) | s1;\r\n}\r\n\r\n/*Return the adler32 of the bytes data[0..len-1]*/\r\nstatic unsigned adler32(const unsigned char* data, unsigned len)\r\n{\r\n  return update_adler32(1L, data, len);\r\n}\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / Zlib                                                                   / */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n\r\nunsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,\r\n                                 size_t insize, const LodePNGDecompressSettings* settings)\r\n{\r\n  unsigned error = 0;\r\n  unsigned CM, CINFO, FDICT;\r\n\r\n  if(insize < 2) return 53; /*error, size of zlib data too small*/\r\n  /*read information from zlib header*/\r\n  if((in[0] * 256 + in[1]) % 31 != 0)\r\n  {\r\n    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/\r\n    return 24;\r\n  }\r\n\r\n  CM = in[0] & 15;\r\n  CINFO = (in[0] >> 4) & 15;\r\n  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/\r\n  FDICT = (in[1] >> 5) & 1;\r\n  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/\r\n\r\n  if(CM != 8 || CINFO > 7)\r\n  {\r\n    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/\r\n    return 25;\r\n  }\r\n  if(FDICT != 0)\r\n  {\r\n    /*error: the specification of PNG says about the zlib stream:\r\n      \"The additional flags shall not specify a preset dictionary.\"*/\r\n    return 26;\r\n  }\r\n\r\n  error = inflate(out, outsize, in + 2, insize - 2, settings);\r\n  if(error) return error;\r\n\r\n  if(!settings->ignore_adler32)\r\n  {\r\n    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);\r\n    unsigned checksum = adler32(*out, (unsigned)(*outsize));\r\n    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/\r\n  }\r\n\r\n  return 0; /*no error*/\r\n}\r\n\r\nstatic unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,\r\n                                size_t insize, const LodePNGDecompressSettings* settings)\r\n{\r\n  if(settings->custom_zlib)\r\n  {\r\n    return settings->custom_zlib(out, outsize, in, insize, settings);\r\n  }\r\n  else\r\n  {\r\n    return lodepng_zlib_decompress(out, outsize, in, insize, settings);\r\n  }\r\n}\r\n\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n\r\nunsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\r\n                               size_t insize, const LodePNGCompressSettings* settings)\r\n{\r\n  /*initially, *out must be NULL and outsize 0, if you just give some random *out\r\n  that's pointing to a non allocated buffer, this'll crash*/\r\n  ucvector outv;\r\n  size_t i;\r\n  unsigned error;\r\n  unsigned char* deflatedata = 0;\r\n  size_t deflatesize = 0;\r\n\r\n  /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/\r\n  unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/\r\n  unsigned FLEVEL = 0;\r\n  unsigned FDICT = 0;\r\n  unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;\r\n  unsigned FCHECK = 31 - CMFFLG % 31;\r\n  CMFFLG += FCHECK;\r\n\r\n  /*ucvector-controlled version of the output buffer, for dynamic array*/\r\n  ucvector_init_buffer(&outv, *out, *outsize);\r\n\r\n  ucvector_push_back(&outv, (unsigned char)(CMFFLG >> 8));\r\n  ucvector_push_back(&outv, (unsigned char)(CMFFLG & 255));\r\n\r\n  error = deflate(&deflatedata, &deflatesize, in, insize, settings);\r\n\r\n  if(!error)\r\n  {\r\n    unsigned ADLER32 = adler32(in, (unsigned)insize);\r\n    for(i = 0; i != deflatesize; ++i) ucvector_push_back(&outv, deflatedata[i]);\r\n    lodepng_free(deflatedata);\r\n    lodepng_add32bitInt(&outv, ADLER32);\r\n  }\r\n\r\n  *out = outv.data;\r\n  *outsize = outv.size;\r\n\r\n  return error;\r\n}\r\n\r\n/* compress using the default or custom zlib function */\r\nstatic unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\r\n                              size_t insize, const LodePNGCompressSettings* settings)\r\n{\r\n  if(settings->custom_zlib)\r\n  {\r\n    return settings->custom_zlib(out, outsize, in, insize, settings);\r\n  }\r\n  else\r\n  {\r\n    return lodepng_zlib_compress(out, outsize, in, insize, settings);\r\n  }\r\n}\r\n\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n#else /*no LODEPNG_COMPILE_ZLIB*/\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\nstatic unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,\r\n                                size_t insize, const LodePNGDecompressSettings* settings)\r\n{\r\n  if(!settings->custom_zlib) return 87; /*no custom zlib function provided */\r\n  return settings->custom_zlib(out, outsize, in, insize, settings);\r\n}\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\nstatic unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\r\n                              size_t insize, const LodePNGCompressSettings* settings)\r\n{\r\n  if(!settings->custom_zlib) return 87; /*no custom zlib function provided */\r\n  return settings->custom_zlib(out, outsize, in, insize, settings);\r\n}\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n#endif /*LODEPNG_COMPILE_ZLIB*/\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n\r\n/*this is a good tradeoff between speed and compression ratio*/\r\n#define DEFAULT_WINDOWSIZE 2048\r\n\r\nvoid lodepng_compress_settings_init(LodePNGCompressSettings* settings)\r\n{\r\n  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/\r\n  settings->btype = 2;\r\n  settings->use_lz77 = 1;\r\n  settings->windowsize = DEFAULT_WINDOWSIZE;\r\n  settings->minmatch = 3;\r\n  settings->nicematch = 128;\r\n  settings->lazymatching = 1;\r\n\r\n  settings->custom_zlib = 0;\r\n  settings->custom_deflate = 0;\r\n  settings->custom_context = 0;\r\n}\r\n\r\nconst LodePNGCompressSettings lodepng_default_compress_settings = {2, 1, DEFAULT_WINDOWSIZE, 3, 128, 1, 0, 0, 0};\r\n\r\n\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n\r\nvoid lodepng_decompress_settings_init(LodePNGDecompressSettings* settings)\r\n{\r\n  settings->ignore_adler32 = 0;\r\n\r\n  settings->custom_zlib = 0;\r\n  settings->custom_inflate = 0;\r\n  settings->custom_context = 0;\r\n}\r\n\r\nconst LodePNGDecompressSettings lodepng_default_decompress_settings = {0, 0, 0, 0};\r\n\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* // End of Zlib related code. Begin of PNG related code.                 // */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n#ifdef LODEPNG_COMPILE_PNG\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / CRC32                                                                  / */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n\r\n#ifndef LODEPNG_NO_COMPILE_CRC\r\n/* CRC polynomial: 0xedb88320 */\r\nstatic unsigned lodepng_crc32_table[256] = {\r\n           0u, 1996959894u, 3993919788u, 2567524794u,  124634137u, 1886057615u, 3915621685u, 2657392035u,\r\n   249268274u, 2044508324u, 3772115230u, 2547177864u,  162941995u, 2125561021u, 3887607047u, 2428444049u,\r\n   498536548u, 1789927666u, 4089016648u, 2227061214u,  450548861u, 1843258603u, 4107580753u, 2211677639u,\r\n   325883990u, 1684777152u, 4251122042u, 2321926636u,  335633487u, 1661365465u, 4195302755u, 2366115317u,\r\n   997073096u, 1281953886u, 3579855332u, 2724688242u, 1006888145u, 1258607687u, 3524101629u, 2768942443u,\r\n   901097722u, 1119000684u, 3686517206u, 2898065728u,  853044451u, 1172266101u, 3705015759u, 2882616665u,\r\n   651767980u, 1373503546u, 3369554304u, 3218104598u,  565507253u, 1454621731u, 3485111705u, 3099436303u,\r\n   671266974u, 1594198024u, 3322730930u, 2970347812u,  795835527u, 1483230225u, 3244367275u, 3060149565u,\r\n  1994146192u,   31158534u, 2563907772u, 4023717930u, 1907459465u,  112637215u, 2680153253u, 3904427059u,\r\n  2013776290u,  251722036u, 2517215374u, 3775830040u, 2137656763u,  141376813u, 2439277719u, 3865271297u,\r\n  1802195444u,  476864866u, 2238001368u, 4066508878u, 1812370925u,  453092731u, 2181625025u, 4111451223u,\r\n  1706088902u,  314042704u, 2344532202u, 4240017532u, 1658658271u,  366619977u, 2362670323u, 4224994405u,\r\n  1303535960u,  984961486u, 2747007092u, 3569037538u, 1256170817u, 1037604311u, 2765210733u, 3554079995u,\r\n  1131014506u,  879679996u, 2909243462u, 3663771856u, 1141124467u,  855842277u, 2852801631u, 3708648649u,\r\n  1342533948u,  654459306u, 3188396048u, 3373015174u, 1466479909u,  544179635u, 3110523913u, 3462522015u,\r\n  1591671054u,  702138776u, 2966460450u, 3352799412u, 1504918807u,  783551873u, 3082640443u, 3233442989u,\r\n  3988292384u, 2596254646u,   62317068u, 1957810842u, 3939845945u, 2647816111u,   81470997u, 1943803523u,\r\n  3814918930u, 2489596804u,  225274430u, 2053790376u, 3826175755u, 2466906013u,  167816743u, 2097651377u,\r\n  4027552580u, 2265490386u,  503444072u, 1762050814u, 4150417245u, 2154129355u,  426522225u, 1852507879u,\r\n  4275313526u, 2312317920u,  282753626u, 1742555852u, 4189708143u, 2394877945u,  397917763u, 1622183637u,\r\n  3604390888u, 2714866558u,  953729732u, 1340076626u, 3518719985u, 2797360999u, 1068828381u, 1219638859u,\r\n  3624741850u, 2936675148u,  906185462u, 1090812512u, 3747672003u, 2825379669u,  829329135u, 1181335161u,\r\n  3412177804u, 3160834842u,  628085408u, 1382605366u, 3423369109u, 3138078467u,  570562233u, 1426400815u,\r\n  3317316542u, 2998733608u,  733239954u, 1555261956u, 3268935591u, 3050360625u,  752459403u, 1541320221u,\r\n  2607071920u, 3965973030u, 1969922972u,   40735498u, 2617837225u, 3943577151u, 1913087877u,   83908371u,\r\n  2512341634u, 3803740692u, 2075208622u,  213261112u, 2463272603u, 3855990285u, 2094854071u,  198958881u,\r\n  2262029012u, 4057260610u, 1759359992u,  534414190u, 2176718541u, 4139329115u, 1873836001u,  414664567u,\r\n  2282248934u, 4279200368u, 1711684554u,  285281116u, 2405801727u, 4167216745u, 1634467795u,  376229701u,\r\n  2685067896u, 3608007406u, 1308918612u,  956543938u, 2808555105u, 3495958263u, 1231636301u, 1047427035u,\r\n  2932959818u, 3654703836u, 1088359270u,  936918000u, 2847714899u, 3736837829u, 1202900863u,  817233897u,\r\n  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,\r\n  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u\r\n};\r\n\r\n/*Return the CRC of the bytes buf[0..len-1].*/\r\nunsigned lodepng_crc32(const unsigned char* data, size_t length)\r\n{\r\n  unsigned r = 0xffffffffu;\r\n  size_t i;\r\n  for(i = 0; i < length; ++i)\r\n  {\r\n    r = lodepng_crc32_table[(r ^ data[i]) & 0xff] ^ (r >> 8);\r\n  }\r\n  return r ^ 0xffffffffu;\r\n}\r\n#else /* !LODEPNG_NO_COMPILE_CRC */\r\nunsigned lodepng_crc32(const unsigned char* data, size_t length);\r\n#endif /* !LODEPNG_NO_COMPILE_CRC */\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / Reading and writing single bits and bytes from/to stream for LodePNG   / */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\nstatic unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)\r\n{\r\n  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);\r\n  ++(*bitpointer);\r\n  return result;\r\n}\r\n\r\nstatic unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)\r\n{\r\n  unsigned result = 0;\r\n  size_t i;\r\n  for(i = 0 ; i < nbits; ++i)\r\n  {\r\n    result <<= 1;\r\n    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);\r\n  }\r\n  return result;\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\nstatic void setBitOfReversedStream0(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)\r\n{\r\n  /*the current bit in bitstream must be 0 for this to work*/\r\n  if(bit)\r\n  {\r\n    /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/\r\n    bitstream[(*bitpointer) >> 3] |= (bit << (7 - ((*bitpointer) & 0x7)));\r\n  }\r\n  ++(*bitpointer);\r\n}\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\nstatic void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)\r\n{\r\n  /*the current bit in bitstream may be 0 or 1 for this to work*/\r\n  if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));\r\n  else         bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));\r\n  ++(*bitpointer);\r\n}\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / PNG chunks                                                             / */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\nunsigned lodepng_chunk_length(const unsigned char* chunk)\r\n{\r\n  return lodepng_read32bitInt(&chunk[0]);\r\n}\r\n\r\nvoid lodepng_chunk_type(char type[5], const unsigned char* chunk)\r\n{\r\n  unsigned i;\r\n  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];\r\n  type[4] = 0; /*null termination char*/\r\n}\r\n\r\nunsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type)\r\n{\r\n  if(strlen(type) != 4) return 0;\r\n  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);\r\n}\r\n\r\nunsigned char lodepng_chunk_ancillary(const unsigned char* chunk)\r\n{\r\n  return((chunk[4] & 32) != 0);\r\n}\r\n\r\nunsigned char lodepng_chunk_private(const unsigned char* chunk)\r\n{\r\n  return((chunk[6] & 32) != 0);\r\n}\r\n\r\nunsigned char lodepng_chunk_safetocopy(const unsigned char* chunk)\r\n{\r\n  return((chunk[7] & 32) != 0);\r\n}\r\n\r\nunsigned char* lodepng_chunk_data(unsigned char* chunk)\r\n{\r\n  return &chunk[8];\r\n}\r\n\r\nconst unsigned char* lodepng_chunk_data_const(const unsigned char* chunk)\r\n{\r\n  return &chunk[8];\r\n}\r\n\r\nunsigned lodepng_chunk_check_crc(const unsigned char* chunk)\r\n{\r\n  unsigned length = lodepng_chunk_length(chunk);\r\n  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);\r\n  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/\r\n  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);\r\n  if(CRC != checksum) return 1;\r\n  else return 0;\r\n}\r\n\r\nvoid lodepng_chunk_generate_crc(unsigned char* chunk)\r\n{\r\n  unsigned length = lodepng_chunk_length(chunk);\r\n  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);\r\n  lodepng_set32bitInt(chunk + 8 + length, CRC);\r\n}\r\n\r\nunsigned char* lodepng_chunk_next(unsigned char* chunk)\r\n{\r\n  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;\r\n  return &chunk[total_chunk_length];\r\n}\r\n\r\nconst unsigned char* lodepng_chunk_next_const(const unsigned char* chunk)\r\n{\r\n  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;\r\n  return &chunk[total_chunk_length];\r\n}\r\n\r\nunsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk)\r\n{\r\n  unsigned i;\r\n  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;\r\n  unsigned char *chunk_start, *new_buffer;\r\n  size_t new_length = (*outlength) + total_chunk_length;\r\n  if(new_length < total_chunk_length || new_length < (*outlength)) return 77; /*integer overflow happened*/\r\n\r\n  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);\r\n  if(!new_buffer) return 83; /*alloc fail*/\r\n  (*out) = new_buffer;\r\n  (*outlength) = new_length;\r\n  chunk_start = &(*out)[new_length - total_chunk_length];\r\n\r\n  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];\r\n\r\n  return 0;\r\n}\r\n\r\nunsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,\r\n                              const char* type, const unsigned char* data)\r\n{\r\n  unsigned i;\r\n  unsigned char *chunk, *new_buffer;\r\n  size_t new_length = (*outlength) + length + 12;\r\n  if(new_length < length + 12 || new_length < (*outlength)) return 77; /*integer overflow happened*/\r\n  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);\r\n  if(!new_buffer) return 83; /*alloc fail*/\r\n  (*out) = new_buffer;\r\n  (*outlength) = new_length;\r\n  chunk = &(*out)[(*outlength) - length - 12];\r\n\r\n  /*1: length*/\r\n  lodepng_set32bitInt(chunk, (unsigned)length);\r\n\r\n  /*2: chunk name (4 letters)*/\r\n  chunk[4] = (unsigned char)type[0];\r\n  chunk[5] = (unsigned char)type[1];\r\n  chunk[6] = (unsigned char)type[2];\r\n  chunk[7] = (unsigned char)type[3];\r\n\r\n  /*3: the data*/\r\n  for(i = 0; i != length; ++i) chunk[8 + i] = data[i];\r\n\r\n  /*4: CRC (of the chunkname characters and the data)*/\r\n  lodepng_chunk_generate_crc(chunk);\r\n\r\n  return 0;\r\n}\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / Color types and such                                                   / */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n/*return type is a LodePNG error code*/\r\nstatic unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) /*bd = bitdepth*/\r\n{\r\n  switch(colortype)\r\n  {\r\n    case 0: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break; /*grey*/\r\n    case 2: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGB*/\r\n    case 3: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break; /*palette*/\r\n    case 4: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*grey + alpha*/\r\n    case 6: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGBA*/\r\n    default: return 31;\r\n  }\r\n  return 0; /*allowed color type / bits combination*/\r\n}\r\n\r\nstatic unsigned getNumColorChannels(LodePNGColorType colortype)\r\n{\r\n  switch(colortype)\r\n  {\r\n    case 0: return 1; /*grey*/\r\n    case 2: return 3; /*RGB*/\r\n    case 3: return 1; /*palette*/\r\n    case 4: return 2; /*grey + alpha*/\r\n    case 6: return 4; /*RGBA*/\r\n  }\r\n  return 0; /*unexisting color type*/\r\n}\r\n\r\nstatic unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  /*bits per pixel is amount of channels * bits per channel*/\r\n  return getNumColorChannels(colortype) * bitdepth;\r\n}\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\nvoid lodepng_color_mode_init(LodePNGColorMode* info)\r\n{\r\n  info->key_defined = 0;\r\n  info->key_r = info->key_g = info->key_b = 0;\r\n  info->colortype = LCT_RGBA;\r\n  info->bitdepth = 8;\r\n  info->palette = 0;\r\n  info->palettesize = 0;\r\n}\r\n\r\nvoid lodepng_color_mode_cleanup(LodePNGColorMode* info)\r\n{\r\n  lodepng_palette_clear(info);\r\n}\r\n\r\nunsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source)\r\n{\r\n  size_t i;\r\n  lodepng_color_mode_cleanup(dest);\r\n  *dest = *source;\r\n  if(source->palette)\r\n  {\r\n    dest->palette = (unsigned char*)lodepng_malloc(1024);\r\n    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/\r\n    for(i = 0; i != source->palettesize * 4; ++i) dest->palette[i] = source->palette[i];\r\n  }\r\n  return 0;\r\n}\r\n\r\nstatic int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b)\r\n{\r\n  size_t i;\r\n  if(a->colortype != b->colortype) return 0;\r\n  if(a->bitdepth != b->bitdepth) return 0;\r\n  if(a->key_defined != b->key_defined) return 0;\r\n  if(a->key_defined)\r\n  {\r\n    if(a->key_r != b->key_r) return 0;\r\n    if(a->key_g != b->key_g) return 0;\r\n    if(a->key_b != b->key_b) return 0;\r\n  }\r\n  /*if one of the palette sizes is 0, then we consider it to be the same as the\r\n  other: it means that e.g. the palette was not given by the user and should be\r\n  considered the same as the palette inside the PNG.*/\r\n  if(1/*a->palettesize != 0 && b->palettesize != 0*/) {\r\n    if(a->palettesize != b->palettesize) return 0;\r\n    for(i = 0; i != a->palettesize * 4; ++i)\r\n    {\r\n      if(a->palette[i] != b->palette[i]) return 0;\r\n    }\r\n  }\r\n  return 1;\r\n}\r\n\r\nvoid lodepng_palette_clear(LodePNGColorMode* info)\r\n{\r\n  if(info->palette) lodepng_free(info->palette);\r\n  info->palette = 0;\r\n  info->palettesize = 0;\r\n}\r\n\r\nunsigned lodepng_palette_add(LodePNGColorMode* info,\r\n                             unsigned char r, unsigned char g, unsigned char b, unsigned char a)\r\n{\r\n  unsigned char* data;\r\n  /*the same resize technique as C++ std::vectors is used, and here it's made so that for a palette with\r\n  the max of 256 colors, it'll have the exact alloc size*/\r\n  if(!info->palette) /*allocate palette if empty*/\r\n  {\r\n    /*room for 256 colors with 4 bytes each*/\r\n    data = (unsigned char*)lodepng_realloc(info->palette, 1024);\r\n    if(!data) return 83; /*alloc fail*/\r\n    else info->palette = data;\r\n  }\r\n  info->palette[4 * info->palettesize + 0] = r;\r\n  info->palette[4 * info->palettesize + 1] = g;\r\n  info->palette[4 * info->palettesize + 2] = b;\r\n  info->palette[4 * info->palettesize + 3] = a;\r\n  ++info->palettesize;\r\n  return 0;\r\n}\r\n\r\nunsigned lodepng_get_bpp(const LodePNGColorMode* info)\r\n{\r\n  /*calculate bits per pixel out of colortype and bitdepth*/\r\n  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);\r\n}\r\n\r\nunsigned lodepng_get_channels(const LodePNGColorMode* info)\r\n{\r\n  return getNumColorChannels(info->colortype);\r\n}\r\n\r\nunsigned lodepng_is_greyscale_type(const LodePNGColorMode* info)\r\n{\r\n  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;\r\n}\r\n\r\nunsigned lodepng_is_alpha_type(const LodePNGColorMode* info)\r\n{\r\n  return (info->colortype & 4) != 0; /*4 or 6*/\r\n}\r\n\r\nunsigned lodepng_is_palette_type(const LodePNGColorMode* info)\r\n{\r\n  return info->colortype == LCT_PALETTE;\r\n}\r\n\r\nunsigned lodepng_has_palette_alpha(const LodePNGColorMode* info)\r\n{\r\n  size_t i;\r\n  for(i = 0; i != info->palettesize; ++i)\r\n  {\r\n    if(info->palette[i * 4 + 3] < 255) return 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nunsigned lodepng_can_have_alpha(const LodePNGColorMode* info)\r\n{\r\n  return info->key_defined\r\n      || lodepng_is_alpha_type(info)\r\n      || lodepng_has_palette_alpha(info);\r\n}\r\n\r\nsize_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color)\r\n{\r\n  /*will not overflow for any color type if roughly w * h < 268435455*/\r\n  size_t bpp = lodepng_get_bpp(color);\r\n  size_t n = w * h;\r\n  return ((n / 8) * bpp) + ((n & 7) * bpp + 7) / 8;\r\n}\r\n\r\nsize_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  /*will not overflow for any color type if roughly w * h < 268435455*/\r\n  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);\r\n  size_t n = w * h;\r\n  return ((n / 8) * bpp) + ((n & 7) * bpp + 7) / 8;\r\n}\r\n\r\n\r\n#ifdef LODEPNG_COMPILE_PNG\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer*/\r\nstatic size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)\r\n{\r\n  /*will not overflow for any color type if roughly w * h < 268435455*/\r\n  size_t bpp = lodepng_get_bpp(color);\r\n  size_t line = ((w / 8) * bpp) + ((w & 7) * bpp + 7) / 8;\r\n  return h * line;\r\n}\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n#endif /*LODEPNG_COMPILE_PNG*/\r\n\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n\r\nstatic void LodePNGUnknownChunks_init(LodePNGInfo* info)\r\n{\r\n  unsigned i;\r\n  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;\r\n  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;\r\n}\r\n\r\nstatic void LodePNGUnknownChunks_cleanup(LodePNGInfo* info)\r\n{\r\n  unsigned i;\r\n  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);\r\n}\r\n\r\nstatic unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src)\r\n{\r\n  unsigned i;\r\n\r\n  LodePNGUnknownChunks_cleanup(dest);\r\n\r\n  for(i = 0; i != 3; ++i)\r\n  {\r\n    size_t j;\r\n    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];\r\n    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);\r\n    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/\r\n    for(j = 0; j < src->unknown_chunks_size[i]; ++j)\r\n    {\r\n      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/******************************************************************************/\r\n\r\nstatic void LodePNGText_init(LodePNGInfo* info)\r\n{\r\n  info->text_num = 0;\r\n  info->text_keys = NULL;\r\n  info->text_strings = NULL;\r\n}\r\n\r\nstatic void LodePNGText_cleanup(LodePNGInfo* info)\r\n{\r\n  size_t i;\r\n  for(i = 0; i != info->text_num; ++i)\r\n  {\r\n    string_cleanup(&info->text_keys[i]);\r\n    string_cleanup(&info->text_strings[i]);\r\n  }\r\n  lodepng_free(info->text_keys);\r\n  lodepng_free(info->text_strings);\r\n}\r\n\r\nstatic unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source)\r\n{\r\n  size_t i = 0;\r\n  dest->text_keys = 0;\r\n  dest->text_strings = 0;\r\n  dest->text_num = 0;\r\n  for(i = 0; i != source->text_num; ++i)\r\n  {\r\n    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));\r\n  }\r\n  return 0;\r\n}\r\n\r\nvoid lodepng_clear_text(LodePNGInfo* info)\r\n{\r\n  LodePNGText_cleanup(info);\r\n}\r\n\r\nunsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str)\r\n{\r\n  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));\r\n  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));\r\n  if(!new_keys || !new_strings)\r\n  {\r\n    lodepng_free(new_keys);\r\n    lodepng_free(new_strings);\r\n    return 83; /*alloc fail*/\r\n  }\r\n\r\n  ++info->text_num;\r\n  info->text_keys = new_keys;\r\n  info->text_strings = new_strings;\r\n\r\n  string_init(&info->text_keys[info->text_num - 1]);\r\n  string_set(&info->text_keys[info->text_num - 1], key);\r\n\r\n  string_init(&info->text_strings[info->text_num - 1]);\r\n  string_set(&info->text_strings[info->text_num - 1], str);\r\n\r\n  return 0;\r\n}\r\n\r\n/******************************************************************************/\r\n\r\nstatic void LodePNGIText_init(LodePNGInfo* info)\r\n{\r\n  info->itext_num = 0;\r\n  info->itext_keys = NULL;\r\n  info->itext_langtags = NULL;\r\n  info->itext_transkeys = NULL;\r\n  info->itext_strings = NULL;\r\n}\r\n\r\nstatic void LodePNGIText_cleanup(LodePNGInfo* info)\r\n{\r\n  size_t i;\r\n  for(i = 0; i != info->itext_num; ++i)\r\n  {\r\n    string_cleanup(&info->itext_keys[i]);\r\n    string_cleanup(&info->itext_langtags[i]);\r\n    string_cleanup(&info->itext_transkeys[i]);\r\n    string_cleanup(&info->itext_strings[i]);\r\n  }\r\n  lodepng_free(info->itext_keys);\r\n  lodepng_free(info->itext_langtags);\r\n  lodepng_free(info->itext_transkeys);\r\n  lodepng_free(info->itext_strings);\r\n}\r\n\r\nstatic unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source)\r\n{\r\n  size_t i = 0;\r\n  dest->itext_keys = 0;\r\n  dest->itext_langtags = 0;\r\n  dest->itext_transkeys = 0;\r\n  dest->itext_strings = 0;\r\n  dest->itext_num = 0;\r\n  for(i = 0; i != source->itext_num; ++i)\r\n  {\r\n    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],\r\n                                        source->itext_transkeys[i], source->itext_strings[i]));\r\n  }\r\n  return 0;\r\n}\r\n\r\nvoid lodepng_clear_itext(LodePNGInfo* info)\r\n{\r\n  LodePNGIText_cleanup(info);\r\n}\r\n\r\nunsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,\r\n                           const char* transkey, const char* str)\r\n{\r\n  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));\r\n  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));\r\n  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));\r\n  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));\r\n  if(!new_keys || !new_langtags || !new_transkeys || !new_strings)\r\n  {\r\n    lodepng_free(new_keys);\r\n    lodepng_free(new_langtags);\r\n    lodepng_free(new_transkeys);\r\n    lodepng_free(new_strings);\r\n    return 83; /*alloc fail*/\r\n  }\r\n\r\n  ++info->itext_num;\r\n  info->itext_keys = new_keys;\r\n  info->itext_langtags = new_langtags;\r\n  info->itext_transkeys = new_transkeys;\r\n  info->itext_strings = new_strings;\r\n\r\n  string_init(&info->itext_keys[info->itext_num - 1]);\r\n  string_set(&info->itext_keys[info->itext_num - 1], key);\r\n\r\n  string_init(&info->itext_langtags[info->itext_num - 1]);\r\n  string_set(&info->itext_langtags[info->itext_num - 1], langtag);\r\n\r\n  string_init(&info->itext_transkeys[info->itext_num - 1]);\r\n  string_set(&info->itext_transkeys[info->itext_num - 1], transkey);\r\n\r\n  string_init(&info->itext_strings[info->itext_num - 1]);\r\n  string_set(&info->itext_strings[info->itext_num - 1], str);\r\n\r\n  return 0;\r\n}\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n\r\nvoid lodepng_info_init(LodePNGInfo* info)\r\n{\r\n  lodepng_color_mode_init(&info->color);\r\n  info->interlace_method = 0;\r\n  info->compression_method = 0;\r\n  info->filter_method = 0;\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n  info->background_defined = 0;\r\n  info->background_r = info->background_g = info->background_b = 0;\r\n\r\n  LodePNGText_init(info);\r\n  LodePNGIText_init(info);\r\n\r\n  info->time_defined = 0;\r\n  info->phys_defined = 0;\r\n\r\n  LodePNGUnknownChunks_init(info);\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n}\r\n\r\nvoid lodepng_info_cleanup(LodePNGInfo* info)\r\n{\r\n  lodepng_color_mode_cleanup(&info->color);\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n  LodePNGText_cleanup(info);\r\n  LodePNGIText_cleanup(info);\r\n\r\n  LodePNGUnknownChunks_cleanup(info);\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n}\r\n\r\nunsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source)\r\n{\r\n  lodepng_info_cleanup(dest);\r\n  *dest = *source;\r\n  lodepng_color_mode_init(&dest->color);\r\n  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));\r\n\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));\r\n  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));\r\n\r\n  LodePNGUnknownChunks_init(dest);\r\n  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n  return 0;\r\n}\r\n\r\nvoid lodepng_info_swap(LodePNGInfo* a, LodePNGInfo* b)\r\n{\r\n  LodePNGInfo temp = *a;\r\n  *a = *b;\r\n  *b = temp;\r\n}\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/\r\nstatic void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in)\r\n{\r\n  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/\r\n  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/\r\n  unsigned p = index & m;\r\n  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/\r\n  in = in << (bits * (m - p));\r\n  if(p == 0) out[index * bits / 8] = in;\r\n  else out[index * bits / 8] |= in;\r\n}\r\n\r\ntypedef struct ColorTree ColorTree;\r\n\r\n/*\r\nOne node of a color tree\r\nThis is the data structure used to count the number of unique colors and to get a palette\r\nindex for a color. It's like an octree, but because the alpha channel is used too, each\r\nnode has 16 instead of 8 children.\r\n*/\r\nstruct ColorTree\r\n{\r\n  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/\r\n  int index; /*the payload. Only has a meaningful value if this is in the last level*/\r\n};\r\n\r\nstatic void color_tree_init(ColorTree* tree)\r\n{\r\n  int i;\r\n  for(i = 0; i != 16; ++i) tree->children[i] = 0;\r\n  tree->index = -1;\r\n}\r\n\r\nstatic void color_tree_cleanup(ColorTree* tree)\r\n{\r\n  int i;\r\n  for(i = 0; i != 16; ++i)\r\n  {\r\n    if(tree->children[i])\r\n    {\r\n      color_tree_cleanup(tree->children[i]);\r\n      lodepng_free(tree->children[i]);\r\n    }\r\n  }\r\n}\r\n\r\n/*returns -1 if color not present, its index otherwise*/\r\nstatic int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)\r\n{\r\n  int bit = 0;\r\n  for(bit = 0; bit < 8; ++bit)\r\n  {\r\n    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);\r\n    if(!tree->children[i]) return -1;\r\n    else tree = tree->children[i];\r\n  }\r\n  return tree ? tree->index : -1;\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\nstatic int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)\r\n{\r\n  return color_tree_get(tree, r, g, b, a) >= 0;\r\n}\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n/*color is not allowed to already exist.\r\nIndex should be >= 0 (it's signed to be compatible with using -1 for \"doesn't exist\")*/\r\nstatic void color_tree_add(ColorTree* tree,\r\n                           unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index)\r\n{\r\n  int bit;\r\n  for(bit = 0; bit < 8; ++bit)\r\n  {\r\n    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);\r\n    if(!tree->children[i])\r\n    {\r\n      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));\r\n      color_tree_init(tree->children[i]);\r\n    }\r\n    tree = tree->children[i];\r\n  }\r\n  tree->index = (int)index;\r\n}\r\n\r\n/*put a pixel, given its RGBA color, into image of any color type*/\r\nstatic unsigned rgba8ToPixel(unsigned char* out, size_t i,\r\n                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,\r\n                             unsigned char r, unsigned char g, unsigned char b, unsigned char a)\r\n{\r\n  if(mode->colortype == LCT_GREY)\r\n  {\r\n    unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;\r\n    if(mode->bitdepth == 8) out[i] = grey;\r\n    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = grey;\r\n    else\r\n    {\r\n      /*take the most significant bits of grey*/\r\n      grey = (grey >> (8 - mode->bitdepth)) & ((1 << mode->bitdepth) - 1);\r\n      addColorBits(out, i, mode->bitdepth, grey);\r\n    }\r\n  }\r\n  else if(mode->colortype == LCT_RGB)\r\n  {\r\n    if(mode->bitdepth == 8)\r\n    {\r\n      out[i * 3 + 0] = r;\r\n      out[i * 3 + 1] = g;\r\n      out[i * 3 + 2] = b;\r\n    }\r\n    else\r\n    {\r\n      out[i * 6 + 0] = out[i * 6 + 1] = r;\r\n      out[i * 6 + 2] = out[i * 6 + 3] = g;\r\n      out[i * 6 + 4] = out[i * 6 + 5] = b;\r\n    }\r\n  }\r\n  else if(mode->colortype == LCT_PALETTE)\r\n  {\r\n    int index = color_tree_get(tree, r, g, b, a);\r\n    if(index < 0) return 82; /*color not in palette*/\r\n    if(mode->bitdepth == 8) out[i] = index;\r\n    else addColorBits(out, i, mode->bitdepth, (unsigned)index);\r\n  }\r\n  else if(mode->colortype == LCT_GREY_ALPHA)\r\n  {\r\n    unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;\r\n    if(mode->bitdepth == 8)\r\n    {\r\n      out[i * 2 + 0] = grey;\r\n      out[i * 2 + 1] = a;\r\n    }\r\n    else if(mode->bitdepth == 16)\r\n    {\r\n      out[i * 4 + 0] = out[i * 4 + 1] = grey;\r\n      out[i * 4 + 2] = out[i * 4 + 3] = a;\r\n    }\r\n  }\r\n  else if(mode->colortype == LCT_RGBA)\r\n  {\r\n    if(mode->bitdepth == 8)\r\n    {\r\n      out[i * 4 + 0] = r;\r\n      out[i * 4 + 1] = g;\r\n      out[i * 4 + 2] = b;\r\n      out[i * 4 + 3] = a;\r\n    }\r\n    else\r\n    {\r\n      out[i * 8 + 0] = out[i * 8 + 1] = r;\r\n      out[i * 8 + 2] = out[i * 8 + 3] = g;\r\n      out[i * 8 + 4] = out[i * 8 + 5] = b;\r\n      out[i * 8 + 6] = out[i * 8 + 7] = a;\r\n    }\r\n  }\r\n\r\n  return 0; /*no error*/\r\n}\r\n\r\n/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/\r\nstatic void rgba16ToPixel(unsigned char* out, size_t i,\r\n                         const LodePNGColorMode* mode,\r\n                         unsigned short r, unsigned short g, unsigned short b, unsigned short a)\r\n{\r\n  if(mode->colortype == LCT_GREY)\r\n  {\r\n    unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;\r\n    out[i * 2 + 0] = (grey >> 8) & 255;\r\n    out[i * 2 + 1] = grey & 255;\r\n  }\r\n  else if(mode->colortype == LCT_RGB)\r\n  {\r\n    out[i * 6 + 0] = (r >> 8) & 255;\r\n    out[i * 6 + 1] = r & 255;\r\n    out[i * 6 + 2] = (g >> 8) & 255;\r\n    out[i * 6 + 3] = g & 255;\r\n    out[i * 6 + 4] = (b >> 8) & 255;\r\n    out[i * 6 + 5] = b & 255;\r\n  }\r\n  else if(mode->colortype == LCT_GREY_ALPHA)\r\n  {\r\n    unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;\r\n    out[i * 4 + 0] = (grey >> 8) & 255;\r\n    out[i * 4 + 1] = grey & 255;\r\n    out[i * 4 + 2] = (a >> 8) & 255;\r\n    out[i * 4 + 3] = a & 255;\r\n  }\r\n  else if(mode->colortype == LCT_RGBA)\r\n  {\r\n    out[i * 8 + 0] = (r >> 8) & 255;\r\n    out[i * 8 + 1] = r & 255;\r\n    out[i * 8 + 2] = (g >> 8) & 255;\r\n    out[i * 8 + 3] = g & 255;\r\n    out[i * 8 + 4] = (b >> 8) & 255;\r\n    out[i * 8 + 5] = b & 255;\r\n    out[i * 8 + 6] = (a >> 8) & 255;\r\n    out[i * 8 + 7] = a & 255;\r\n  }\r\n}\r\n\r\n/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/\r\nstatic void getPixelColorRGBA8(unsigned char* r, unsigned char* g,\r\n                               unsigned char* b, unsigned char* a,\r\n                               const unsigned char* in, size_t i,\r\n                               const LodePNGColorMode* mode)\r\n{\r\n  if(mode->colortype == LCT_GREY)\r\n  {\r\n    if(mode->bitdepth == 8)\r\n    {\r\n      *r = *g = *b = in[i];\r\n      if(mode->key_defined && *r == mode->key_r) *a = 0;\r\n      else *a = 255;\r\n    }\r\n    else if(mode->bitdepth == 16)\r\n    {\r\n      *r = *g = *b = in[i * 2 + 0];\r\n      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\r\n      else *a = 255;\r\n    }\r\n    else\r\n    {\r\n      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/\r\n      size_t j = i * mode->bitdepth;\r\n      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);\r\n      *r = *g = *b = (value * 255) / highest;\r\n      if(mode->key_defined && value == mode->key_r) *a = 0;\r\n      else *a = 255;\r\n    }\r\n  }\r\n  else if(mode->colortype == LCT_RGB)\r\n  {\r\n    if(mode->bitdepth == 8)\r\n    {\r\n      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];\r\n      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;\r\n      else *a = 255;\r\n    }\r\n    else\r\n    {\r\n      *r = in[i * 6 + 0];\r\n      *g = in[i * 6 + 2];\r\n      *b = in[i * 6 + 4];\r\n      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\r\n         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\r\n         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\r\n      else *a = 255;\r\n    }\r\n  }\r\n  else if(mode->colortype == LCT_PALETTE)\r\n  {\r\n    unsigned index;\r\n    if(mode->bitdepth == 8) index = in[i];\r\n    else\r\n    {\r\n      size_t j = i * mode->bitdepth;\r\n      index = readBitsFromReversedStream(&j, in, mode->bitdepth);\r\n    }\r\n\r\n    if(index >= mode->palettesize)\r\n    {\r\n      /*This is an error according to the PNG spec, but common PNG decoders make it black instead.\r\n      Done here too, slightly faster due to no error handling needed.*/\r\n      *r = *g = *b = 0;\r\n      *a = 255;\r\n    }\r\n    else\r\n    {\r\n      *r = mode->palette[index * 4 + 0];\r\n      *g = mode->palette[index * 4 + 1];\r\n      *b = mode->palette[index * 4 + 2];\r\n      *a = mode->palette[index * 4 + 3];\r\n    }\r\n  }\r\n  else if(mode->colortype == LCT_GREY_ALPHA)\r\n  {\r\n    if(mode->bitdepth == 8)\r\n    {\r\n      *r = *g = *b = in[i * 2 + 0];\r\n      *a = in[i * 2 + 1];\r\n    }\r\n    else\r\n    {\r\n      *r = *g = *b = in[i * 4 + 0];\r\n      *a = in[i * 4 + 2];\r\n    }\r\n  }\r\n  else if(mode->colortype == LCT_RGBA)\r\n  {\r\n    if(mode->bitdepth == 8)\r\n    {\r\n      *r = in[i * 4 + 0];\r\n      *g = in[i * 4 + 1];\r\n      *b = in[i * 4 + 2];\r\n      *a = in[i * 4 + 3];\r\n    }\r\n    else\r\n    {\r\n      *r = in[i * 8 + 0];\r\n      *g = in[i * 8 + 2];\r\n      *b = in[i * 8 + 4];\r\n      *a = in[i * 8 + 6];\r\n    }\r\n  }\r\n}\r\n\r\n/*Similar to getPixelColorRGBA8, but with all the for loops inside of the color\r\nmode test cases, optimized to convert the colors much faster, when converting\r\nto RGBA or RGB with 8 bit per cannel. buffer must be RGBA or RGB output with\r\nenough memory, if has_alpha is true the output is RGBA. mode has the color mode\r\nof the input buffer.*/\r\nstatic void getPixelColorsRGBA8(unsigned char* buffer, size_t numpixels,\r\n                                unsigned has_alpha, const unsigned char* in,\r\n                                const LodePNGColorMode* mode)\r\n{\r\n  unsigned num_channels = has_alpha ? 4 : 3;\r\n  size_t i;\r\n  if(mode->colortype == LCT_GREY)\r\n  {\r\n    if(mode->bitdepth == 8)\r\n    {\r\n      for(i = 0; i != numpixels; ++i, buffer += num_channels)\r\n      {\r\n        buffer[0] = buffer[1] = buffer[2] = in[i];\r\n        if(has_alpha) buffer[3] = mode->key_defined && in[i] == mode->key_r ? 0 : 255;\r\n      }\r\n    }\r\n    else if(mode->bitdepth == 16)\r\n    {\r\n      for(i = 0; i != numpixels; ++i, buffer += num_channels)\r\n      {\r\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2];\r\n        if(has_alpha) buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/\r\n      size_t j = 0;\r\n      for(i = 0; i != numpixels; ++i, buffer += num_channels)\r\n      {\r\n        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);\r\n        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;\r\n        if(has_alpha) buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;\r\n      }\r\n    }\r\n  }\r\n  else if(mode->colortype == LCT_RGB)\r\n  {\r\n    if(mode->bitdepth == 8)\r\n    {\r\n      for(i = 0; i != numpixels; ++i, buffer += num_channels)\r\n      {\r\n        buffer[0] = in[i * 3 + 0];\r\n        buffer[1] = in[i * 3 + 1];\r\n        buffer[2] = in[i * 3 + 2];\r\n        if(has_alpha) buffer[3] = mode->key_defined && buffer[0] == mode->key_r\r\n           && buffer[1]== mode->key_g && buffer[2] == mode->key_b ? 0 : 255;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      for(i = 0; i != numpixels; ++i, buffer += num_channels)\r\n      {\r\n        buffer[0] = in[i * 6 + 0];\r\n        buffer[1] = in[i * 6 + 2];\r\n        buffer[2] = in[i * 6 + 4];\r\n        if(has_alpha) buffer[3] = mode->key_defined\r\n           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\r\n           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\r\n           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;\r\n      }\r\n    }\r\n  }\r\n  else if(mode->colortype == LCT_PALETTE)\r\n  {\r\n    unsigned index;\r\n    size_t j = 0;\r\n    for(i = 0; i != numpixels; ++i, buffer += num_channels)\r\n    {\r\n      if(mode->bitdepth == 8) index = in[i];\r\n      else index = readBitsFromReversedStream(&j, in, mode->bitdepth);\r\n\r\n      if(index >= mode->palettesize)\r\n      {\r\n        /*This is an error according to the PNG spec, but most PNG decoders make it black instead.\r\n        Done here too, slightly faster due to no error handling needed.*/\r\n        buffer[0] = buffer[1] = buffer[2] = 0;\r\n        if(has_alpha) buffer[3] = 255;\r\n      }\r\n      else\r\n      {\r\n        buffer[0] = mode->palette[index * 4 + 0];\r\n        buffer[1] = mode->palette[index * 4 + 1];\r\n        buffer[2] = mode->palette[index * 4 + 2];\r\n        if(has_alpha) buffer[3] = mode->palette[index * 4 + 3];\r\n      }\r\n    }\r\n  }\r\n  else if(mode->colortype == LCT_GREY_ALPHA)\r\n  {\r\n    if(mode->bitdepth == 8)\r\n    {\r\n      for(i = 0; i != numpixels; ++i, buffer += num_channels)\r\n      {\r\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];\r\n        if(has_alpha) buffer[3] = in[i * 2 + 1];\r\n      }\r\n    }\r\n    else\r\n    {\r\n      for(i = 0; i != numpixels; ++i, buffer += num_channels)\r\n      {\r\n        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];\r\n        if(has_alpha) buffer[3] = in[i * 4 + 2];\r\n      }\r\n    }\r\n  }\r\n  else if(mode->colortype == LCT_RGBA)\r\n  {\r\n    if(mode->bitdepth == 8)\r\n    {\r\n      for(i = 0; i != numpixels; ++i, buffer += num_channels)\r\n      {\r\n        buffer[0] = in[i * 4 + 0];\r\n        buffer[1] = in[i * 4 + 1];\r\n        buffer[2] = in[i * 4 + 2];\r\n        if(has_alpha) buffer[3] = in[i * 4 + 3];\r\n      }\r\n    }\r\n    else\r\n    {\r\n      for(i = 0; i != numpixels; ++i, buffer += num_channels)\r\n      {\r\n        buffer[0] = in[i * 8 + 0];\r\n        buffer[1] = in[i * 8 + 2];\r\n        buffer[2] = in[i * 8 + 4];\r\n        if(has_alpha) buffer[3] = in[i * 8 + 6];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with\r\ngiven color type, but the given color type must be 16-bit itself.*/\r\nstatic void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,\r\n                                const unsigned char* in, size_t i, const LodePNGColorMode* mode)\r\n{\r\n  if(mode->colortype == LCT_GREY)\r\n  {\r\n    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];\r\n    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\r\n    else *a = 65535;\r\n  }\r\n  else if(mode->colortype == LCT_RGB)\r\n  {\r\n    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];\r\n    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];\r\n    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];\r\n    if(mode->key_defined\r\n       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\r\n       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\r\n       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\r\n    else *a = 65535;\r\n  }\r\n  else if(mode->colortype == LCT_GREY_ALPHA)\r\n  {\r\n    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];\r\n    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];\r\n  }\r\n  else if(mode->colortype == LCT_RGBA)\r\n  {\r\n    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];\r\n    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];\r\n    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];\r\n    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];\r\n  }\r\n}\r\n\r\nunsigned lodepng_convert(unsigned char* out, const unsigned char* in,\r\n                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,\r\n                         unsigned w, unsigned h)\r\n{\r\n  size_t i;\r\n  ColorTree tree;\r\n  size_t numpixels = w * h;\r\n\r\n  if(lodepng_color_mode_equal(mode_out, mode_in))\r\n  {\r\n    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);\r\n    for(i = 0; i != numbytes; ++i) out[i] = in[i];\r\n    return 0;\r\n  }\r\n\r\n  if(mode_out->colortype == LCT_PALETTE)\r\n  {\r\n    size_t palettesize = mode_out->palettesize;\r\n    const unsigned char* palette = mode_out->palette;\r\n    size_t palsize = 1u << mode_out->bitdepth;\r\n    /*if the user specified output palette but did not give the values, assume\r\n    they want the values of the input color type (assuming that one is palette).\r\n    Note that we never create a new palette ourselves.*/\r\n    if(palettesize == 0)\r\n    {\r\n      palettesize = mode_in->palettesize;\r\n      palette = mode_in->palette;\r\n    }\r\n    if(palettesize < palsize) palsize = palettesize;\r\n    color_tree_init(&tree);\r\n    for(i = 0; i != palsize; ++i)\r\n    {\r\n      const unsigned char* p = &palette[i * 4];\r\n      color_tree_add(&tree, p[0], p[1], p[2], p[3], i);\r\n    }\r\n  }\r\n\r\n  if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16)\r\n  {\r\n    for(i = 0; i != numpixels; ++i)\r\n    {\r\n      unsigned short r = 0, g = 0, b = 0, a = 0;\r\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);\r\n      rgba16ToPixel(out, i, mode_out, r, g, b, a);\r\n    }\r\n  }\r\n  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA)\r\n  {\r\n    getPixelColorsRGBA8(out, numpixels, 1, in, mode_in);\r\n  }\r\n  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB)\r\n  {\r\n    getPixelColorsRGBA8(out, numpixels, 0, in, mode_in);\r\n  }\r\n  else\r\n  {\r\n    unsigned char r = 0, g = 0, b = 0, a = 0;\r\n    for(i = 0; i != numpixels; ++i)\r\n    {\r\n      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);\r\n      CERROR_TRY_RETURN(rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a));\r\n    }\r\n  }\r\n\r\n  if(mode_out->colortype == LCT_PALETTE)\r\n  {\r\n    color_tree_cleanup(&tree);\r\n  }\r\n\r\n  return 0; /*no error*/\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n\r\nvoid lodepng_color_profile_init(LodePNGColorProfile* profile)\r\n{\r\n  profile->colored = 0;\r\n  profile->key = 0;\r\n  profile->key_r = profile->key_g = profile->key_b = 0;\r\n  profile->alpha = 0;\r\n  profile->numcolors = 0;\r\n  profile->bits = 1;\r\n}\r\n\r\n/*function used for debug purposes with C++*/\r\n/*void printColorProfile(LodePNGColorProfile* p)\r\n{\r\n  std::cout << \"colored: \" << (int)p->colored << \", \";\r\n  std::cout << \"key: \" << (int)p->key << \", \";\r\n  std::cout << \"key_r: \" << (int)p->key_r << \", \";\r\n  std::cout << \"key_g: \" << (int)p->key_g << \", \";\r\n  std::cout << \"key_b: \" << (int)p->key_b << \", \";\r\n  std::cout << \"alpha: \" << (int)p->alpha << \", \";\r\n  std::cout << \"numcolors: \" << (int)p->numcolors << \", \";\r\n  std::cout << \"bits: \" << (int)p->bits << std::endl;\r\n}*/\r\n\r\n/*Returns how many bits needed to represent given value (max 8 bit)*/\r\nstatic unsigned getValueRequiredBits(unsigned char value)\r\n{\r\n  if(value == 0 || value == 255) return 1;\r\n  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/\r\n  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;\r\n  return 8;\r\n}\r\n\r\n/*profile must already have been inited with mode.\r\nIt's ok to set some parameters of profile to done already.*/\r\nunsigned lodepng_get_color_profile(LodePNGColorProfile* profile,\r\n                                   const unsigned char* in, unsigned w, unsigned h,\r\n                                   const LodePNGColorMode* mode)\r\n{\r\n  unsigned error = 0;\r\n  size_t i;\r\n  ColorTree tree;\r\n  size_t numpixels = w * h;\r\n\r\n  unsigned colored_done = lodepng_is_greyscale_type(mode) ? 1 : 0;\r\n  unsigned alpha_done = lodepng_can_have_alpha(mode) ? 0 : 1;\r\n  unsigned numcolors_done = 0;\r\n  unsigned bpp = lodepng_get_bpp(mode);\r\n  unsigned bits_done = bpp == 1 ? 1 : 0;\r\n  unsigned maxnumcolors = 257;\r\n  unsigned sixteen = 0;\r\n  if(bpp <= 8) maxnumcolors = bpp == 1 ? 2 : (bpp == 2 ? 4 : (bpp == 4 ? 16 : 256));\r\n\r\n  color_tree_init(&tree);\r\n\r\n  /*Check if the 16-bit input is truly 16-bit*/\r\n  if(mode->bitdepth == 16)\r\n  {\r\n    unsigned short r, g, b, a;\r\n    for(i = 0; i != numpixels; ++i)\r\n    {\r\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);\r\n      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||\r\n         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/\r\n      {\r\n        sixteen = 1;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if(sixteen)\r\n  {\r\n    unsigned short r = 0, g = 0, b = 0, a = 0;\r\n    profile->bits = 16;\r\n    bits_done = numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/\r\n\r\n    for(i = 0; i != numpixels; ++i)\r\n    {\r\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);\r\n\r\n      if(!colored_done && (r != g || r != b))\r\n      {\r\n        profile->colored = 1;\r\n        colored_done = 1;\r\n      }\r\n\r\n      if(!alpha_done)\r\n      {\r\n        unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);\r\n        if(a != 65535 && (a != 0 || (profile->key && !matchkey)))\r\n        {\r\n          profile->alpha = 1;\r\n          profile->key = 0;\r\n          alpha_done = 1;\r\n        }\r\n        else if(a == 0 && !profile->alpha && !profile->key)\r\n        {\r\n          profile->key = 1;\r\n          profile->key_r = r;\r\n          profile->key_g = g;\r\n          profile->key_b = b;\r\n        }\r\n        else if(a == 65535 && profile->key && matchkey)\r\n        {\r\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\r\n          profile->alpha = 1;\r\n          profile->key = 0;\r\n          alpha_done = 1;\r\n        }\r\n      }\r\n      if(alpha_done && numcolors_done && colored_done && bits_done) break;\r\n    }\r\n\r\n    if(profile->key && !profile->alpha)\r\n    {\r\n      for(i = 0; i != numpixels; ++i)\r\n      {\r\n        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);\r\n        if(a != 0 && r == profile->key_r && g == profile->key_g && b == profile->key_b)\r\n        {\r\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\r\n          profile->alpha = 1;\r\n          profile->key = 0;\r\n          alpha_done = 1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else /* < 16-bit */\r\n  {\r\n    unsigned char r = 0, g = 0, b = 0, a = 0;\r\n    for(i = 0; i != numpixels; ++i)\r\n    {\r\n      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode);\r\n\r\n      if(!bits_done && profile->bits < 8)\r\n      {\r\n        /*only r is checked, < 8 bits is only relevant for greyscale*/\r\n        unsigned bits = getValueRequiredBits(r);\r\n        if(bits > profile->bits) profile->bits = bits;\r\n      }\r\n      bits_done = (profile->bits >= bpp);\r\n\r\n      if(!colored_done && (r != g || r != b))\r\n      {\r\n        profile->colored = 1;\r\n        colored_done = 1;\r\n        if(profile->bits < 8) profile->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/\r\n      }\r\n\r\n      if(!alpha_done)\r\n      {\r\n        unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);\r\n        if(a != 255 && (a != 0 || (profile->key && !matchkey)))\r\n        {\r\n          profile->alpha = 1;\r\n          profile->key = 0;\r\n          alpha_done = 1;\r\n          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\r\n        }\r\n        else if(a == 0 && !profile->alpha && !profile->key)\r\n        {\r\n          profile->key = 1;\r\n          profile->key_r = r;\r\n          profile->key_g = g;\r\n          profile->key_b = b;\r\n        }\r\n        else if(a == 255 && profile->key && matchkey)\r\n        {\r\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\r\n          profile->alpha = 1;\r\n          profile->key = 0;\r\n          alpha_done = 1;\r\n          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\r\n        }\r\n      }\r\n\r\n      if(!numcolors_done)\r\n      {\r\n        if(!color_tree_has(&tree, r, g, b, a))\r\n        {\r\n          color_tree_add(&tree, r, g, b, a, profile->numcolors);\r\n          if(profile->numcolors < 256)\r\n          {\r\n            unsigned char* p = profile->palette;\r\n            unsigned n = profile->numcolors;\r\n            p[n * 4 + 0] = r;\r\n            p[n * 4 + 1] = g;\r\n            p[n * 4 + 2] = b;\r\n            p[n * 4 + 3] = a;\r\n          }\r\n          ++profile->numcolors;\r\n          numcolors_done = profile->numcolors >= maxnumcolors;\r\n        }\r\n      }\r\n\r\n      if(alpha_done && numcolors_done && colored_done && bits_done) break;\r\n    }\r\n\r\n    if(profile->key && !profile->alpha)\r\n    {\r\n      for(i = 0; i != numpixels; ++i)\r\n      {\r\n        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode);\r\n        if(a != 0 && r == profile->key_r && g == profile->key_g && b == profile->key_b)\r\n        {\r\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\r\n          profile->alpha = 1;\r\n          profile->key = 0;\r\n          alpha_done = 1;\r\n          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\r\n        }\r\n      }\r\n    }\r\n\r\n    /*make the profile's key always 16-bit for consistency - repeat each byte twice*/\r\n    profile->key_r += (profile->key_r << 8);\r\n    profile->key_g += (profile->key_g << 8);\r\n    profile->key_b += (profile->key_b << 8);\r\n  }\r\n\r\n  color_tree_cleanup(&tree);\r\n  return error;\r\n}\r\n\r\n/*Automatically chooses color type that gives smallest amount of bits in the\r\noutput image, e.g. grey if there are only greyscale pixels, palette if there\r\nare less than 256 colors, ...\r\nUpdates values of mode with a potentially smaller color model. mode_out should\r\ncontain the user chosen color model, but will be overwritten with the new chosen one.*/\r\nunsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,\r\n                                   const unsigned char* image, unsigned w, unsigned h,\r\n                                   const LodePNGColorMode* mode_in)\r\n{\r\n  LodePNGColorProfile prof;\r\n  unsigned error = 0;\r\n  unsigned i, n, palettebits, palette_ok;\r\n\r\n  lodepng_color_profile_init(&prof);\r\n  error = lodepng_get_color_profile(&prof, image, w, h, mode_in);\r\n  if(error) return error;\r\n  mode_out->key_defined = 0;\r\n\r\n  if(prof.key && w * h <= 16)\r\n  {\r\n    prof.alpha = 1; /*too few pixels to justify tRNS chunk overhead*/\r\n    prof.key = 0;\r\n    if(prof.bits < 8) prof.bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\r\n  }\r\n  n = prof.numcolors;\r\n  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));\r\n  palette_ok = n <= 256 && prof.bits <= 8;\r\n  if(w * h < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/\r\n  if(!prof.colored && prof.bits <= palettebits) palette_ok = 0; /*grey is less overhead*/\r\n\r\n  if(palette_ok)\r\n  {\r\n    unsigned char* p = prof.palette;\r\n    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/\r\n    for(i = 0; i != prof.numcolors; ++i)\r\n    {\r\n      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);\r\n      if(error) break;\r\n    }\r\n\r\n    mode_out->colortype = LCT_PALETTE;\r\n    mode_out->bitdepth = palettebits;\r\n\r\n    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize\r\n        && mode_in->bitdepth == mode_out->bitdepth)\r\n    {\r\n      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/\r\n      lodepng_color_mode_cleanup(mode_out);\r\n      lodepng_color_mode_copy(mode_out, mode_in);\r\n    }\r\n  }\r\n  else /*8-bit or 16-bit per channel*/\r\n  {\r\n    mode_out->bitdepth = prof.bits;\r\n    mode_out->colortype = prof.alpha ? (prof.colored ? LCT_RGBA : LCT_GREY_ALPHA)\r\n                                     : (prof.colored ? LCT_RGB : LCT_GREY);\r\n\r\n    if(prof.key)\r\n    {\r\n      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*profile always uses 16-bit, mask converts it*/\r\n      mode_out->key_r = prof.key_r & mask;\r\n      mode_out->key_g = prof.key_g & mask;\r\n      mode_out->key_b = prof.key_b & mask;\r\n      mode_out->key_defined = 1;\r\n    }\r\n  }\r\n\r\n  return error;\r\n}\r\n\r\n#endif /* #ifdef LODEPNG_COMPILE_ENCODER */\r\n\r\n/*\r\nPaeth predicter, used by PNG filter type 4\r\nThe parameters are of type short, but should come from unsigned chars, the shorts\r\nare only needed to make the paeth calculation correct.\r\n*/\r\nstatic unsigned char paethPredictor(short a, short b, short c)\r\n{\r\n  short pa = abs(b - c);\r\n  short pb = abs(a - c);\r\n  short pc = abs(a + b - c - c);\r\n\r\n  if(pc < pa && pc < pb) return (unsigned char)c;\r\n  else if(pb < pa) return (unsigned char)b;\r\n  else return (unsigned char)a;\r\n}\r\n\r\n/*shared values used by multiple Adam7 related functions*/\r\n\r\nstatic const unsigned ADAM7_IX[7] = { 0, 4, 0, 2, 0, 1, 0 }; /*x start values*/\r\nstatic const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/\r\nstatic const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/\r\nstatic const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/\r\n\r\n/*\r\nOutputs various dimensions and positions in the image related to the Adam7 reduced images.\r\npassw: output containing the width of the 7 passes\r\npassh: output containing the height of the 7 passes\r\nfilter_passstart: output containing the index of the start and end of each\r\n reduced image with filter bytes\r\npadded_passstart output containing the index of the start and end of each\r\n reduced image when without filter bytes but with padded scanlines\r\npassstart: output containing the index of the start and end of each reduced\r\n image without padding between scanlines, but still padding between the images\r\nw, h: width and height of non-interlaced image\r\nbpp: bits per pixel\r\n\"padded\" is only relevant if bpp is less than 8 and a scanline or image does not\r\n end at a full byte\r\n*/\r\nstatic void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],\r\n                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)\r\n{\r\n  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/\r\n  unsigned i;\r\n\r\n  /*calculate width and height in pixels of each pass*/\r\n  for(i = 0; i != 7; ++i)\r\n  {\r\n    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];\r\n    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];\r\n    if(passw[i] == 0) passh[i] = 0;\r\n    if(passh[i] == 0) passw[i] = 0;\r\n  }\r\n\r\n  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;\r\n  for(i = 0; i != 7; ++i)\r\n  {\r\n    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/\r\n    filter_passstart[i + 1] = filter_passstart[i]\r\n                            + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0);\r\n    /*bits padded if needed to fill full byte at end of each scanline*/\r\n    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8);\r\n    /*only padded at end of reduced image*/\r\n    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8;\r\n  }\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / PNG Decoder                                                            / */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n/*read the information from the header and store it in the LodePNGInfo. return value is error*/\r\nunsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,\r\n                         const unsigned char* in, size_t insize)\r\n{\r\n  LodePNGInfo* info = &state->info_png;\r\n  if(insize == 0 || in == 0)\r\n  {\r\n    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/\r\n  }\r\n  if(insize < 33)\r\n  {\r\n    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/\r\n  }\r\n\r\n  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/\r\n  lodepng_info_cleanup(info);\r\n  lodepng_info_init(info);\r\n\r\n  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71\r\n     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10)\r\n  {\r\n    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/\r\n  }\r\n  if(lodepng_chunk_length(in + 8) != 13)\r\n  {\r\n    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/\r\n  }\r\n  if(!lodepng_chunk_type_equals(in + 8, \"IHDR\"))\r\n  {\r\n    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/\r\n  }\r\n\r\n  /*read the values given in the header*/\r\n  *w = lodepng_read32bitInt(&in[16]);\r\n  *h = lodepng_read32bitInt(&in[20]);\r\n  info->color.bitdepth = in[24];\r\n  info->color.colortype = (LodePNGColorType)in[25];\r\n  info->compression_method = in[26];\r\n  info->filter_method = in[27];\r\n  info->interlace_method = in[28];\r\n\r\n  if(*w == 0 || *h == 0)\r\n  {\r\n    CERROR_RETURN_ERROR(state->error, 93);\r\n  }\r\n\r\n  if(!state->decoder.ignore_crc)\r\n  {\r\n    unsigned CRC = lodepng_read32bitInt(&in[29]);\r\n    unsigned checksum = lodepng_crc32(&in[12], 17);\r\n    if(CRC != checksum)\r\n    {\r\n      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/\r\n    }\r\n  }\r\n\r\n  /*error: only compression method 0 is allowed in the specification*/\r\n  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);\r\n  /*error: only filter method 0 is allowed in the specification*/\r\n  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);\r\n  /*error: only interlace methods 0 and 1 exist in the specification*/\r\n  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);\r\n\r\n  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);\r\n  return state->error;\r\n}\r\n\r\nstatic unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,\r\n                                 size_t bytewidth, unsigned char filterType, size_t length)\r\n{\r\n  /*\r\n  For PNG filter method 0\r\n  unfilter a PNG image scanline by scanline. when the pixels are smaller than 1 byte,\r\n  the filter works byte per byte (bytewidth = 1)\r\n  precon is the previous unfiltered scanline, recon the result, scanline the current one\r\n  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead\r\n  recon and scanline MAY be the same memory address! precon must be disjoint.\r\n  */\r\n\r\n  size_t i;\r\n  switch(filterType)\r\n  {\r\n    case 0:\r\n      for(i = 0; i != length; ++i) recon[i] = scanline[i];\r\n      break;\r\n    case 1:\r\n      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];\r\n      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];\r\n      break;\r\n    case 2:\r\n      if(precon)\r\n      {\r\n        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];\r\n      }\r\n      else\r\n      {\r\n        for(i = 0; i != length; ++i) recon[i] = scanline[i];\r\n      }\r\n      break;\r\n    case 3:\r\n      if(precon)\r\n      {\r\n        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1);\r\n        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1);\r\n      }\r\n      else\r\n      {\r\n        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];\r\n        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1);\r\n      }\r\n      break;\r\n    case 4:\r\n      if(precon)\r\n      {\r\n        for(i = 0; i != bytewidth; ++i)\r\n        {\r\n          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/\r\n        }\r\n        for(i = bytewidth; i < length; ++i)\r\n        {\r\n          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));\r\n        }\r\n      }\r\n      else\r\n      {\r\n        for(i = 0; i != bytewidth; ++i)\r\n        {\r\n          recon[i] = scanline[i];\r\n        }\r\n        for(i = bytewidth; i < length; ++i)\r\n        {\r\n          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/\r\n          recon[i] = (scanline[i] + recon[i - bytewidth]);\r\n        }\r\n      }\r\n      break;\r\n    default: return 36; /*error: unexisting filter type given*/\r\n  }\r\n  return 0;\r\n}\r\n\r\nstatic unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)\r\n{\r\n  /*\r\n  For PNG filter method 0\r\n  this function unfilters a single image (e.g. without interlacing this is called once, with Adam7 seven times)\r\n  out must have enough bytes allocated already, in must have the scanlines + 1 filtertype byte per scanline\r\n  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel\r\n  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)\r\n  */\r\n\r\n  unsigned y;\r\n  unsigned char* prevline = 0;\r\n\r\n  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/\r\n  size_t bytewidth = (bpp + 7) / 8;\r\n  size_t linebytes = (w * bpp + 7) / 8;\r\n\r\n  for(y = 0; y < h; ++y)\r\n  {\r\n    size_t outindex = linebytes * y;\r\n    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\r\n    unsigned char filterType = in[inindex];\r\n\r\n    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));\r\n\r\n    prevline = &out[outindex];\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/*\r\nin: Adam7 interlaced image, with no padding bits between scanlines, but between\r\n reduced images so that each reduced image starts at a byte.\r\nout: the same pixels, but re-ordered so that they're now a non-interlaced image with size w*h\r\nbpp: bits per pixel\r\nout has the following size in bits: w * h * bpp.\r\nin is possibly bigger due to padding bits between reduced images.\r\nout must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation\r\n(because that's likely a little bit faster)\r\nNOTE: comments about padding bits are only relevant if bpp < 8\r\n*/\r\nstatic void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)\r\n{\r\n  unsigned passw[7], passh[7];\r\n  size_t filter_passstart[8], padded_passstart[8], passstart[8];\r\n  unsigned i;\r\n\r\n  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\r\n\r\n  if(bpp >= 8)\r\n  {\r\n    for(i = 0; i != 7; ++i)\r\n    {\r\n      unsigned x, y, b;\r\n      size_t bytewidth = bpp / 8;\r\n      for(y = 0; y < passh[i]; ++y)\r\n      for(x = 0; x < passw[i]; ++x)\r\n      {\r\n        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;\r\n        size_t pixeloutstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;\r\n        for(b = 0; b < bytewidth; ++b)\r\n        {\r\n          out[pixeloutstart + b] = in[pixelinstart + b];\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/\r\n  {\r\n    for(i = 0; i != 7; ++i)\r\n    {\r\n      unsigned x, y, b;\r\n      unsigned ilinebits = bpp * passw[i];\r\n      unsigned olinebits = bpp * w;\r\n      size_t obp, ibp; /*bit pointers (for out and in buffer)*/\r\n      for(y = 0; y < passh[i]; ++y)\r\n      for(x = 0; x < passw[i]; ++x)\r\n      {\r\n        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);\r\n        obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;\r\n        for(b = 0; b < bpp; ++b)\r\n        {\r\n          unsigned char bit = readBitFromReversedStream(&ibp, in);\r\n          /*note that this function assumes the out buffer is completely 0, use setBitOfReversedStream otherwise*/\r\n          setBitOfReversedStream0(&obp, out, bit);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nstatic void removePaddingBits(unsigned char* out, const unsigned char* in,\r\n                              size_t olinebits, size_t ilinebits, unsigned h)\r\n{\r\n  /*\r\n  After filtering there are still padding bits if scanlines have non multiple of 8 bit amounts. They need\r\n  to be removed (except at last scanline of (Adam7-reduced) image) before working with pure image buffers\r\n  for the Adam7 code, the color convert code and the output to the user.\r\n  in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must\r\n  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits\r\n  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7\r\n  only useful if (ilinebits - olinebits) is a value in the range 1..7\r\n  */\r\n  unsigned y;\r\n  size_t diff = ilinebits - olinebits;\r\n  size_t ibp = 0, obp = 0; /*input and output bit pointers*/\r\n  for(y = 0; y < h; ++y)\r\n  {\r\n    size_t x;\r\n    for(x = 0; x < olinebits; ++x)\r\n    {\r\n      unsigned char bit = readBitFromReversedStream(&ibp, in);\r\n      setBitOfReversedStream(&obp, out, bit);\r\n    }\r\n    ibp += diff;\r\n  }\r\n}\r\n\r\n/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from\r\nthe IDAT chunks (with filter index bytes and possible padding bits)\r\nreturn value is error*/\r\nstatic unsigned postProcessScanlines(unsigned char* out, unsigned char* in,\r\n                                     unsigned w, unsigned h, const LodePNGInfo* info_png)\r\n{\r\n  /*\r\n  This function converts the filtered-padded-interlaced data into pure 2D image buffer with the PNG's colortype.\r\n  Steps:\r\n  *) if no Adam7: 1) unfilter 2) remove padding bits (= posible extra bits per scanline if bpp < 8)\r\n  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace\r\n  NOTE: the in buffer will be overwritten with intermediate data!\r\n  */\r\n  unsigned bpp = lodepng_get_bpp(&info_png->color);\r\n  if(bpp == 0) return 31; /*error: invalid colortype*/\r\n\r\n  if(info_png->interlace_method == 0)\r\n  {\r\n    if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)\r\n    {\r\n      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));\r\n      removePaddingBits(out, in, w * bpp, ((w * bpp + 7) / 8) * 8, h);\r\n    }\r\n    /*we can immediately filter into the out buffer, no other steps needed*/\r\n    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));\r\n  }\r\n  else /*interlace_method is 1 (Adam7)*/\r\n  {\r\n    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];\r\n    unsigned i;\r\n\r\n    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\r\n\r\n    for(i = 0; i != 7; ++i)\r\n    {\r\n      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));\r\n      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,\r\n      move bytes instead of bits or move not at all*/\r\n      if(bpp < 8)\r\n      {\r\n        /*remove padding bits in scanlines; after this there still may be padding\r\n        bits between the different reduced images: each reduced image still starts nicely at a byte*/\r\n        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,\r\n                          ((passw[i] * bpp + 7) / 8) * 8, passh[i]);\r\n      }\r\n    }\r\n\r\n    Adam7_deinterlace(out, in, w, h, bpp);\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nstatic unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)\r\n{\r\n  unsigned pos = 0, i;\r\n  if(color->palette) lodepng_free(color->palette);\r\n  color->palettesize = chunkLength / 3;\r\n  color->palette = (unsigned char*)lodepng_malloc(4 * color->palettesize);\r\n  if(!color->palette && color->palettesize)\r\n  {\r\n    color->palettesize = 0;\r\n    return 83; /*alloc fail*/\r\n  }\r\n  if(color->palettesize > 256) return 38; /*error: palette too big*/\r\n\r\n  for(i = 0; i != color->palettesize; ++i)\r\n  {\r\n    color->palette[4 * i + 0] = data[pos++]; /*R*/\r\n    color->palette[4 * i + 1] = data[pos++]; /*G*/\r\n    color->palette[4 * i + 2] = data[pos++]; /*B*/\r\n    color->palette[4 * i + 3] = 255; /*alpha*/\r\n  }\r\n\r\n  return 0; /* OK */\r\n}\r\n\r\nstatic unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)\r\n{\r\n  unsigned i;\r\n  if(color->colortype == LCT_PALETTE)\r\n  {\r\n    /*error: more alpha values given than there are palette entries*/\r\n    if(chunkLength > color->palettesize) return 38;\r\n\r\n    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];\r\n  }\r\n  else if(color->colortype == LCT_GREY)\r\n  {\r\n    /*error: this chunk must be 2 bytes for greyscale image*/\r\n    if(chunkLength != 2) return 30;\r\n\r\n    color->key_defined = 1;\r\n    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];\r\n  }\r\n  else if(color->colortype == LCT_RGB)\r\n  {\r\n    /*error: this chunk must be 6 bytes for RGB image*/\r\n    if(chunkLength != 6) return 41;\r\n\r\n    color->key_defined = 1;\r\n    color->key_r = 256u * data[0] + data[1];\r\n    color->key_g = 256u * data[2] + data[3];\r\n    color->key_b = 256u * data[4] + data[5];\r\n  }\r\n  else return 42; /*error: tRNS chunk not allowed for other color models*/\r\n\r\n  return 0; /* OK */\r\n}\r\n\r\n\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n/*background color chunk (bKGD)*/\r\nstatic unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\r\n{\r\n  if(info->color.colortype == LCT_PALETTE)\r\n  {\r\n    /*error: this chunk must be 1 byte for indexed color image*/\r\n    if(chunkLength != 1) return 43;\r\n\r\n    info->background_defined = 1;\r\n    info->background_r = info->background_g = info->background_b = data[0];\r\n  }\r\n  else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)\r\n  {\r\n    /*error: this chunk must be 2 bytes for greyscale image*/\r\n    if(chunkLength != 2) return 44;\r\n\r\n    info->background_defined = 1;\r\n    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];\r\n  }\r\n  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)\r\n  {\r\n    /*error: this chunk must be 6 bytes for greyscale image*/\r\n    if(chunkLength != 6) return 45;\r\n\r\n    info->background_defined = 1;\r\n    info->background_r = 256u * data[0] + data[1];\r\n    info->background_g = 256u * data[2] + data[3];\r\n    info->background_b = 256u * data[4] + data[5];\r\n  }\r\n\r\n  return 0; /* OK */\r\n}\r\n\r\n/*text chunk (tEXt)*/\r\nstatic unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\r\n{\r\n  unsigned error = 0;\r\n  char *key = 0, *str = 0;\r\n  unsigned i;\r\n\r\n  while(!error) /*not really a while loop, only used to break on error*/\r\n  {\r\n    unsigned length, string2_begin;\r\n\r\n    length = 0;\r\n    while(length < chunkLength && data[length] != 0) ++length;\r\n    /*even though it's not allowed by the standard, no error is thrown if\r\n    there's no null termination char, if the text is empty*/\r\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\r\n\r\n    key = (char*)lodepng_malloc(length + 1);\r\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\r\n\r\n    key[length] = 0;\r\n    for(i = 0; i != length; ++i) key[i] = (char)data[i];\r\n\r\n    string2_begin = length + 1; /*skip keyword null terminator*/\r\n\r\n    length = chunkLength < string2_begin ? 0 : chunkLength - string2_begin;\r\n    str = (char*)lodepng_malloc(length + 1);\r\n    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/\r\n\r\n    str[length] = 0;\r\n    for(i = 0; i != length; ++i) str[i] = (char)data[string2_begin + i];\r\n\r\n    error = lodepng_add_text(info, key, str);\r\n\r\n    break;\r\n  }\r\n\r\n  lodepng_free(key);\r\n  lodepng_free(str);\r\n\r\n  return error;\r\n}\r\n\r\n/*compressed text chunk (zTXt)*/\r\nstatic unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,\r\n                               const unsigned char* data, size_t chunkLength)\r\n{\r\n  unsigned error = 0;\r\n  unsigned i;\r\n\r\n  unsigned length, string2_begin;\r\n  char *key = 0;\r\n  ucvector decoded;\r\n\r\n  ucvector_init(&decoded);\r\n\r\n  while(!error) /*not really a while loop, only used to break on error*/\r\n  {\r\n    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;\r\n    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/\r\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\r\n\r\n    key = (char*)lodepng_malloc(length + 1);\r\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\r\n\r\n    key[length] = 0;\r\n    for(i = 0; i != length; ++i) key[i] = (char)data[i];\r\n\r\n    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/\r\n\r\n    string2_begin = length + 2;\r\n    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/\r\n\r\n    length = chunkLength - string2_begin;\r\n    /*will fail if zlib error, e.g. if length is too small*/\r\n    error = zlib_decompress(&decoded.data, &decoded.size,\r\n                            (unsigned char*)(&data[string2_begin]),\r\n                            length, zlibsettings);\r\n    if(error) break;\r\n    ucvector_push_back(&decoded, 0);\r\n\r\n    error = lodepng_add_text(info, key, (char*)decoded.data);\r\n\r\n    break;\r\n  }\r\n\r\n  lodepng_free(key);\r\n  ucvector_cleanup(&decoded);\r\n\r\n  return error;\r\n}\r\n\r\n/*international text chunk (iTXt)*/\r\nstatic unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,\r\n                               const unsigned char* data, size_t chunkLength)\r\n{\r\n  unsigned error = 0;\r\n  unsigned i;\r\n\r\n  unsigned length, begin, compressed;\r\n  char *key = 0, *langtag = 0, *transkey = 0;\r\n  ucvector decoded;\r\n  ucvector_init(&decoded);\r\n\r\n  while(!error) /*not really a while loop, only used to break on error*/\r\n  {\r\n    /*Quick check if the chunk length isn't too small. Even without check\r\n    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/\r\n    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/\r\n\r\n    /*read the key*/\r\n    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;\r\n    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/\r\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\r\n\r\n    key = (char*)lodepng_malloc(length + 1);\r\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\r\n\r\n    key[length] = 0;\r\n    for(i = 0; i != length; ++i) key[i] = (char)data[i];\r\n\r\n    /*read the compression method*/\r\n    compressed = data[length + 1];\r\n    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/\r\n\r\n    /*even though it's not allowed by the standard, no error is thrown if\r\n    there's no null termination char, if the text is empty for the next 3 texts*/\r\n\r\n    /*read the langtag*/\r\n    begin = length + 3;\r\n    length = 0;\r\n    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;\r\n\r\n    langtag = (char*)lodepng_malloc(length + 1);\r\n    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/\r\n\r\n    langtag[length] = 0;\r\n    for(i = 0; i != length; ++i) langtag[i] = (char)data[begin + i];\r\n\r\n    /*read the transkey*/\r\n    begin += length + 1;\r\n    length = 0;\r\n    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;\r\n\r\n    transkey = (char*)lodepng_malloc(length + 1);\r\n    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/\r\n\r\n    transkey[length] = 0;\r\n    for(i = 0; i != length; ++i) transkey[i] = (char)data[begin + i];\r\n\r\n    /*read the actual text*/\r\n    begin += length + 1;\r\n\r\n    length = chunkLength < begin ? 0 : chunkLength - begin;\r\n\r\n    if(compressed)\r\n    {\r\n      /*will fail if zlib error, e.g. if length is too small*/\r\n      error = zlib_decompress(&decoded.data, &decoded.size,\r\n                              (unsigned char*)(&data[begin]),\r\n                              length, zlibsettings);\r\n      if(error) break;\r\n      if(decoded.allocsize < decoded.size) decoded.allocsize = decoded.size;\r\n      ucvector_push_back(&decoded, 0);\r\n    }\r\n    else\r\n    {\r\n      if(!ucvector_resize(&decoded, length + 1)) CERROR_BREAK(error, 83 /*alloc fail*/);\r\n\r\n      decoded.data[length] = 0;\r\n      for(i = 0; i != length; ++i) decoded.data[i] = data[begin + i];\r\n    }\r\n\r\n    error = lodepng_add_itext(info, key, langtag, transkey, (char*)decoded.data);\r\n\r\n    break;\r\n  }\r\n\r\n  lodepng_free(key);\r\n  lodepng_free(langtag);\r\n  lodepng_free(transkey);\r\n  ucvector_cleanup(&decoded);\r\n\r\n  return error;\r\n}\r\n\r\nstatic unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\r\n{\r\n  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/\r\n\r\n  info->time_defined = 1;\r\n  info->time.year = 256u * data[0] + data[1];\r\n  info->time.month = data[2];\r\n  info->time.day = data[3];\r\n  info->time.hour = data[4];\r\n  info->time.minute = data[5];\r\n  info->time.second = data[6];\r\n\r\n  return 0; /* OK */\r\n}\r\n\r\nstatic unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\r\n{\r\n  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/\r\n\r\n  info->phys_defined = 1;\r\n  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];\r\n  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];\r\n  info->phys_unit = data[8];\r\n\r\n  return 0; /* OK */\r\n}\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n\r\n/*read a PNG, the result will be in the same color type as the PNG (hence \"generic\")*/\r\nstatic void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,\r\n                          LodePNGState* state,\r\n                          const unsigned char* in, size_t insize)\r\n{\r\n  unsigned char IEND = 0;\r\n  const unsigned char* chunk;\r\n  size_t i;\r\n  ucvector idat; /*the data from idat chunks*/\r\n  ucvector scanlines;\r\n  size_t predict;\r\n  size_t numpixels;\r\n  size_t outsize = 0;\r\n\r\n  /*for unknown chunk order*/\r\n  unsigned unknown = 0;\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n\r\n  /*provide some proper output values if error will happen*/\r\n  *out = 0;\r\n\r\n  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/\r\n  if(state->error) return;\r\n\r\n  numpixels = *w * *h;\r\n\r\n  /*multiplication overflow*/\r\n  if(*h != 0 && numpixels / *h != *w) CERROR_RETURN(state->error, 92);\r\n  /*multiplication overflow possible further below. Allows up to 2^31-1 pixel\r\n  bytes with 16-bit RGBA, the rest is room for filter bytes.*/\r\n  if(numpixels > 268435455) CERROR_RETURN(state->error, 92);\r\n\r\n  ucvector_init(&idat);\r\n  chunk = &in[33]; /*first byte of the first chunk after the header*/\r\n\r\n  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.\r\n  IDAT data is put at the start of the in buffer*/\r\n  while(!IEND && !state->error)\r\n  {\r\n    unsigned chunkLength;\r\n    const unsigned char* data; /*the data in the chunk*/\r\n\r\n    /*error: size of the in buffer too small to contain next chunk*/\r\n    if((size_t)((chunk - in) + 12) > insize || chunk < in) CERROR_BREAK(state->error, 30);\r\n\r\n    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/\r\n    chunkLength = lodepng_chunk_length(chunk);\r\n    /*error: chunk length larger than the max PNG chunk size*/\r\n    if(chunkLength > 2147483647) CERROR_BREAK(state->error, 63);\r\n\r\n    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in)\r\n    {\r\n      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/\r\n    }\r\n\r\n    data = lodepng_chunk_data_const(chunk);\r\n\r\n    /*IDAT chunk, containing compressed image data*/\r\n    if(lodepng_chunk_type_equals(chunk, \"IDAT\"))\r\n    {\r\n      size_t oldsize = idat.size;\r\n      if(!ucvector_resize(&idat, oldsize + chunkLength)) CERROR_BREAK(state->error, 83 /*alloc fail*/);\r\n      for(i = 0; i != chunkLength; ++i) idat.data[oldsize + i] = data[i];\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n      critical_pos = 3;\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n    }\r\n    /*IEND chunk*/\r\n    else if(lodepng_chunk_type_equals(chunk, \"IEND\"))\r\n    {\r\n      IEND = 1;\r\n    }\r\n    /*palette chunk (PLTE)*/\r\n    else if(lodepng_chunk_type_equals(chunk, \"PLTE\"))\r\n    {\r\n      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);\r\n      if(state->error) break;\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n      critical_pos = 2;\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n    }\r\n    /*palette transparency chunk (tRNS)*/\r\n    else if(lodepng_chunk_type_equals(chunk, \"tRNS\"))\r\n    {\r\n      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);\r\n      if(state->error) break;\r\n    }\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n    /*background color chunk (bKGD)*/\r\n    else if(lodepng_chunk_type_equals(chunk, \"bKGD\"))\r\n    {\r\n      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);\r\n      if(state->error) break;\r\n    }\r\n    /*text chunk (tEXt)*/\r\n    else if(lodepng_chunk_type_equals(chunk, \"tEXt\"))\r\n    {\r\n      if(state->decoder.read_text_chunks)\r\n      {\r\n        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);\r\n        if(state->error) break;\r\n      }\r\n    }\r\n    /*compressed text chunk (zTXt)*/\r\n    else if(lodepng_chunk_type_equals(chunk, \"zTXt\"))\r\n    {\r\n      if(state->decoder.read_text_chunks)\r\n      {\r\n        state->error = readChunk_zTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);\r\n        if(state->error) break;\r\n      }\r\n    }\r\n    /*international text chunk (iTXt)*/\r\n    else if(lodepng_chunk_type_equals(chunk, \"iTXt\"))\r\n    {\r\n      if(state->decoder.read_text_chunks)\r\n      {\r\n        state->error = readChunk_iTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);\r\n        if(state->error) break;\r\n      }\r\n    }\r\n    else if(lodepng_chunk_type_equals(chunk, \"tIME\"))\r\n    {\r\n      state->error = readChunk_tIME(&state->info_png, data, chunkLength);\r\n      if(state->error) break;\r\n    }\r\n    else if(lodepng_chunk_type_equals(chunk, \"pHYs\"))\r\n    {\r\n      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);\r\n      if(state->error) break;\r\n    }\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n    else /*it's not an implemented chunk type, so ignore it: skip over the data*/\r\n    {\r\n      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/\r\n      if(!lodepng_chunk_ancillary(chunk)) CERROR_BREAK(state->error, 69);\r\n\r\n      unknown = 1;\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n      if(state->decoder.remember_unknown_chunks)\r\n      {\r\n        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],\r\n                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);\r\n        if(state->error) break;\r\n      }\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n    }\r\n\r\n    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/\r\n    {\r\n      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/\r\n    }\r\n\r\n    if(!IEND) chunk = lodepng_chunk_next_const(chunk);\r\n  }\r\n\r\n  ucvector_init(&scanlines);\r\n  /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.\r\n  If the decompressed size does not match the prediction, the image must be corrupt.*/\r\n  if(state->info_png.interlace_method == 0)\r\n  {\r\n    /*The extra *h is added because this are the filter bytes every scanline starts with*/\r\n    predict = lodepng_get_raw_size_idat(*w, *h, &state->info_png.color) + *h;\r\n  }\r\n  else\r\n  {\r\n    /*Adam-7 interlaced: predicted size is the sum of the 7 sub-images sizes*/\r\n    const LodePNGColorMode* color = &state->info_png.color;\r\n    predict = 0;\r\n    predict += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, color) + ((*h + 7) >> 3);\r\n    if(*w > 4) predict += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, color) + ((*h + 7) >> 3);\r\n    predict += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, color) + ((*h + 3) >> 3);\r\n    if(*w > 2) predict += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, color) + ((*h + 3) >> 2);\r\n    predict += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, color) + ((*h + 1) >> 2);\r\n    if(*w > 1) predict += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, color) + ((*h + 1) >> 1);\r\n    predict += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, color) + ((*h + 0) >> 1);\r\n  }\r\n  if(!state->error && !ucvector_reserve(&scanlines, predict)) state->error = 83; /*alloc fail*/\r\n  if(!state->error)\r\n  {\r\n    state->error = zlib_decompress(&scanlines.data, &scanlines.size, idat.data,\r\n                                   idat.size, &state->decoder.zlibsettings);\r\n    if(!state->error && scanlines.size != predict) state->error = 91; /*decompressed size doesn't match prediction*/\r\n  }\r\n  ucvector_cleanup(&idat);\r\n\r\n  if(!state->error)\r\n  {\r\n    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);\r\n    *out = (unsigned char*)lodepng_malloc(outsize);\r\n    if(!*out) state->error = 83; /*alloc fail*/\r\n  }\r\n  if(!state->error)\r\n  {\r\n    for(i = 0; i < outsize; i++) (*out)[i] = 0;\r\n    state->error = postProcessScanlines(*out, scanlines.data, *w, *h, &state->info_png);\r\n  }\r\n  ucvector_cleanup(&scanlines);\r\n}\r\n\r\nunsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,\r\n                        LodePNGState* state,\r\n                        const unsigned char* in, size_t insize)\r\n{\r\n  *out = 0;\r\n  decodeGeneric(out, w, h, state, in, insize);\r\n  if(state->error) return state->error;\r\n  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color))\r\n  {\r\n    /*same color type, no copying or converting of data needed*/\r\n    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype\r\n    the raw image has to the end user*/\r\n    if(!state->decoder.color_convert)\r\n    {\r\n      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);\r\n      if(state->error) return state->error;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    /*color conversion needed; sort of copy of the data*/\r\n    unsigned char* data = *out;\r\n    size_t outsize;\r\n\r\n    /*TODO: check if this works according to the statement in the documentation: \"The converter can convert\r\n    from greyscale input color type, to 8-bit greyscale or greyscale with alpha\"*/\r\n    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)\r\n       && !(state->info_raw.bitdepth == 8))\r\n    {\r\n      return 56; /*unsupported color mode conversion*/\r\n    }\r\n\r\n    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);\r\n    *out = (unsigned char*)lodepng_malloc(outsize);\r\n    if(!(*out))\r\n    {\r\n      state->error = 83; /*alloc fail*/\r\n    }\r\n    else state->error = lodepng_convert(*out, data, &state->info_raw,\r\n                                        &state->info_png.color, *w, *h);\r\n    lodepng_free(data);\r\n  }\r\n  return state->error;\r\n}\r\n\r\nunsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,\r\n                               size_t insize, LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  unsigned error;\r\n  LodePNGState state;\r\n  lodepng_state_init(&state);\r\n  state.info_raw.colortype = colortype;\r\n  state.info_raw.bitdepth = bitdepth;\r\n  error = lodepng_decode(out, w, h, &state, in, insize);\r\n  lodepng_state_cleanup(&state);\r\n  return error;\r\n}\r\n\r\nunsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\r\n{\r\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);\r\n}\r\n\r\nunsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\r\n{\r\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_DISK\r\nunsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,\r\n                             LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  unsigned char* buffer = 0;\r\n  size_t buffersize;\r\n  unsigned error;\r\n  error = lodepng_load_file(&buffer, &buffersize, filename);\r\n  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);\r\n  lodepng_free(buffer);\r\n  return error;\r\n}\r\n\r\nunsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)\r\n{\r\n  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);\r\n}\r\n\r\nunsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)\r\n{\r\n  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);\r\n}\r\n#endif /*LODEPNG_COMPILE_DISK*/\r\n\r\nvoid lodepng_decoder_settings_init(LodePNGDecoderSettings* settings)\r\n{\r\n  settings->color_convert = 1;\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n  settings->read_text_chunks = 1;\r\n  settings->remember_unknown_chunks = 0;\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n  settings->ignore_crc = 0;\r\n  lodepng_decompress_settings_init(&settings->zlibsettings);\r\n}\r\n\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)\r\n\r\nvoid lodepng_state_init(LodePNGState* state)\r\n{\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n  lodepng_decoder_settings_init(&state->decoder);\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n  lodepng_encoder_settings_init(&state->encoder);\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n  lodepng_color_mode_init(&state->info_raw);\r\n  lodepng_info_init(&state->info_png);\r\n  state->error = 1;\r\n}\r\n\r\nvoid lodepng_state_cleanup(LodePNGState* state)\r\n{\r\n  lodepng_color_mode_cleanup(&state->info_raw);\r\n  lodepng_info_cleanup(&state->info_png);\r\n}\r\n\r\nvoid lodepng_state_copy(LodePNGState* dest, const LodePNGState* source)\r\n{\r\n  lodepng_state_cleanup(dest);\r\n  *dest = *source;\r\n  lodepng_color_mode_init(&dest->info_raw);\r\n  lodepng_info_init(&dest->info_png);\r\n  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;\r\n  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;\r\n}\r\n\r\n#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* / PNG Encoder                                                            / */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n/*chunkName must be string of 4 characters*/\r\nstatic unsigned addChunk(ucvector* out, const char* chunkName, const unsigned char* data, size_t length)\r\n{\r\n  CERROR_TRY_RETURN(lodepng_chunk_create(&out->data, &out->size, (unsigned)length, chunkName, data));\r\n  out->allocsize = out->size; /*fix the allocsize again*/\r\n  return 0;\r\n}\r\n\r\nstatic void writeSignature(ucvector* out)\r\n{\r\n  /*8 bytes PNG signature, aka the magic bytes*/\r\n  ucvector_push_back(out, 137);\r\n  ucvector_push_back(out, 80);\r\n  ucvector_push_back(out, 78);\r\n  ucvector_push_back(out, 71);\r\n  ucvector_push_back(out, 13);\r\n  ucvector_push_back(out, 10);\r\n  ucvector_push_back(out, 26);\r\n  ucvector_push_back(out, 10);\r\n}\r\n\r\nstatic unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,\r\n                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method)\r\n{\r\n  unsigned error = 0;\r\n  ucvector header;\r\n  ucvector_init(&header);\r\n\r\n  lodepng_add32bitInt(&header, w); /*width*/\r\n  lodepng_add32bitInt(&header, h); /*height*/\r\n  ucvector_push_back(&header, (unsigned char)bitdepth); /*bit depth*/\r\n  ucvector_push_back(&header, (unsigned char)colortype); /*color type*/\r\n  ucvector_push_back(&header, 0); /*compression method*/\r\n  ucvector_push_back(&header, 0); /*filter method*/\r\n  ucvector_push_back(&header, interlace_method); /*interlace method*/\r\n\r\n  error = addChunk(out, \"IHDR\", header.data, header.size);\r\n  ucvector_cleanup(&header);\r\n\r\n  return error;\r\n}\r\n\r\nstatic unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info)\r\n{\r\n  unsigned error = 0;\r\n  size_t i;\r\n  ucvector PLTE;\r\n  ucvector_init(&PLTE);\r\n  for(i = 0; i != info->palettesize * 4; ++i)\r\n  {\r\n    /*add all channels except alpha channel*/\r\n    if(i % 4 != 3) ucvector_push_back(&PLTE, info->palette[i]);\r\n  }\r\n  error = addChunk(out, \"PLTE\", PLTE.data, PLTE.size);\r\n  ucvector_cleanup(&PLTE);\r\n\r\n  return error;\r\n}\r\n\r\nstatic unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info)\r\n{\r\n  unsigned error = 0;\r\n  size_t i;\r\n  ucvector tRNS;\r\n  ucvector_init(&tRNS);\r\n  if(info->colortype == LCT_PALETTE)\r\n  {\r\n    size_t amount = info->palettesize;\r\n    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/\r\n    for(i = info->palettesize; i != 0; --i)\r\n    {\r\n      if(info->palette[4 * (i - 1) + 3] == 255) --amount;\r\n      else break;\r\n    }\r\n    /*add only alpha channel*/\r\n    for(i = 0; i != amount; ++i) ucvector_push_back(&tRNS, info->palette[4 * i + 3]);\r\n  }\r\n  else if(info->colortype == LCT_GREY)\r\n  {\r\n    if(info->key_defined)\r\n    {\r\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_r >> 8));\r\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_r & 255));\r\n    }\r\n  }\r\n  else if(info->colortype == LCT_RGB)\r\n  {\r\n    if(info->key_defined)\r\n    {\r\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_r >> 8));\r\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_r & 255));\r\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_g >> 8));\r\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_g & 255));\r\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_b >> 8));\r\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_b & 255));\r\n    }\r\n  }\r\n\r\n  error = addChunk(out, \"tRNS\", tRNS.data, tRNS.size);\r\n  ucvector_cleanup(&tRNS);\r\n\r\n  return error;\r\n}\r\n\r\nstatic unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,\r\n                              LodePNGCompressSettings* zlibsettings)\r\n{\r\n  ucvector zlibdata;\r\n  unsigned error = 0;\r\n\r\n  /*compress with the Zlib compressor*/\r\n  ucvector_init(&zlibdata);\r\n  error = zlib_compress(&zlibdata.data, &zlibdata.size, data, datasize, zlibsettings);\r\n  if(!error) error = addChunk(out, \"IDAT\", zlibdata.data, zlibdata.size);\r\n  ucvector_cleanup(&zlibdata);\r\n\r\n  return error;\r\n}\r\n\r\nstatic unsigned addChunk_IEND(ucvector* out)\r\n{\r\n  unsigned error = 0;\r\n  error = addChunk(out, \"IEND\", 0, 0);\r\n  return error;\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n\r\nstatic unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring)\r\n{\r\n  unsigned error = 0;\r\n  size_t i;\r\n  ucvector text;\r\n  ucvector_init(&text);\r\n  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&text, (unsigned char)keyword[i]);\r\n  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/\r\n  ucvector_push_back(&text, 0); /*0 termination char*/\r\n  for(i = 0; textstring[i] != 0; ++i) ucvector_push_back(&text, (unsigned char)textstring[i]);\r\n  error = addChunk(out, \"tEXt\", text.data, text.size);\r\n  ucvector_cleanup(&text);\r\n\r\n  return error;\r\n}\r\n\r\nstatic unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,\r\n                              LodePNGCompressSettings* zlibsettings)\r\n{\r\n  unsigned error = 0;\r\n  ucvector data, compressed;\r\n  size_t i, textsize = strlen(textstring);\r\n\r\n  ucvector_init(&data);\r\n  ucvector_init(&compressed);\r\n  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)keyword[i]);\r\n  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/\r\n  ucvector_push_back(&data, 0); /*0 termination char*/\r\n  ucvector_push_back(&data, 0); /*compression method: 0*/\r\n\r\n  error = zlib_compress(&compressed.data, &compressed.size,\r\n                        (unsigned char*)textstring, textsize, zlibsettings);\r\n  if(!error)\r\n  {\r\n    for(i = 0; i != compressed.size; ++i) ucvector_push_back(&data, compressed.data[i]);\r\n    error = addChunk(out, \"zTXt\", data.data, data.size);\r\n  }\r\n\r\n  ucvector_cleanup(&compressed);\r\n  ucvector_cleanup(&data);\r\n  return error;\r\n}\r\n\r\nstatic unsigned addChunk_iTXt(ucvector* out, unsigned compressed, const char* keyword, const char* langtag,\r\n                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings)\r\n{\r\n  unsigned error = 0;\r\n  ucvector data;\r\n  size_t i, textsize = strlen(textstring);\r\n\r\n  ucvector_init(&data);\r\n\r\n  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)keyword[i]);\r\n  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/\r\n  ucvector_push_back(&data, 0); /*null termination char*/\r\n  ucvector_push_back(&data, compressed ? 1 : 0); /*compression flag*/\r\n  ucvector_push_back(&data, 0); /*compression method*/\r\n  for(i = 0; langtag[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)langtag[i]);\r\n  ucvector_push_back(&data, 0); /*null termination char*/\r\n  for(i = 0; transkey[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)transkey[i]);\r\n  ucvector_push_back(&data, 0); /*null termination char*/\r\n\r\n  if(compressed)\r\n  {\r\n    ucvector compressed_data;\r\n    ucvector_init(&compressed_data);\r\n    error = zlib_compress(&compressed_data.data, &compressed_data.size,\r\n                          (unsigned char*)textstring, textsize, zlibsettings);\r\n    if(!error)\r\n    {\r\n      for(i = 0; i != compressed_data.size; ++i) ucvector_push_back(&data, compressed_data.data[i]);\r\n    }\r\n    ucvector_cleanup(&compressed_data);\r\n  }\r\n  else /*not compressed*/\r\n  {\r\n    for(i = 0; textstring[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)textstring[i]);\r\n  }\r\n\r\n  if(!error) error = addChunk(out, \"iTXt\", data.data, data.size);\r\n  ucvector_cleanup(&data);\r\n  return error;\r\n}\r\n\r\nstatic unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info)\r\n{\r\n  unsigned error = 0;\r\n  ucvector bKGD;\r\n  ucvector_init(&bKGD);\r\n  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)\r\n  {\r\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_r >> 8));\r\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_r & 255));\r\n  }\r\n  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)\r\n  {\r\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_r >> 8));\r\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_r & 255));\r\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_g >> 8));\r\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_g & 255));\r\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_b >> 8));\r\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_b & 255));\r\n  }\r\n  else if(info->color.colortype == LCT_PALETTE)\r\n  {\r\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_r & 255)); /*palette index*/\r\n  }\r\n\r\n  error = addChunk(out, \"bKGD\", bKGD.data, bKGD.size);\r\n  ucvector_cleanup(&bKGD);\r\n\r\n  return error;\r\n}\r\n\r\nstatic unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time)\r\n{\r\n  unsigned error = 0;\r\n  unsigned char* data = (unsigned char*)lodepng_malloc(7);\r\n  if(!data) return 83; /*alloc fail*/\r\n  data[0] = (unsigned char)(time->year >> 8);\r\n  data[1] = (unsigned char)(time->year & 255);\r\n  data[2] = (unsigned char)time->month;\r\n  data[3] = (unsigned char)time->day;\r\n  data[4] = (unsigned char)time->hour;\r\n  data[5] = (unsigned char)time->minute;\r\n  data[6] = (unsigned char)time->second;\r\n  error = addChunk(out, \"tIME\", data, 7);\r\n  lodepng_free(data);\r\n  return error;\r\n}\r\n\r\nstatic unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info)\r\n{\r\n  unsigned error = 0;\r\n  ucvector data;\r\n  ucvector_init(&data);\r\n\r\n  lodepng_add32bitInt(&data, info->phys_x);\r\n  lodepng_add32bitInt(&data, info->phys_y);\r\n  ucvector_push_back(&data, info->phys_unit);\r\n\r\n  error = addChunk(out, \"pHYs\", data.data, data.size);\r\n  ucvector_cleanup(&data);\r\n\r\n  return error;\r\n}\r\n\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n\r\nstatic void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,\r\n                           size_t length, size_t bytewidth, unsigned char filterType)\r\n{\r\n  size_t i;\r\n  switch(filterType)\r\n  {\r\n    case 0: /*None*/\r\n      for(i = 0; i != length; ++i) out[i] = scanline[i];\r\n      break;\r\n    case 1: /*Sub*/\r\n      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];\r\n      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];\r\n      break;\r\n    case 2: /*Up*/\r\n      if(prevline)\r\n      {\r\n        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];\r\n      }\r\n      else\r\n      {\r\n        for(i = 0; i != length; ++i) out[i] = scanline[i];\r\n      }\r\n      break;\r\n    case 3: /*Average*/\r\n      if(prevline)\r\n      {\r\n        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);\r\n        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);\r\n      }\r\n      else\r\n      {\r\n        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];\r\n        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);\r\n      }\r\n      break;\r\n    case 4: /*Paeth*/\r\n      if(prevline)\r\n      {\r\n        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/\r\n        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);\r\n        for(i = bytewidth; i < length; ++i)\r\n        {\r\n          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));\r\n        }\r\n      }\r\n      else\r\n      {\r\n        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];\r\n        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/\r\n        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);\r\n      }\r\n      break;\r\n    default: return; /*unexisting filter type given*/\r\n  }\r\n}\r\n\r\n/* log2 approximation. A slight bit faster than std::log. */\r\nstatic float flog2(float f)\r\n{\r\n  float result = 0;\r\n  while(f > 32) { result += 4; f /= 16; }\r\n  while(f > 2) { ++result; f /= 2; }\r\n  return result + 1.442695f * (f * f * f / 3 - 3 * f * f / 2 + 3 * f - 1.83333f);\r\n}\r\n\r\nstatic unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,\r\n                       const LodePNGColorMode* info, const LodePNGEncoderSettings* settings)\r\n{\r\n  /*\r\n  For PNG filter method 0\r\n  out must be a buffer with as size: h + (w * h * bpp + 7) / 8, because there are\r\n  the scanlines with 1 extra byte per scanline\r\n  */\r\n\r\n  unsigned bpp = lodepng_get_bpp(info);\r\n  /*the width of a scanline in bytes, not including the filter type*/\r\n  size_t linebytes = (w * bpp + 7) / 8;\r\n  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/\r\n  size_t bytewidth = (bpp + 7) / 8;\r\n  const unsigned char* prevline = 0;\r\n  unsigned x, y;\r\n  unsigned error = 0;\r\n  LodePNGFilterStrategy strategy = settings->filter_strategy;\r\n\r\n  /*\r\n  There is a heuristic called the minimum sum of absolute differences heuristic, suggested by the PNG standard:\r\n   *  If the image type is Palette, or the bit depth is smaller than 8, then do not filter the image (i.e.\r\n      use fixed filtering, with the filter None).\r\n   * (The other case) If the image type is Grayscale or RGB (with or without Alpha), and the bit depth is\r\n     not smaller than 8, then use adaptive filtering heuristic as follows: independently for each row, apply\r\n     all five filters and select the filter that produces the smallest sum of absolute values per row.\r\n  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.\r\n\r\n  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,\r\n  but for \"the other case\", whatever strategy filter_strategy is set to instead of the minimum sum\r\n  heuristic is used.\r\n  */\r\n  if(settings->filter_palette_zero &&\r\n     (info->colortype == LCT_PALETTE || info->bitdepth < 8)) strategy = LFS_ZERO;\r\n\r\n  if(bpp == 0) return 31; /*error: invalid color type*/\r\n\r\n  if(strategy == LFS_ZERO)\r\n  {\r\n    for(y = 0; y != h; ++y)\r\n    {\r\n      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\r\n      size_t inindex = linebytes * y;\r\n      out[outindex] = 0; /*filter type byte*/\r\n      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, 0);\r\n      prevline = &in[inindex];\r\n    }\r\n  }\r\n  else if(strategy == LFS_MINSUM)\r\n  {\r\n    /*adaptive filtering*/\r\n    size_t sum[5];\r\n    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/\r\n    size_t smallest = 0;\r\n    unsigned char type, bestType = 0;\r\n\r\n    for(type = 0; type != 5; ++type)\r\n    {\r\n      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);\r\n      if(!attempt[type]) return 83; /*alloc fail*/\r\n    }\r\n\r\n    if(!error)\r\n    {\r\n      for(y = 0; y != h; ++y)\r\n      {\r\n        /*try the 5 filter types*/\r\n        for(type = 0; type != 5; ++type)\r\n        {\r\n          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);\r\n\r\n          /*calculate the sum of the result*/\r\n          sum[type] = 0;\r\n          if(type == 0)\r\n          {\r\n            for(x = 0; x != linebytes; ++x) sum[type] += (unsigned char)(attempt[type][x]);\r\n          }\r\n          else\r\n          {\r\n            for(x = 0; x != linebytes; ++x)\r\n            {\r\n              /*For differences, each byte should be treated as signed, values above 127 are negative\r\n              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.\r\n              This means filtertype 0 is almost never chosen, but that is justified.*/\r\n              unsigned char s = attempt[type][x];\r\n              sum[type] += s < 128 ? s : (255U - s);\r\n            }\r\n          }\r\n\r\n          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/\r\n          if(type == 0 || sum[type] < smallest)\r\n          {\r\n            bestType = type;\r\n            smallest = sum[type];\r\n          }\r\n        }\r\n\r\n        prevline = &in[y * linebytes];\r\n\r\n        /*now fill the out values*/\r\n        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\r\n        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];\r\n      }\r\n    }\r\n\r\n    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);\r\n  }\r\n  else if(strategy == LFS_ENTROPY)\r\n  {\r\n    float sum[5];\r\n    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/\r\n    float smallest = 0;\r\n    unsigned type, bestType = 0;\r\n    unsigned count[256];\r\n\r\n    for(type = 0; type != 5; ++type)\r\n    {\r\n      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);\r\n      if(!attempt[type]) return 83; /*alloc fail*/\r\n    }\r\n\r\n    for(y = 0; y != h; ++y)\r\n    {\r\n      /*try the 5 filter types*/\r\n      for(type = 0; type != 5; ++type)\r\n      {\r\n        filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);\r\n        for(x = 0; x != 256; ++x) count[x] = 0;\r\n        for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];\r\n        ++count[type]; /*the filter type itself is part of the scanline*/\r\n        sum[type] = 0;\r\n        for(x = 0; x != 256; ++x)\r\n        {\r\n          float p = count[x] / (float)(linebytes + 1);\r\n          sum[type] += count[x] == 0 ? 0 : flog2(1 / p) * p;\r\n        }\r\n        /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/\r\n        if(type == 0 || sum[type] < smallest)\r\n        {\r\n          bestType = type;\r\n          smallest = sum[type];\r\n        }\r\n      }\r\n\r\n      prevline = &in[y * linebytes];\r\n\r\n      /*now fill the out values*/\r\n      out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\r\n      for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];\r\n    }\r\n\r\n    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);\r\n  }\r\n  else if(strategy == LFS_PREDEFINED)\r\n  {\r\n    for(y = 0; y != h; ++y)\r\n    {\r\n      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\r\n      size_t inindex = linebytes * y;\r\n      unsigned char type = settings->predefined_filters[y];\r\n      out[outindex] = type; /*filter type byte*/\r\n      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);\r\n      prevline = &in[inindex];\r\n    }\r\n  }\r\n  else if(strategy == LFS_BRUTE_FORCE)\r\n  {\r\n    /*brute force filter chooser.\r\n    deflate the scanline after every filter attempt to see which one deflates best.\r\n    This is very slow and gives only slightly smaller, sometimes even larger, result*/\r\n    size_t size[5];\r\n    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/\r\n    size_t smallest = 0;\r\n    unsigned type = 0, bestType = 0;\r\n    unsigned char* dummy;\r\n    LodePNGCompressSettings zlibsettings = settings->zlibsettings;\r\n    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,\r\n    to simulate the true case where the tree is the same for the whole image. Sometimes it gives\r\n    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare\r\n    cases better compression. It does make this a bit less slow, so it's worth doing this.*/\r\n    zlibsettings.btype = 1;\r\n    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG\r\n    images only, so disable it*/\r\n    zlibsettings.custom_zlib = 0;\r\n    zlibsettings.custom_deflate = 0;\r\n    for(type = 0; type != 5; ++type)\r\n    {\r\n      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);\r\n      if(!attempt[type]) return 83; /*alloc fail*/\r\n    }\r\n    for(y = 0; y != h; ++y) /*try the 5 filter types*/\r\n    {\r\n      for(type = 0; type != 5; ++type)\r\n      {\r\n        unsigned testsize = linebytes;\r\n        /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/\r\n\r\n        filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);\r\n        size[type] = 0;\r\n        dummy = 0;\r\n        zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);\r\n        lodepng_free(dummy);\r\n        /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/\r\n        if(type == 0 || size[type] < smallest)\r\n        {\r\n          bestType = type;\r\n          smallest = size[type];\r\n        }\r\n      }\r\n      prevline = &in[y * linebytes];\r\n      out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\r\n      for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];\r\n    }\r\n    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);\r\n  }\r\n  else return 88; /* unknown filter strategy */\r\n\r\n  return error;\r\n}\r\n\r\nstatic void addPaddingBits(unsigned char* out, const unsigned char* in,\r\n                           size_t olinebits, size_t ilinebits, unsigned h)\r\n{\r\n  /*The opposite of the removePaddingBits function\r\n  olinebits must be >= ilinebits*/\r\n  unsigned y;\r\n  size_t diff = olinebits - ilinebits;\r\n  size_t obp = 0, ibp = 0; /*bit pointers*/\r\n  for(y = 0; y != h; ++y)\r\n  {\r\n    size_t x;\r\n    for(x = 0; x < ilinebits; ++x)\r\n    {\r\n      unsigned char bit = readBitFromReversedStream(&ibp, in);\r\n      setBitOfReversedStream(&obp, out, bit);\r\n    }\r\n    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid\r\n    \"Use of uninitialised value of size ###\" warning from valgrind*/\r\n    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);\r\n  }\r\n}\r\n\r\n/*\r\nin: non-interlaced image with size w*h\r\nout: the same pixels, but re-ordered according to PNG's Adam7 interlacing, with\r\n no padding bits between scanlines, but between reduced images so that each\r\n reduced image starts at a byte.\r\nbpp: bits per pixel\r\nthere are no padding bits, not between scanlines, not between reduced images\r\nin has the following size in bits: w * h * bpp.\r\nout is possibly bigger due to padding bits between reduced images\r\nNOTE: comments about padding bits are only relevant if bpp < 8\r\n*/\r\nstatic void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)\r\n{\r\n  unsigned passw[7], passh[7];\r\n  size_t filter_passstart[8], padded_passstart[8], passstart[8];\r\n  unsigned i;\r\n\r\n  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\r\n\r\n  if(bpp >= 8)\r\n  {\r\n    for(i = 0; i != 7; ++i)\r\n    {\r\n      unsigned x, y, b;\r\n      size_t bytewidth = bpp / 8;\r\n      for(y = 0; y < passh[i]; ++y)\r\n      for(x = 0; x < passw[i]; ++x)\r\n      {\r\n        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;\r\n        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;\r\n        for(b = 0; b < bytewidth; ++b)\r\n        {\r\n          out[pixeloutstart + b] = in[pixelinstart + b];\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/\r\n  {\r\n    for(i = 0; i != 7; ++i)\r\n    {\r\n      unsigned x, y, b;\r\n      unsigned ilinebits = bpp * passw[i];\r\n      unsigned olinebits = bpp * w;\r\n      size_t obp, ibp; /*bit pointers (for out and in buffer)*/\r\n      for(y = 0; y < passh[i]; ++y)\r\n      for(x = 0; x < passw[i]; ++x)\r\n      {\r\n        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;\r\n        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);\r\n        for(b = 0; b < bpp; ++b)\r\n        {\r\n          unsigned char bit = readBitFromReversedStream(&ibp, in);\r\n          setBitOfReversedStream(&obp, out, bit);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.\r\nreturn value is error**/\r\nstatic unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,\r\n                                    unsigned w, unsigned h,\r\n                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings)\r\n{\r\n  /*\r\n  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:\r\n  *) if no Adam7: 1) add padding bits (= posible extra bits per scanline if bpp < 8) 2) filter\r\n  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter\r\n  */\r\n  unsigned bpp = lodepng_get_bpp(&info_png->color);\r\n  unsigned error = 0;\r\n\r\n  if(info_png->interlace_method == 0)\r\n  {\r\n    *outsize = h + (h * ((w * bpp + 7) / 8)); /*image size plus an extra byte per scanline + possible padding bits*/\r\n    *out = (unsigned char*)lodepng_malloc(*outsize);\r\n    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/\r\n\r\n    if(!error)\r\n    {\r\n      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/\r\n      if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)\r\n      {\r\n        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7) / 8));\r\n        if(!padded) error = 83; /*alloc fail*/\r\n        if(!error)\r\n        {\r\n          addPaddingBits(padded, in, ((w * bpp + 7) / 8) * 8, w * bpp, h);\r\n          error = filter(*out, padded, w, h, &info_png->color, settings);\r\n        }\r\n        lodepng_free(padded);\r\n      }\r\n      else\r\n      {\r\n        /*we can immediately filter into the out buffer, no other steps needed*/\r\n        error = filter(*out, in, w, h, &info_png->color, settings);\r\n      }\r\n    }\r\n  }\r\n  else /*interlace_method is 1 (Adam7)*/\r\n  {\r\n    unsigned passw[7], passh[7];\r\n    size_t filter_passstart[8], padded_passstart[8], passstart[8];\r\n    unsigned char* adam7;\r\n\r\n    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\r\n\r\n    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/\r\n    *out = (unsigned char*)lodepng_malloc(*outsize);\r\n    if(!(*out)) error = 83; /*alloc fail*/\r\n\r\n    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);\r\n    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/\r\n\r\n    if(!error)\r\n    {\r\n      unsigned i;\r\n\r\n      Adam7_interlace(adam7, in, w, h, bpp);\r\n      for(i = 0; i != 7; ++i)\r\n      {\r\n        if(bpp < 8)\r\n        {\r\n          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);\r\n          if(!padded) ERROR_BREAK(83); /*alloc fail*/\r\n          addPaddingBits(padded, &adam7[passstart[i]],\r\n                         ((passw[i] * bpp + 7) / 8) * 8, passw[i] * bpp, passh[i]);\r\n          error = filter(&(*out)[filter_passstart[i]], padded,\r\n                         passw[i], passh[i], &info_png->color, settings);\r\n          lodepng_free(padded);\r\n        }\r\n        else\r\n        {\r\n          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],\r\n                         passw[i], passh[i], &info_png->color, settings);\r\n        }\r\n\r\n        if(error) break;\r\n      }\r\n    }\r\n\r\n    lodepng_free(adam7);\r\n  }\r\n\r\n  return error;\r\n}\r\n\r\n/*\r\npalette must have 4 * palettesize bytes allocated, and given in format RGBARGBARGBARGBA...\r\nreturns 0 if the palette is opaque,\r\nreturns 1 if the palette has a single color with alpha 0 ==> color key\r\nreturns 2 if the palette is semi-translucent.\r\n*/\r\nstatic unsigned getPaletteTranslucency(const unsigned char* palette, size_t palettesize)\r\n{\r\n  size_t i;\r\n  unsigned key = 0;\r\n  unsigned r = 0, g = 0, b = 0; /*the value of the color with alpha 0, so long as color keying is possible*/\r\n  for(i = 0; i != palettesize; ++i)\r\n  {\r\n    if(!key && palette[4 * i + 3] == 0)\r\n    {\r\n      r = palette[4 * i + 0]; g = palette[4 * i + 1]; b = palette[4 * i + 2];\r\n      key = 1;\r\n      i = (size_t)(-1); /*restart from beginning, to detect earlier opaque colors with key's value*/\r\n    }\r\n    else if(palette[4 * i + 3] != 255) return 2;\r\n    /*when key, no opaque RGB may have key's RGB*/\r\n    else if(key && r == palette[i * 4 + 0] && g == palette[i * 4 + 1] && b == palette[i * 4 + 2]) return 2;\r\n  }\r\n  return key;\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\nstatic unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize)\r\n{\r\n  unsigned char* inchunk = data;\r\n  while((size_t)(inchunk - data) < datasize)\r\n  {\r\n    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));\r\n    out->allocsize = out->size; /*fix the allocsize again*/\r\n    inchunk = lodepng_chunk_next(inchunk);\r\n  }\r\n  return 0;\r\n}\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n\r\nunsigned lodepng_encode(unsigned char** out, size_t* outsize,\r\n                        const unsigned char* image, unsigned w, unsigned h,\r\n                        LodePNGState* state)\r\n{\r\n  LodePNGInfo info;\r\n  ucvector outv;\r\n  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/\r\n  size_t datasize = 0;\r\n\r\n  /*provide some proper output values if error will happen*/\r\n  *out = 0;\r\n  *outsize = 0;\r\n  state->error = 0;\r\n\r\n  lodepng_info_init(&info);\r\n  lodepng_info_copy(&info, &state->info_png);\r\n\r\n  if((info.color.colortype == LCT_PALETTE || state->encoder.force_palette)\r\n      && (info.color.palettesize == 0 || info.color.palettesize > 256))\r\n  {\r\n    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/\r\n    return state->error;\r\n  }\r\n\r\n  if(state->encoder.auto_convert)\r\n  {\r\n    state->error = lodepng_auto_choose_color(&info.color, image, w, h, &state->info_raw);\r\n  }\r\n  if(state->error) return state->error;\r\n\r\n  if(state->encoder.zlibsettings.btype > 2)\r\n  {\r\n    CERROR_RETURN_ERROR(state->error, 61); /*error: unexisting btype*/\r\n  }\r\n  if(state->info_png.interlace_method > 1)\r\n  {\r\n    CERROR_RETURN_ERROR(state->error, 71); /*error: unexisting interlace mode*/\r\n  }\r\n\r\n  state->error = checkColorValidity(info.color.colortype, info.color.bitdepth);\r\n  if(state->error) return state->error; /*error: unexisting color type given*/\r\n  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);\r\n  if(state->error) return state->error; /*error: unexisting color type given*/\r\n\r\n  if(!lodepng_color_mode_equal(&state->info_raw, &info.color))\r\n  {\r\n    unsigned char* converted;\r\n    size_t size = (w * h * (size_t)lodepng_get_bpp(&info.color) + 7) / 8;\r\n\r\n    converted = (unsigned char*)lodepng_malloc(size);\r\n    if(!converted && size) state->error = 83; /*alloc fail*/\r\n    if(!state->error)\r\n    {\r\n      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);\r\n    }\r\n    if(!state->error) preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);\r\n    lodepng_free(converted);\r\n  }\r\n  else preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);\r\n\r\n  ucvector_init(&outv);\r\n  while(!state->error) /*while only executed once, to break on error*/\r\n  {\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n    size_t i;\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n    /*write signature and chunks*/\r\n    writeSignature(&outv);\r\n    /*IHDR*/\r\n    addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n    /*unknown chunks between IHDR and PLTE*/\r\n    if(info.unknown_chunks_data[0])\r\n    {\r\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);\r\n      if(state->error) break;\r\n    }\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n    /*PLTE*/\r\n    if(info.color.colortype == LCT_PALETTE)\r\n    {\r\n      addChunk_PLTE(&outv, &info.color);\r\n    }\r\n    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA))\r\n    {\r\n      addChunk_PLTE(&outv, &info.color);\r\n    }\r\n    /*tRNS*/\r\n    if(info.color.colortype == LCT_PALETTE && getPaletteTranslucency(info.color.palette, info.color.palettesize) != 0)\r\n    {\r\n      addChunk_tRNS(&outv, &info.color);\r\n    }\r\n    if((info.color.colortype == LCT_GREY || info.color.colortype == LCT_RGB) && info.color.key_defined)\r\n    {\r\n      addChunk_tRNS(&outv, &info.color);\r\n    }\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n    /*bKGD (must come between PLTE and the IDAt chunks*/\r\n    if(info.background_defined) addChunk_bKGD(&outv, &info);\r\n    /*pHYs (must come before the IDAT chunks)*/\r\n    if(info.phys_defined) addChunk_pHYs(&outv, &info);\r\n\r\n    /*unknown chunks between PLTE and IDAT*/\r\n    if(info.unknown_chunks_data[1])\r\n    {\r\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);\r\n      if(state->error) break;\r\n    }\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n    /*IDAT (multiple IDAT chunks must be consecutive)*/\r\n    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);\r\n    if(state->error) break;\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n    /*tIME*/\r\n    if(info.time_defined) addChunk_tIME(&outv, &info.time);\r\n    /*tEXt and/or zTXt*/\r\n    for(i = 0; i != info.text_num; ++i)\r\n    {\r\n      if(strlen(info.text_keys[i]) > 79)\r\n      {\r\n        state->error = 66; /*text chunk too large*/\r\n        break;\r\n      }\r\n      if(strlen(info.text_keys[i]) < 1)\r\n      {\r\n        state->error = 67; /*text chunk too small*/\r\n        break;\r\n      }\r\n      if(state->encoder.text_compression)\r\n      {\r\n        addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);\r\n      }\r\n      else\r\n      {\r\n        addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);\r\n      }\r\n    }\r\n    /*LodePNG version id in text chunk*/\r\n    if(state->encoder.add_id)\r\n    {\r\n      unsigned alread_added_id_text = 0;\r\n      for(i = 0; i != info.text_num; ++i)\r\n      {\r\n        if(!strcmp(info.text_keys[i], \"LodePNG\"))\r\n        {\r\n          alread_added_id_text = 1;\r\n          break;\r\n        }\r\n      }\r\n      if(alread_added_id_text == 0)\r\n      {\r\n        addChunk_tEXt(&outv, \"LodePNG\", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/\r\n      }\r\n    }\r\n    /*iTXt*/\r\n    for(i = 0; i != info.itext_num; ++i)\r\n    {\r\n      if(strlen(info.itext_keys[i]) > 79)\r\n      {\r\n        state->error = 66; /*text chunk too large*/\r\n        break;\r\n      }\r\n      if(strlen(info.itext_keys[i]) < 1)\r\n      {\r\n        state->error = 67; /*text chunk too small*/\r\n        break;\r\n      }\r\n      addChunk_iTXt(&outv, state->encoder.text_compression,\r\n                    info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],\r\n                    &state->encoder.zlibsettings);\r\n    }\r\n\r\n    /*unknown chunks between IDAT and IEND*/\r\n    if(info.unknown_chunks_data[2])\r\n    {\r\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);\r\n      if(state->error) break;\r\n    }\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n    addChunk_IEND(&outv);\r\n\r\n    break; /*this isn't really a while loop; no error happened so break out now!*/\r\n  }\r\n\r\n  lodepng_info_cleanup(&info);\r\n  lodepng_free(data);\r\n  /*instead of cleaning the vector up, give it to the output*/\r\n  *out = outv.data;\r\n  *outsize = outv.size;\r\n\r\n  return state->error;\r\n}\r\n\r\nunsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,\r\n                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  unsigned error;\r\n  LodePNGState state;\r\n  lodepng_state_init(&state);\r\n  state.info_raw.colortype = colortype;\r\n  state.info_raw.bitdepth = bitdepth;\r\n  state.info_png.color.colortype = colortype;\r\n  state.info_png.color.bitdepth = bitdepth;\r\n  lodepng_encode(out, outsize, image, w, h, &state);\r\n  error = state.error;\r\n  lodepng_state_cleanup(&state);\r\n  return error;\r\n}\r\n\r\nunsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)\r\n{\r\n  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);\r\n}\r\n\r\nunsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)\r\n{\r\n  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_DISK\r\nunsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,\r\n                             LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  unsigned char* buffer;\r\n  size_t buffersize;\r\n  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);\r\n  if(!error) error = lodepng_save_file(buffer, buffersize, filename);\r\n  lodepng_free(buffer);\r\n  return error;\r\n}\r\n\r\nunsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)\r\n{\r\n  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);\r\n}\r\n\r\nunsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)\r\n{\r\n  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);\r\n}\r\n#endif /*LODEPNG_COMPILE_DISK*/\r\n\r\nvoid lodepng_encoder_settings_init(LodePNGEncoderSettings* settings)\r\n{\r\n  lodepng_compress_settings_init(&settings->zlibsettings);\r\n  settings->filter_palette_zero = 1;\r\n  settings->filter_strategy = LFS_MINSUM;\r\n  settings->auto_convert = 1;\r\n  settings->force_palette = 0;\r\n  settings->predefined_filters = 0;\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n  settings->add_id = 0;\r\n  settings->text_compression = 1;\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n}\r\n\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n#endif /*LODEPNG_COMPILE_PNG*/\r\n\r\n#ifdef LODEPNG_COMPILE_ERROR_TEXT\r\n/*\r\nThis returns the description of a numerical error code in English. This is also\r\nthe documentation of all the error codes.\r\n*/\r\nconst char* lodepng_error_text(unsigned code)\r\n{\r\n  switch(code)\r\n  {\r\n    case 0: return \"no error, everything went ok\";\r\n    case 1: return \"nothing done yet\"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/\r\n    case 10: return \"end of input memory reached without huffman end code\"; /*while huffman decoding*/\r\n    case 11: return \"error in code tree made it jump outside of huffman tree\"; /*while huffman decoding*/\r\n    case 13: return \"problem while processing dynamic deflate block\";\r\n    case 14: return \"problem while processing dynamic deflate block\";\r\n    case 15: return \"problem while processing dynamic deflate block\";\r\n    case 16: return \"unexisting code while processing dynamic deflate block\";\r\n    case 17: return \"end of out buffer memory reached while inflating\";\r\n    case 18: return \"invalid distance code while inflating\";\r\n    case 19: return \"end of out buffer memory reached while inflating\";\r\n    case 20: return \"invalid deflate block BTYPE encountered while decoding\";\r\n    case 21: return \"NLEN is not ones complement of LEN in a deflate block\";\r\n     /*end of out buffer memory reached while inflating:\r\n     This can happen if the inflated deflate data is longer than the amount of bytes required to fill up\r\n     all the pixels of the image, given the color depth and image dimensions. Something that doesn't\r\n     happen in a normal, well encoded, PNG image.*/\r\n    case 22: return \"end of out buffer memory reached while inflating\";\r\n    case 23: return \"end of in buffer memory reached while inflating\";\r\n    case 24: return \"invalid FCHECK in zlib header\";\r\n    case 25: return \"invalid compression method in zlib header\";\r\n    case 26: return \"FDICT encountered in zlib header while it's not used for PNG\";\r\n    case 27: return \"PNG file is smaller than a PNG header\";\r\n    /*Checks the magic file header, the first 8 bytes of the PNG file*/\r\n    case 28: return \"incorrect PNG signature, it's no PNG or corrupted\";\r\n    case 29: return \"first chunk is not the header chunk\";\r\n    case 30: return \"chunk length too large, chunk broken off at end of file\";\r\n    case 31: return \"illegal PNG color type or bpp\";\r\n    case 32: return \"illegal PNG compression method\";\r\n    case 33: return \"illegal PNG filter method\";\r\n    case 34: return \"illegal PNG interlace method\";\r\n    case 35: return \"chunk length of a chunk is too large or the chunk too small\";\r\n    case 36: return \"illegal PNG filter type encountered\";\r\n    case 37: return \"illegal bit depth for this color type given\";\r\n    case 38: return \"the palette is too big\"; /*more than 256 colors*/\r\n    case 39: return \"more palette alpha values given in tRNS chunk than there are colors in the palette\";\r\n    case 40: return \"tRNS chunk has wrong size for greyscale image\";\r\n    case 41: return \"tRNS chunk has wrong size for RGB image\";\r\n    case 42: return \"tRNS chunk appeared while it was not allowed for this color type\";\r\n    case 43: return \"bKGD chunk has wrong size for palette image\";\r\n    case 44: return \"bKGD chunk has wrong size for greyscale image\";\r\n    case 45: return \"bKGD chunk has wrong size for RGB image\";\r\n    case 48: return \"empty input buffer given to decoder. Maybe caused by non-existing file?\";\r\n    case 49: return \"jumped past memory while generating dynamic huffman tree\";\r\n    case 50: return \"jumped past memory while generating dynamic huffman tree\";\r\n    case 51: return \"jumped past memory while inflating huffman block\";\r\n    case 52: return \"jumped past memory while inflating\";\r\n    case 53: return \"size of zlib data too small\";\r\n    case 54: return \"repeat symbol in tree while there was no value symbol yet\";\r\n    /*jumped past tree while generating huffman tree, this could be when the\r\n    tree will have more leaves than symbols after generating it out of the\r\n    given lenghts. They call this an oversubscribed dynamic bit lengths tree in zlib.*/\r\n    case 55: return \"jumped past tree while generating huffman tree\";\r\n    case 56: return \"given output image colortype or bitdepth not supported for color conversion\";\r\n    case 57: return \"invalid CRC encountered (checking CRC can be disabled)\";\r\n    case 58: return \"invalid ADLER32 encountered (checking ADLER32 can be disabled)\";\r\n    case 59: return \"requested color conversion not supported\";\r\n    case 60: return \"invalid window size given in the settings of the encoder (must be 0-32768)\";\r\n    case 61: return \"invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)\";\r\n    /*LodePNG leaves the choice of RGB to greyscale conversion formula to the user.*/\r\n    case 62: return \"conversion from color to greyscale not supported\";\r\n    case 63: return \"length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk\"; /*(2^31-1)*/\r\n    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/\r\n    case 64: return \"the length of the END symbol 256 in the Huffman tree is 0\";\r\n    case 66: return \"the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes\";\r\n    case 67: return \"the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte\";\r\n    case 68: return \"tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors\";\r\n    case 69: return \"unknown chunk type with 'critical' flag encountered by the decoder\";\r\n    case 71: return \"unexisting interlace mode given to encoder (must be 0 or 1)\";\r\n    case 72: return \"while decoding, unexisting compression method encountering in zTXt or iTXt chunk (it must be 0)\";\r\n    case 73: return \"invalid tIME chunk size\";\r\n    case 74: return \"invalid pHYs chunk size\";\r\n    /*length could be wrong, or data chopped off*/\r\n    case 75: return \"no null termination char found while decoding text chunk\";\r\n    case 76: return \"iTXt chunk too short to contain required bytes\";\r\n    case 77: return \"integer overflow in buffer size\";\r\n    case 78: return \"failed to open file for reading\"; /*file doesn't exist or couldn't be opened for reading*/\r\n    case 79: return \"failed to open file for writing\";\r\n    case 80: return \"tried creating a tree of 0 symbols\";\r\n    case 81: return \"lazy matching at pos 0 is impossible\";\r\n    case 82: return \"color conversion to palette requested while a color isn't in palette\";\r\n    case 83: return \"memory allocation failed\";\r\n    case 84: return \"given image too small to contain all pixels to be encoded\";\r\n    case 86: return \"impossible offset in lz77 encoding (internal bug)\";\r\n    case 87: return \"must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined\";\r\n    case 88: return \"invalid filter strategy given for LodePNGEncoderSettings.filter_strategy\";\r\n    case 89: return \"text chunk keyword too short or long: must have size 1-79\";\r\n    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/\r\n    case 90: return \"windowsize must be a power of two\";\r\n    case 91: return \"invalid decompressed idat size\";\r\n    case 92: return \"too many pixels, not supported\";\r\n    case 93: return \"zero width or height is invalid\";\r\n    case 94: return \"header chunk must have a size of 13 bytes\";\r\n  }\r\n  return \"unknown error code\";\r\n}\r\n#endif /*LODEPNG_COMPILE_ERROR_TEXT*/\r\n\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* // C++ Wrapper                                                          // */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n/* ////////////////////////////////////////////////////////////////////////// */\r\n\r\n#ifdef LODEPNG_COMPILE_CPP\r\nnamespace lodepng\r\n{\r\n\r\n#ifdef LODEPNG_COMPILE_DISK\r\nunsigned load_file(std::vector<unsigned char>& buffer, const std::string& filename)\r\n{\r\n  long size = lodepng_filesize(filename.c_str());\r\n  if(size < 0) return 78;\r\n  buffer.resize((size_t)size);\r\n  return size == 0 ? 0 : lodepng_buffer_file(&buffer[0], (size_t)size, filename.c_str());\r\n}\r\n\r\n/*write given buffer to the file, overwriting the file, it doesn't append to it.*/\r\nunsigned save_file(const std::vector<unsigned char>& buffer, const std::string& filename)\r\n{\r\n  return lodepng_save_file(buffer.empty() ? 0 : &buffer[0], buffer.size(), filename.c_str());\r\n}\r\n#endif /* LODEPNG_COMPILE_DISK */\r\n\r\n#ifdef LODEPNG_COMPILE_ZLIB\r\n#ifdef LODEPNG_COMPILE_DECODER\r\nunsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\r\n                    const LodePNGDecompressSettings& settings)\r\n{\r\n  unsigned char* buffer = 0;\r\n  size_t buffersize = 0;\r\n  unsigned error = zlib_decompress(&buffer, &buffersize, in, insize, &settings);\r\n  if(buffer)\r\n  {\r\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\r\n    lodepng_free(buffer);\r\n  }\r\n  return error;\r\n}\r\n\r\nunsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\r\n                    const LodePNGDecompressSettings& settings)\r\n{\r\n  return decompress(out, in.empty() ? 0 : &in[0], in.size(), settings);\r\n}\r\n#endif /* LODEPNG_COMPILE_DECODER */\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\nunsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\r\n                  const LodePNGCompressSettings& settings)\r\n{\r\n  unsigned char* buffer = 0;\r\n  size_t buffersize = 0;\r\n  unsigned error = zlib_compress(&buffer, &buffersize, in, insize, &settings);\r\n  if(buffer)\r\n  {\r\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\r\n    lodepng_free(buffer);\r\n  }\r\n  return error;\r\n}\r\n\r\nunsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\r\n                  const LodePNGCompressSettings& settings)\r\n{\r\n  return compress(out, in.empty() ? 0 : &in[0], in.size(), settings);\r\n}\r\n#endif /* LODEPNG_COMPILE_ENCODER */\r\n#endif /* LODEPNG_COMPILE_ZLIB */\r\n\r\n\r\n#ifdef LODEPNG_COMPILE_PNG\r\n\r\nState::State()\r\n{\r\n  lodepng_state_init(this);\r\n}\r\n\r\nState::State(const State& other)\r\n{\r\n  lodepng_state_init(this);\r\n  lodepng_state_copy(this, &other);\r\n}\r\n\r\nState::~State()\r\n{\r\n  lodepng_state_cleanup(this);\r\n}\r\n\r\nState& State::operator=(const State& other)\r\n{\r\n  lodepng_state_copy(this, &other);\r\n  return *this;\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n\r\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const unsigned char* in,\r\n                size_t insize, LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  unsigned char* buffer;\r\n  unsigned error = lodepng_decode_memory(&buffer, &w, &h, in, insize, colortype, bitdepth);\r\n  if(buffer && !error)\r\n  {\r\n    State state;\r\n    state.info_raw.colortype = colortype;\r\n    state.info_raw.bitdepth = bitdepth;\r\n    size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);\r\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\r\n    lodepng_free(buffer);\r\n  }\r\n  return error;\r\n}\r\n\r\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\r\n                const std::vector<unsigned char>& in, LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  return decode(out, w, h, in.empty() ? 0 : &in[0], (unsigned)in.size(), colortype, bitdepth);\r\n}\r\n\r\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\r\n                State& state,\r\n                const unsigned char* in, size_t insize)\r\n{\r\n  unsigned char* buffer = NULL;\r\n  unsigned error = lodepng_decode(&buffer, &w, &h, &state, in, insize);\r\n  if(buffer && !error)\r\n  {\r\n    size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);\r\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\r\n  }\r\n  lodepng_free(buffer);\r\n  return error;\r\n}\r\n\r\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\r\n                State& state,\r\n                const std::vector<unsigned char>& in)\r\n{\r\n  return decode(out, w, h, state, in.empty() ? 0 : &in[0], in.size());\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_DISK\r\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const std::string& filename,\r\n                LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  std::vector<unsigned char> buffer;\r\n  unsigned error = load_file(buffer, filename);\r\n  if(error) return error;\r\n  return decode(out, w, h, buffer, colortype, bitdepth);\r\n}\r\n#endif /* LODEPNG_COMPILE_DECODER */\r\n#endif /* LODEPNG_COMPILE_DISK */\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\nunsigned encode(std::vector<unsigned char>& out, const unsigned char* in, unsigned w, unsigned h,\r\n                LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  unsigned char* buffer;\r\n  size_t buffersize;\r\n  unsigned error = lodepng_encode_memory(&buffer, &buffersize, in, w, h, colortype, bitdepth);\r\n  if(buffer)\r\n  {\r\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\r\n    lodepng_free(buffer);\r\n  }\r\n  return error;\r\n}\r\n\r\nunsigned encode(std::vector<unsigned char>& out,\r\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\r\n                LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;\r\n  return encode(out, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);\r\n}\r\n\r\nunsigned encode(std::vector<unsigned char>& out,\r\n                const unsigned char* in, unsigned w, unsigned h,\r\n                State& state)\r\n{\r\n  unsigned char* buffer;\r\n  size_t buffersize;\r\n  unsigned error = lodepng_encode(&buffer, &buffersize, in, w, h, &state);\r\n  if(buffer)\r\n  {\r\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\r\n    lodepng_free(buffer);\r\n  }\r\n  return error;\r\n}\r\n\r\nunsigned encode(std::vector<unsigned char>& out,\r\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\r\n                State& state)\r\n{\r\n  if(lodepng_get_raw_size(w, h, &state.info_raw) > in.size()) return 84;\r\n  return encode(out, in.empty() ? 0 : &in[0], w, h, state);\r\n}\r\n\r\n#ifdef LODEPNG_COMPILE_DISK\r\nunsigned encode(const std::string& filename,\r\n                const unsigned char* in, unsigned w, unsigned h,\r\n                LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  std::vector<unsigned char> buffer;\r\n  unsigned error = encode(buffer, in, w, h, colortype, bitdepth);\r\n  if(!error) error = save_file(buffer, filename);\r\n  return error;\r\n}\r\n\r\nunsigned encode(const std::string& filename,\r\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\r\n                LodePNGColorType colortype, unsigned bitdepth)\r\n{\r\n  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;\r\n  return encode(filename, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);\r\n}\r\n#endif /* LODEPNG_COMPILE_DISK */\r\n#endif /* LODEPNG_COMPILE_ENCODER */\r\n#endif /* LODEPNG_COMPILE_PNG */\r\n} /* namespace lodepng */\r\n#endif /*LODEPNG_COMPILE_CPP*/\r\n","/*\r\nLodePNG version 20161127\r\n\r\nCopyright (c) 2005-2016 Lode Vandevenne\r\n\r\nThis software is provided 'as-is', without any express or implied\r\nwarranty. In no event will the authors be held liable for any damages\r\narising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any purpose,\r\nincluding commercial applications, and to alter it and redistribute it\r\nfreely, subject to the following restrictions:\r\n\r\n    1. The origin of this software must not be misrepresented; you must not\r\n    claim that you wrote the original software. If you use this software\r\n    in a product, an acknowledgment in the product documentation would be\r\n    appreciated but is not required.\r\n\r\n    2. Altered source versions must be plainly marked as such, and must not be\r\n    misrepresented as being the original software.\r\n\r\n    3. This notice may not be removed or altered from any source\r\n    distribution.\r\n*/\r\n\r\n#ifndef LODEPNG_H\r\n#define LODEPNG_H\r\n\r\n#include <string.h> /*for size_t*/\r\n\r\nextern const char* LODEPNG_VERSION_STRING;\r\n\r\n/*\r\nThe following #defines are used to create code sections. They can be disabled\r\nto disable code sections, which can give faster compile time and smaller binary.\r\nThe \"NO_COMPILE\" defines are designed to be used to pass as defines to the\r\ncompiler command to disable them without modifying this header, e.g.\r\n-DLODEPNG_NO_COMPILE_ZLIB for gcc.\r\nIn addition to those below, you can also define LODEPNG_NO_COMPILE_CRC to\r\nallow implementing a custom lodepng_crc32.\r\n*/\r\n/*deflate & zlib. If disabled, you must specify alternative zlib functions in\r\nthe custom_zlib field of the compress and decompress settings*/\r\n#ifndef LODEPNG_NO_COMPILE_ZLIB\r\n#define LODEPNG_COMPILE_ZLIB\r\n#endif\r\n/*png encoder and png decoder*/\r\n#ifndef LODEPNG_NO_COMPILE_PNG\r\n#define LODEPNG_COMPILE_PNG\r\n#endif\r\n/*deflate&zlib decoder and png decoder*/\r\n#ifndef LODEPNG_NO_COMPILE_DECODER\r\n#define LODEPNG_COMPILE_DECODER\r\n#endif\r\n/*deflate&zlib encoder and png encoder*/\r\n#ifndef LODEPNG_NO_COMPILE_ENCODER\r\n#define LODEPNG_COMPILE_ENCODER\r\n#endif\r\n/*the optional built in harddisk file loading and saving functions*/\r\n#ifndef LODEPNG_NO_COMPILE_DISK\r\n#define LODEPNG_COMPILE_DISK\r\n#endif\r\n/*support for chunks other than IHDR, IDAT, PLTE, tRNS, IEND: ancillary and unknown chunks*/\r\n#ifndef LODEPNG_NO_COMPILE_ANCILLARY_CHUNKS\r\n#define LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n#endif\r\n/*ability to convert error numerical codes to English text string*/\r\n#ifndef LODEPNG_NO_COMPILE_ERROR_TEXT\r\n#define LODEPNG_COMPILE_ERROR_TEXT\r\n#endif\r\n/*Compile the default allocators (C's free, malloc and realloc). If you disable this,\r\nyou can define the functions lodepng_free, lodepng_malloc and lodepng_realloc in your\r\nsource files with custom allocators.*/\r\n#ifndef LODEPNG_NO_COMPILE_ALLOCATORS\r\n#define LODEPNG_COMPILE_ALLOCATORS\r\n#endif\r\n/*compile the C++ version (you can disable the C++ wrapper here even when compiling for C++)*/\r\n#ifdef __cplusplus\r\n#ifndef LODEPNG_NO_COMPILE_CPP\r\n#define LODEPNG_COMPILE_CPP\r\n#endif\r\n#endif\r\n\r\n#ifdef LODEPNG_COMPILE_CPP\r\n#include <vector>\r\n#include <string>\r\n#endif /*LODEPNG_COMPILE_CPP*/\r\n\r\n#ifdef LODEPNG_COMPILE_PNG\r\n/*The PNG color types (also used for raw).*/\r\ntypedef enum LodePNGColorType\r\n{\r\n  LCT_GREY = 0, /*greyscale: 1,2,4,8,16 bit*/\r\n  LCT_RGB = 2, /*RGB: 8,16 bit*/\r\n  LCT_PALETTE = 3, /*palette: 1,2,4,8 bit*/\r\n  LCT_GREY_ALPHA = 4, /*greyscale with alpha: 8,16 bit*/\r\n  LCT_RGBA = 6 /*RGB with alpha: 8,16 bit*/\r\n} LodePNGColorType;\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n/*\r\nConverts PNG data in memory to raw pixel data.\r\nout: Output parameter. Pointer to buffer that will contain the raw pixel data.\r\n     After decoding, its size is w * h * (bytes per pixel) bytes larger than\r\n     initially. Bytes per pixel depends on colortype and bitdepth.\r\n     Must be freed after usage with free(*out).\r\n     Note: for 16-bit per channel colors, uses big endian format like PNG does.\r\nw: Output parameter. Pointer to width of pixel data.\r\nh: Output parameter. Pointer to height of pixel data.\r\nin: Memory buffer with the PNG file.\r\ninsize: size of the in buffer.\r\ncolortype: the desired color type for the raw output image. See explanation on PNG color types.\r\nbitdepth: the desired bit depth for the raw output image. See explanation on PNG color types.\r\nReturn value: LodePNG error code (0 means no error).\r\n*/\r\nunsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h,\r\n                               const unsigned char* in, size_t insize,\r\n                               LodePNGColorType colortype, unsigned bitdepth);\r\n\r\n/*Same as lodepng_decode_memory, but always decodes to 32-bit RGBA raw image*/\r\nunsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h,\r\n                          const unsigned char* in, size_t insize);\r\n\r\n/*Same as lodepng_decode_memory, but always decodes to 24-bit RGB raw image*/\r\nunsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h,\r\n                          const unsigned char* in, size_t insize);\r\n\r\n#ifdef LODEPNG_COMPILE_DISK\r\n/*\r\nLoad PNG from disk, from file with given name.\r\nSame as the other decode functions, but instead takes a filename as input.\r\n*/\r\nunsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h,\r\n                             const char* filename,\r\n                             LodePNGColorType colortype, unsigned bitdepth);\r\n\r\n/*Same as lodepng_decode_file, but always decodes to 32-bit RGBA raw image.*/\r\nunsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h,\r\n                               const char* filename);\r\n\r\n/*Same as lodepng_decode_file, but always decodes to 24-bit RGB raw image.*/\r\nunsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h,\r\n                               const char* filename);\r\n#endif /*LODEPNG_COMPILE_DISK*/\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n/*\r\nConverts raw pixel data into a PNG image in memory. The colortype and bitdepth\r\n  of the output PNG image cannot be chosen, they are automatically determined\r\n  by the colortype, bitdepth and content of the input pixel data.\r\n  Note: for 16-bit per channel colors, needs big endian format like PNG does.\r\nout: Output parameter. Pointer to buffer that will contain the PNG image data.\r\n     Must be freed after usage with free(*out).\r\noutsize: Output parameter. Pointer to the size in bytes of the out buffer.\r\nimage: The raw pixel data to encode. The size of this buffer should be\r\n       w * h * (bytes per pixel), bytes per pixel depends on colortype and bitdepth.\r\nw: width of the raw pixel data in pixels.\r\nh: height of the raw pixel data in pixels.\r\ncolortype: the color type of the raw input image. See explanation on PNG color types.\r\nbitdepth: the bit depth of the raw input image. See explanation on PNG color types.\r\nReturn value: LodePNG error code (0 means no error).\r\n*/\r\nunsigned lodepng_encode_memory(unsigned char** out, size_t* outsize,\r\n                               const unsigned char* image, unsigned w, unsigned h,\r\n                               LodePNGColorType colortype, unsigned bitdepth);\r\n\r\n/*Same as lodepng_encode_memory, but always encodes from 32-bit RGBA raw image.*/\r\nunsigned lodepng_encode32(unsigned char** out, size_t* outsize,\r\n                          const unsigned char* image, unsigned w, unsigned h);\r\n\r\n/*Same as lodepng_encode_memory, but always encodes from 24-bit RGB raw image.*/\r\nunsigned lodepng_encode24(unsigned char** out, size_t* outsize,\r\n                          const unsigned char* image, unsigned w, unsigned h);\r\n\r\n#ifdef LODEPNG_COMPILE_DISK\r\n/*\r\nConverts raw pixel data into a PNG file on disk.\r\nSame as the other encode functions, but instead takes a filename as output.\r\nNOTE: This overwrites existing files without warning!\r\n*/\r\nunsigned lodepng_encode_file(const char* filename,\r\n                             const unsigned char* image, unsigned w, unsigned h,\r\n                             LodePNGColorType colortype, unsigned bitdepth);\r\n\r\n/*Same as lodepng_encode_file, but always encodes from 32-bit RGBA raw image.*/\r\nunsigned lodepng_encode32_file(const char* filename,\r\n                               const unsigned char* image, unsigned w, unsigned h);\r\n\r\n/*Same as lodepng_encode_file, but always encodes from 24-bit RGB raw image.*/\r\nunsigned lodepng_encode24_file(const char* filename,\r\n                               const unsigned char* image, unsigned w, unsigned h);\r\n#endif /*LODEPNG_COMPILE_DISK*/\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n\r\n#ifdef LODEPNG_COMPILE_CPP\r\nnamespace lodepng\r\n{\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n/*Same as lodepng_decode_memory, but decodes to an std::vector. The colortype\r\nis the format to output the pixels to. Default is RGBA 8-bit per channel.*/\r\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\r\n                const unsigned char* in, size_t insize,\r\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\r\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\r\n                const std::vector<unsigned char>& in,\r\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\r\n#ifdef LODEPNG_COMPILE_DISK\r\n/*\r\nConverts PNG file from disk to raw pixel data in memory.\r\nSame as the other decode functions, but instead takes a filename as input.\r\n*/\r\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\r\n                const std::string& filename,\r\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\r\n#endif /* LODEPNG_COMPILE_DISK */\r\n#endif /* LODEPNG_COMPILE_DECODER */\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n/*Same as lodepng_encode_memory, but encodes to an std::vector. colortype\r\nis that of the raw input data. The output PNG color type will be auto chosen.*/\r\nunsigned encode(std::vector<unsigned char>& out,\r\n                const unsigned char* in, unsigned w, unsigned h,\r\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\r\nunsigned encode(std::vector<unsigned char>& out,\r\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\r\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\r\n#ifdef LODEPNG_COMPILE_DISK\r\n/*\r\nConverts 32-bit RGBA raw pixel data into a PNG file on disk.\r\nSame as the other encode functions, but instead takes a filename as output.\r\nNOTE: This overwrites existing files without warning!\r\n*/\r\nunsigned encode(const std::string& filename,\r\n                const unsigned char* in, unsigned w, unsigned h,\r\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\r\nunsigned encode(const std::string& filename,\r\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\r\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\r\n#endif /* LODEPNG_COMPILE_DISK */\r\n#endif /* LODEPNG_COMPILE_ENCODER */\r\n} /* namespace lodepng */\r\n#endif /*LODEPNG_COMPILE_CPP*/\r\n#endif /*LODEPNG_COMPILE_PNG*/\r\n\r\n#ifdef LODEPNG_COMPILE_ERROR_TEXT\r\n/*Returns an English description of the numerical error code.*/\r\nconst char* lodepng_error_text(unsigned code);\r\n#endif /*LODEPNG_COMPILE_ERROR_TEXT*/\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n/*Settings for zlib decompression*/\r\ntypedef struct LodePNGDecompressSettings LodePNGDecompressSettings;\r\nstruct LodePNGDecompressSettings\r\n{\r\n  unsigned ignore_adler32; /*if 1, continue and don't give an error message if the Adler32 checksum is corrupted*/\r\n\r\n  /*use custom zlib decoder instead of built in one (default: null)*/\r\n  unsigned (*custom_zlib)(unsigned char**, size_t*,\r\n                          const unsigned char*, size_t,\r\n                          const LodePNGDecompressSettings*);\r\n  /*use custom deflate decoder instead of built in one (default: null)\r\n  if custom_zlib is used, custom_deflate is ignored since only the built in\r\n  zlib function will call custom_deflate*/\r\n  unsigned (*custom_inflate)(unsigned char**, size_t*,\r\n                             const unsigned char*, size_t,\r\n                             const LodePNGDecompressSettings*);\r\n\r\n  const void* custom_context; /*optional custom settings for custom functions*/\r\n};\r\n\r\nextern const LodePNGDecompressSettings lodepng_default_decompress_settings;\r\nvoid lodepng_decompress_settings_init(LodePNGDecompressSettings* settings);\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n/*\r\nSettings for zlib compression. Tweaking these settings tweaks the balance\r\nbetween speed and compression ratio.\r\n*/\r\ntypedef struct LodePNGCompressSettings LodePNGCompressSettings;\r\nstruct LodePNGCompressSettings /*deflate = compress*/\r\n{\r\n  /*LZ77 related settings*/\r\n  unsigned btype; /*the block type for LZ (0, 1, 2 or 3, see zlib standard). Should be 2 for proper compression.*/\r\n  unsigned use_lz77; /*whether or not to use LZ77. Should be 1 for proper compression.*/\r\n  unsigned windowsize; /*must be a power of two <= 32768. higher compresses more but is slower. Default value: 2048.*/\r\n  unsigned minmatch; /*mininum lz77 length. 3 is normally best, 6 can be better for some PNGs. Default: 0*/\r\n  unsigned nicematch; /*stop searching if >= this length found. Set to 258 for best compression. Default: 128*/\r\n  unsigned lazymatching; /*use lazy matching: better compression but a bit slower. Default: true*/\r\n\r\n  /*use custom zlib encoder instead of built in one (default: null)*/\r\n  unsigned (*custom_zlib)(unsigned char**, size_t*,\r\n                          const unsigned char*, size_t,\r\n                          const LodePNGCompressSettings*);\r\n  /*use custom deflate encoder instead of built in one (default: null)\r\n  if custom_zlib is used, custom_deflate is ignored since only the built in\r\n  zlib function will call custom_deflate*/\r\n  unsigned (*custom_deflate)(unsigned char**, size_t*,\r\n                             const unsigned char*, size_t,\r\n                             const LodePNGCompressSettings*);\r\n\r\n  const void* custom_context; /*optional custom settings for custom functions*/\r\n};\r\n\r\nextern const LodePNGCompressSettings lodepng_default_compress_settings;\r\nvoid lodepng_compress_settings_init(LodePNGCompressSettings* settings);\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n#ifdef LODEPNG_COMPILE_PNG\r\n/*\r\nColor mode of an image. Contains all information required to decode the pixel\r\nbits to RGBA colors. This information is the same as used in the PNG file\r\nformat, and is used both for PNG and raw image data in LodePNG.\r\n*/\r\ntypedef struct LodePNGColorMode\r\n{\r\n  /*header (IHDR)*/\r\n  LodePNGColorType colortype; /*color type, see PNG standard or documentation further in this header file*/\r\n  unsigned bitdepth;  /*bits per sample, see PNG standard or documentation further in this header file*/\r\n\r\n  /*\r\n  palette (PLTE and tRNS)\r\n\r\n  Dynamically allocated with the colors of the palette, including alpha.\r\n  When encoding a PNG, to store your colors in the palette of the LodePNGColorMode, first use\r\n  lodepng_palette_clear, then for each color use lodepng_palette_add.\r\n  If you encode an image without alpha with palette, don't forget to put value 255 in each A byte of the palette.\r\n\r\n  When decoding, by default you can ignore this palette, since LodePNG already\r\n  fills the palette colors in the pixels of the raw RGBA output.\r\n\r\n  The palette is only supported for color type 3.\r\n  */\r\n  unsigned char* palette; /*palette in RGBARGBA... order. When allocated, must be either 0, or have size 1024*/\r\n  size_t palettesize; /*palette size in number of colors (amount of bytes is 4 * palettesize)*/\r\n\r\n  /*\r\n  transparent color key (tRNS)\r\n\r\n  This color uses the same bit depth as the bitdepth value in this struct, which can be 1-bit to 16-bit.\r\n  For greyscale PNGs, r, g and b will all 3 be set to the same.\r\n\r\n  When decoding, by default you can ignore this information, since LodePNG sets\r\n  pixels with this key to transparent already in the raw RGBA output.\r\n\r\n  The color key is only supported for color types 0 and 2.\r\n  */\r\n  unsigned key_defined; /*is a transparent color key given? 0 = false, 1 = true*/\r\n  unsigned key_r;       /*red/greyscale component of color key*/\r\n  unsigned key_g;       /*green component of color key*/\r\n  unsigned key_b;       /*blue component of color key*/\r\n} LodePNGColorMode;\r\n\r\n/*init, cleanup and copy functions to use with this struct*/\r\nvoid lodepng_color_mode_init(LodePNGColorMode* info);\r\nvoid lodepng_color_mode_cleanup(LodePNGColorMode* info);\r\n/*return value is error code (0 means no error)*/\r\nunsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source);\r\n\r\nvoid lodepng_palette_clear(LodePNGColorMode* info);\r\n/*add 1 color to the palette*/\r\nunsigned lodepng_palette_add(LodePNGColorMode* info,\r\n                             unsigned char r, unsigned char g, unsigned char b, unsigned char a);\r\n\r\n/*get the total amount of bits per pixel, based on colortype and bitdepth in the struct*/\r\nunsigned lodepng_get_bpp(const LodePNGColorMode* info);\r\n/*get the amount of color channels used, based on colortype in the struct.\r\nIf a palette is used, it counts as 1 channel.*/\r\nunsigned lodepng_get_channels(const LodePNGColorMode* info);\r\n/*is it a greyscale type? (only colortype 0 or 4)*/\r\nunsigned lodepng_is_greyscale_type(const LodePNGColorMode* info);\r\n/*has it got an alpha channel? (only colortype 2 or 6)*/\r\nunsigned lodepng_is_alpha_type(const LodePNGColorMode* info);\r\n/*has it got a palette? (only colortype 3)*/\r\nunsigned lodepng_is_palette_type(const LodePNGColorMode* info);\r\n/*only returns true if there is a palette and there is a value in the palette with alpha < 255.\r\nLoops through the palette to check this.*/\r\nunsigned lodepng_has_palette_alpha(const LodePNGColorMode* info);\r\n/*\r\nCheck if the given color info indicates the possibility of having non-opaque pixels in the PNG image.\r\nReturns true if the image can have translucent or invisible pixels (it still be opaque if it doesn't use such pixels).\r\nReturns false if the image can only have opaque pixels.\r\nIn detail, it returns true only if it's a color type with alpha, or has a palette with non-opaque values,\r\nor if \"key_defined\" is true.\r\n*/\r\nunsigned lodepng_can_have_alpha(const LodePNGColorMode* info);\r\n/*Returns the byte size of a raw image buffer with given width, height and color mode*/\r\nsize_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color);\r\n\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n/*The information of a Time chunk in PNG.*/\r\ntypedef struct LodePNGTime\r\n{\r\n  unsigned year;    /*2 bytes used (0-65535)*/\r\n  unsigned month;   /*1-12*/\r\n  unsigned day;     /*1-31*/\r\n  unsigned hour;    /*0-23*/\r\n  unsigned minute;  /*0-59*/\r\n  unsigned second;  /*0-60 (to allow for leap seconds)*/\r\n} LodePNGTime;\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n\r\n/*Information about the PNG image, except pixels, width and height.*/\r\ntypedef struct LodePNGInfo\r\n{\r\n  /*header (IHDR), palette (PLTE) and transparency (tRNS) chunks*/\r\n  unsigned compression_method;/*compression method of the original file. Always 0.*/\r\n  unsigned filter_method;     /*filter method of the original file*/\r\n  unsigned interlace_method;  /*interlace method of the original file*/\r\n  LodePNGColorMode color;     /*color type and bits, palette and transparency of the PNG file*/\r\n\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n  /*\r\n  suggested background color chunk (bKGD)\r\n  This color uses the same color mode as the PNG (except alpha channel), which can be 1-bit to 16-bit.\r\n\r\n  For greyscale PNGs, r, g and b will all 3 be set to the same. When encoding\r\n  the encoder writes the red one. For palette PNGs: When decoding, the RGB value\r\n  will be stored, not a palette index. But when encoding, specify the index of\r\n  the palette in background_r, the other two are then ignored.\r\n\r\n  The decoder does not use this background color to edit the color of pixels.\r\n  */\r\n  unsigned background_defined; /*is a suggested background color given?*/\r\n  unsigned background_r;       /*red component of suggested background color*/\r\n  unsigned background_g;       /*green component of suggested background color*/\r\n  unsigned background_b;       /*blue component of suggested background color*/\r\n\r\n  /*\r\n  non-international text chunks (tEXt and zTXt)\r\n\r\n  The char** arrays each contain num strings. The actual messages are in\r\n  text_strings, while text_keys are keywords that give a short description what\r\n  the actual text represents, e.g. Title, Author, Description, or anything else.\r\n\r\n  A keyword is minimum 1 character and maximum 79 characters long. It's\r\n  discouraged to use a single line length longer than 79 characters for texts.\r\n\r\n  Don't allocate these text buffers yourself. Use the init/cleanup functions\r\n  correctly and use lodepng_add_text and lodepng_clear_text.\r\n  */\r\n  size_t text_num; /*the amount of texts in these char** buffers (there may be more texts in itext)*/\r\n  char** text_keys; /*the keyword of a text chunk (e.g. \"Comment\")*/\r\n  char** text_strings; /*the actual text*/\r\n\r\n  /*\r\n  international text chunks (iTXt)\r\n  Similar to the non-international text chunks, but with additional strings\r\n  \"langtags\" and \"transkeys\".\r\n  */\r\n  size_t itext_num; /*the amount of international texts in this PNG*/\r\n  char** itext_keys; /*the English keyword of the text chunk (e.g. \"Comment\")*/\r\n  char** itext_langtags; /*language tag for this text's language, ISO/IEC 646 string, e.g. ISO 639 language tag*/\r\n  char** itext_transkeys; /*keyword translated to the international language - UTF-8 string*/\r\n  char** itext_strings; /*the actual international text - UTF-8 string*/\r\n\r\n  /*time chunk (tIME)*/\r\n  unsigned time_defined; /*set to 1 to make the encoder generate a tIME chunk*/\r\n  LodePNGTime time;\r\n\r\n  /*phys chunk (pHYs)*/\r\n  unsigned phys_defined; /*if 0, there is no pHYs chunk and the values below are undefined, if 1 else there is one*/\r\n  unsigned phys_x; /*pixels per unit in x direction*/\r\n  unsigned phys_y; /*pixels per unit in y direction*/\r\n  unsigned phys_unit; /*may be 0 (unknown unit) or 1 (metre)*/\r\n\r\n  /*\r\n  unknown chunks\r\n  There are 3 buffers, one for each position in the PNG where unknown chunks can appear\r\n  each buffer contains all unknown chunks for that position consecutively\r\n  The 3 buffers are the unknown chunks between certain critical chunks:\r\n  0: IHDR-PLTE, 1: PLTE-IDAT, 2: IDAT-IEND\r\n  Do not allocate or traverse this data yourself. Use the chunk traversing functions declared\r\n  later, such as lodepng_chunk_next and lodepng_chunk_append, to read/write this struct.\r\n  */\r\n  unsigned char* unknown_chunks_data[3];\r\n  size_t unknown_chunks_size[3]; /*size in bytes of the unknown chunks, given for protection*/\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n} LodePNGInfo;\r\n\r\n/*init, cleanup and copy functions to use with this struct*/\r\nvoid lodepng_info_init(LodePNGInfo* info);\r\nvoid lodepng_info_cleanup(LodePNGInfo* info);\r\n/*return value is error code (0 means no error)*/\r\nunsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source);\r\n\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\nvoid lodepng_clear_text(LodePNGInfo* info); /*use this to clear the texts again after you filled them in*/\r\nunsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str); /*push back both texts at once*/\r\n\r\nvoid lodepng_clear_itext(LodePNGInfo* info); /*use this to clear the itexts again after you filled them in*/\r\nunsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,\r\n                           const char* transkey, const char* str); /*push back the 4 texts of 1 chunk at once*/\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n\r\n/*\r\nConverts raw buffer from one color type to another color type, based on\r\nLodePNGColorMode structs to describe the input and output color type.\r\nSee the reference manual at the end of this header file to see which color conversions are supported.\r\nreturn value = LodePNG error code (0 if all went ok, an error if the conversion isn't supported)\r\nThe out buffer must have size (w * h * bpp + 7) / 8, where bpp is the bits per pixel\r\nof the output color type (lodepng_get_bpp).\r\nFor < 8 bpp images, there should not be padding bits at the end of scanlines.\r\nFor 16-bit per channel colors, uses big endian format like PNG does.\r\nReturn value is LodePNG error code\r\n*/\r\nunsigned lodepng_convert(unsigned char* out, const unsigned char* in,\r\n                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,\r\n                         unsigned w, unsigned h);\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n/*\r\nSettings for the decoder. This contains settings for the PNG and the Zlib\r\ndecoder, but not the Info settings from the Info structs.\r\n*/\r\ntypedef struct LodePNGDecoderSettings\r\n{\r\n  LodePNGDecompressSettings zlibsettings; /*in here is the setting to ignore Adler32 checksums*/\r\n\r\n  unsigned ignore_crc; /*ignore CRC checksums*/\r\n\r\n  unsigned color_convert; /*whether to convert the PNG to the color type you want. Default: yes*/\r\n\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n  unsigned read_text_chunks; /*if false but remember_unknown_chunks is true, they're stored in the unknown chunks*/\r\n  /*store all bytes from unknown chunks in the LodePNGInfo (off by default, useful for a png editor)*/\r\n  unsigned remember_unknown_chunks;\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n} LodePNGDecoderSettings;\r\n\r\nvoid lodepng_decoder_settings_init(LodePNGDecoderSettings* settings);\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n/*automatically use color type with less bits per pixel if losslessly possible. Default: AUTO*/\r\ntypedef enum LodePNGFilterStrategy\r\n{\r\n  /*every filter at zero*/\r\n  LFS_ZERO,\r\n  /*Use filter that gives minimum sum, as described in the official PNG filter heuristic.*/\r\n  LFS_MINSUM,\r\n  /*Use the filter type that gives smallest Shannon entropy for this scanline. Depending\r\n  on the image, this is better or worse than minsum.*/\r\n  LFS_ENTROPY,\r\n  /*\r\n  Brute-force-search PNG filters by compressing each filter for each scanline.\r\n  Experimental, very slow, and only rarely gives better compression than MINSUM.\r\n  */\r\n  LFS_BRUTE_FORCE,\r\n  /*use predefined_filters buffer: you specify the filter type for each scanline*/\r\n  LFS_PREDEFINED\r\n} LodePNGFilterStrategy;\r\n\r\n/*Gives characteristics about the colors of the image, which helps decide which color model to use for encoding.\r\nUsed internally by default if \"auto_convert\" is enabled. Public because it's useful for custom algorithms.*/\r\ntypedef struct LodePNGColorProfile\r\n{\r\n  unsigned colored; /*not greyscale*/\r\n  unsigned key; /*image is not opaque and color key is possible instead of full alpha*/\r\n  unsigned short key_r; /*key values, always as 16-bit, in 8-bit case the byte is duplicated, e.g. 65535 means 255*/\r\n  unsigned short key_g;\r\n  unsigned short key_b;\r\n  unsigned alpha; /*image is not opaque and alpha channel or alpha palette required*/\r\n  unsigned numcolors; /*amount of colors, up to 257. Not valid if bits == 16.*/\r\n  unsigned char palette[1024]; /*Remembers up to the first 256 RGBA colors, in no particular order*/\r\n  unsigned bits; /*bits per channel (not for palette). 1,2 or 4 for greyscale only. 16 if 16-bit per channel required.*/\r\n} LodePNGColorProfile;\r\n\r\nvoid lodepng_color_profile_init(LodePNGColorProfile* profile);\r\n\r\n/*Get a LodePNGColorProfile of the image.*/\r\nunsigned lodepng_get_color_profile(LodePNGColorProfile* profile,\r\n                                   const unsigned char* image, unsigned w, unsigned h,\r\n                                   const LodePNGColorMode* mode_in);\r\n/*The function LodePNG uses internally to decide the PNG color with auto_convert.\r\nChooses an optimal color model, e.g. grey if only grey pixels, palette if < 256 colors, ...*/\r\nunsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,\r\n                                   const unsigned char* image, unsigned w, unsigned h,\r\n                                   const LodePNGColorMode* mode_in);\r\n\r\n/*Settings for the encoder.*/\r\ntypedef struct LodePNGEncoderSettings\r\n{\r\n  LodePNGCompressSettings zlibsettings; /*settings for the zlib encoder, such as window size, ...*/\r\n\r\n  unsigned auto_convert; /*automatically choose output PNG color type. Default: true*/\r\n\r\n  /*If true, follows the official PNG heuristic: if the PNG uses a palette or lower than\r\n  8 bit depth, set all filters to zero. Otherwise use the filter_strategy. Note that to\r\n  completely follow the official PNG heuristic, filter_palette_zero must be true and\r\n  filter_strategy must be LFS_MINSUM*/\r\n  unsigned filter_palette_zero;\r\n  /*Which filter strategy to use when not using zeroes due to filter_palette_zero.\r\n  Set filter_palette_zero to 0 to ensure always using your chosen strategy. Default: LFS_MINSUM*/\r\n  LodePNGFilterStrategy filter_strategy;\r\n  /*used if filter_strategy is LFS_PREDEFINED. In that case, this must point to a buffer with\r\n  the same length as the amount of scanlines in the image, and each value must <= 5. You\r\n  have to cleanup this buffer, LodePNG will never free it. Don't forget that filter_palette_zero\r\n  must be set to 0 to ensure this is also used on palette or low bitdepth images.*/\r\n  const unsigned char* predefined_filters;\r\n\r\n  /*force creating a PLTE chunk if colortype is 2 or 6 (= a suggested palette).\r\n  If colortype is 3, PLTE is _always_ created.*/\r\n  unsigned force_palette;\r\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\r\n  /*add LodePNG identifier and version as a text chunk, for debugging*/\r\n  unsigned add_id;\r\n  /*encode text chunks as zTXt chunks instead of tEXt chunks, and use compression in iTXt chunks*/\r\n  unsigned text_compression;\r\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\r\n} LodePNGEncoderSettings;\r\n\r\nvoid lodepng_encoder_settings_init(LodePNGEncoderSettings* settings);\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n\r\n#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)\r\n/*The settings, state and information for extended encoding and decoding.*/\r\ntypedef struct LodePNGState\r\n{\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n  LodePNGDecoderSettings decoder; /*the decoding settings*/\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n  LodePNGEncoderSettings encoder; /*the encoding settings*/\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n  LodePNGColorMode info_raw; /*specifies the format in which you would like to get the raw pixel buffer*/\r\n  LodePNGInfo info_png; /*info of the PNG image obtained after decoding*/\r\n  unsigned error;\r\n#ifdef LODEPNG_COMPILE_CPP\r\n  /* For the lodepng::State subclass. */\r\n  virtual ~LodePNGState(){}\r\n#endif\r\n} LodePNGState;\r\n\r\n/*init, cleanup and copy functions to use with this struct*/\r\nvoid lodepng_state_init(LodePNGState* state);\r\nvoid lodepng_state_cleanup(LodePNGState* state);\r\nvoid lodepng_state_copy(LodePNGState* dest, const LodePNGState* source);\r\n#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n/*\r\nSame as lodepng_decode_memory, but uses a LodePNGState to allow custom settings and\r\ngetting much more information about the PNG image and color mode.\r\n*/\r\nunsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,\r\n                        LodePNGState* state,\r\n                        const unsigned char* in, size_t insize);\r\n\r\n/*\r\nRead the PNG header, but not the actual data. This returns only the information\r\nthat is in the header chunk of the PNG, such as width, height and color type. The\r\ninformation is placed in the info_png field of the LodePNGState.\r\n*/\r\nunsigned lodepng_inspect(unsigned* w, unsigned* h,\r\n                         LodePNGState* state,\r\n                         const unsigned char* in, size_t insize);\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n/*This function allocates the out buffer with standard malloc and stores the size in *outsize.*/\r\nunsigned lodepng_encode(unsigned char** out, size_t* outsize,\r\n                        const unsigned char* image, unsigned w, unsigned h,\r\n                        LodePNGState* state);\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n/*\r\nThe lodepng_chunk functions are normally not needed, except to traverse the\r\nunknown chunks stored in the LodePNGInfo struct, or add new ones to it.\r\nIt also allows traversing the chunks of an encoded PNG file yourself.\r\n\r\nPNG standard chunk naming conventions:\r\nFirst byte: uppercase = critical, lowercase = ancillary\r\nSecond byte: uppercase = public, lowercase = private\r\nThird byte: must be uppercase\r\nFourth byte: uppercase = unsafe to copy, lowercase = safe to copy\r\n*/\r\n\r\n/*\r\nGets the length of the data of the chunk. Total chunk length has 12 bytes more.\r\nThere must be at least 4 bytes to read from. If the result value is too large,\r\nit may be corrupt data.\r\n*/\r\nunsigned lodepng_chunk_length(const unsigned char* chunk);\r\n\r\n/*puts the 4-byte type in null terminated string*/\r\nvoid lodepng_chunk_type(char type[5], const unsigned char* chunk);\r\n\r\n/*check if the type is the given type*/\r\nunsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type);\r\n\r\n/*0: it's one of the critical chunk types, 1: it's an ancillary chunk (see PNG standard)*/\r\nunsigned char lodepng_chunk_ancillary(const unsigned char* chunk);\r\n\r\n/*0: public, 1: private (see PNG standard)*/\r\nunsigned char lodepng_chunk_private(const unsigned char* chunk);\r\n\r\n/*0: the chunk is unsafe to copy, 1: the chunk is safe to copy (see PNG standard)*/\r\nunsigned char lodepng_chunk_safetocopy(const unsigned char* chunk);\r\n\r\n/*get pointer to the data of the chunk, where the input points to the header of the chunk*/\r\nunsigned char* lodepng_chunk_data(unsigned char* chunk);\r\nconst unsigned char* lodepng_chunk_data_const(const unsigned char* chunk);\r\n\r\n/*returns 0 if the crc is correct, 1 if it's incorrect (0 for OK as usual!)*/\r\nunsigned lodepng_chunk_check_crc(const unsigned char* chunk);\r\n\r\n/*generates the correct CRC from the data and puts it in the last 4 bytes of the chunk*/\r\nvoid lodepng_chunk_generate_crc(unsigned char* chunk);\r\n\r\n/*iterate to next chunks. don't use on IEND chunk, as there is no next chunk then*/\r\nunsigned char* lodepng_chunk_next(unsigned char* chunk);\r\nconst unsigned char* lodepng_chunk_next_const(const unsigned char* chunk);\r\n\r\n/*\r\nAppends chunk to the data in out. The given chunk should already have its chunk header.\r\nThe out variable and outlength are updated to reflect the new reallocated buffer.\r\nReturns error code (0 if it went ok)\r\n*/\r\nunsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk);\r\n\r\n/*\r\nAppends new chunk to out. The chunk to append is given by giving its length, type\r\nand data separately. The type is a 4-letter string.\r\nThe out variable and outlength are updated to reflect the new reallocated buffer.\r\nReturne error code (0 if it went ok)\r\n*/\r\nunsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,\r\n                              const char* type, const unsigned char* data);\r\n\r\n\r\n/*Calculate CRC32 of buffer*/\r\nunsigned lodepng_crc32(const unsigned char* buf, size_t len);\r\n#endif /*LODEPNG_COMPILE_PNG*/\r\n\r\n\r\n#ifdef LODEPNG_COMPILE_ZLIB\r\n/*\r\nThis zlib part can be used independently to zlib compress and decompress a\r\nbuffer. It cannot be used to create gzip files however, and it only supports the\r\npart of zlib that is required for PNG, it does not support dictionaries.\r\n*/\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n/*Inflate a buffer. Inflate is the decompression step of deflate. Out buffer must be freed after use.*/\r\nunsigned lodepng_inflate(unsigned char** out, size_t* outsize,\r\n                         const unsigned char* in, size_t insize,\r\n                         const LodePNGDecompressSettings* settings);\r\n\r\n/*\r\nDecompresses Zlib data. Reallocates the out buffer and appends the data. The\r\ndata must be according to the zlib specification.\r\nEither, *out must be NULL and *outsize must be 0, or, *out must be a valid\r\nbuffer and *outsize its size in bytes. out must be freed by user after usage.\r\n*/\r\nunsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize,\r\n                                 const unsigned char* in, size_t insize,\r\n                                 const LodePNGDecompressSettings* settings);\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n/*\r\nCompresses data with Zlib. Reallocates the out buffer and appends the data.\r\nZlib adds a small header and trailer around the deflate data.\r\nThe data is output in the format of the zlib specification.\r\nEither, *out must be NULL and *outsize must be 0, or, *out must be a valid\r\nbuffer and *outsize its size in bytes. out must be freed by user after usage.\r\n*/\r\nunsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize,\r\n                               const unsigned char* in, size_t insize,\r\n                               const LodePNGCompressSettings* settings);\r\n\r\n/*\r\nFind length-limited Huffman code for given frequencies. This function is in the\r\npublic interface only for tests, it's used internally by lodepng_deflate.\r\n*/\r\nunsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,\r\n                                      size_t numcodes, unsigned maxbitlen);\r\n\r\n/*Compress a buffer with deflate. See RFC 1951. Out buffer must be freed after use.*/\r\nunsigned lodepng_deflate(unsigned char** out, size_t* outsize,\r\n                         const unsigned char* in, size_t insize,\r\n                         const LodePNGCompressSettings* settings);\r\n\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n#endif /*LODEPNG_COMPILE_ZLIB*/\r\n\r\n#ifdef LODEPNG_COMPILE_DISK\r\n/*\r\nLoad a file from disk into buffer. The function allocates the out buffer, and\r\nafter usage you should free it.\r\nout: output parameter, contains pointer to loaded buffer.\r\noutsize: output parameter, size of the allocated out buffer\r\nfilename: the path to the file to load\r\nreturn value: error code (0 means ok)\r\n*/\r\nunsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename);\r\n\r\n/*\r\nSave a file from buffer to disk. Warning, if it exists, this function overwrites\r\nthe file without warning!\r\nbuffer: the buffer to write\r\nbuffersize: size of the buffer to write\r\nfilename: the path to the file to save to\r\nreturn value: error code (0 means ok)\r\n*/\r\nunsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename);\r\n#endif /*LODEPNG_COMPILE_DISK*/\r\n\r\n#ifdef LODEPNG_COMPILE_CPP\r\n/* The LodePNG C++ wrapper uses std::vectors instead of manually allocated memory buffers. */\r\nnamespace lodepng\r\n{\r\n#ifdef LODEPNG_COMPILE_PNG\r\nclass State : public LodePNGState\r\n{\r\n  public:\r\n    State();\r\n    State(const State& other);\r\n    virtual ~State();\r\n    State& operator=(const State& other);\r\n};\r\n\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n/* Same as other lodepng::decode, but using a State for more settings and information. */\r\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\r\n                State& state,\r\n                const unsigned char* in, size_t insize);\r\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\r\n                State& state,\r\n                const std::vector<unsigned char>& in);\r\n#endif /*LODEPNG_COMPILE_DECODER*/\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n/* Same as other lodepng::encode, but using a State for more settings and information. */\r\nunsigned encode(std::vector<unsigned char>& out,\r\n                const unsigned char* in, unsigned w, unsigned h,\r\n                State& state);\r\nunsigned encode(std::vector<unsigned char>& out,\r\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\r\n                State& state);\r\n#endif /*LODEPNG_COMPILE_ENCODER*/\r\n\r\n#ifdef LODEPNG_COMPILE_DISK\r\n/*\r\nLoad a file from disk into an std::vector.\r\nreturn value: error code (0 means ok)\r\n*/\r\nunsigned load_file(std::vector<unsigned char>& buffer, const std::string& filename);\r\n\r\n/*\r\nSave the binary data in an std::vector to a file on disk. The file is overwritten\r\nwithout warning.\r\n*/\r\nunsigned save_file(const std::vector<unsigned char>& buffer, const std::string& filename);\r\n#endif /* LODEPNG_COMPILE_DISK */\r\n#endif /* LODEPNG_COMPILE_PNG */\r\n\r\n#ifdef LODEPNG_COMPILE_ZLIB\r\n#ifdef LODEPNG_COMPILE_DECODER\r\n/* Zlib-decompress an unsigned char buffer */\r\nunsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\r\n                    const LodePNGDecompressSettings& settings = lodepng_default_decompress_settings);\r\n\r\n/* Zlib-decompress an std::vector */\r\nunsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\r\n                    const LodePNGDecompressSettings& settings = lodepng_default_decompress_settings);\r\n#endif /* LODEPNG_COMPILE_DECODER */\r\n\r\n#ifdef LODEPNG_COMPILE_ENCODER\r\n/* Zlib-compress an unsigned char buffer */\r\nunsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\r\n                  const LodePNGCompressSettings& settings = lodepng_default_compress_settings);\r\n\r\n/* Zlib-compress an std::vector */\r\nunsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\r\n                  const LodePNGCompressSettings& settings = lodepng_default_compress_settings);\r\n#endif /* LODEPNG_COMPILE_ENCODER */\r\n#endif /* LODEPNG_COMPILE_ZLIB */\r\n} /* namespace lodepng */\r\n#endif /*LODEPNG_COMPILE_CPP*/\r\n\r\n/*\r\nTODO:\r\n[.] test if there are no memory leaks or security exploits - done a lot but needs to be checked often\r\n[.] check compatibility with various compilers  - done but needs to be redone for every newer version\r\n[X] converting color to 16-bit per channel types\r\n[ ] read all public PNG chunk types (but never let the color profile and gamma ones touch RGB values)\r\n[ ] make sure encoder generates no chunks with size > (2^31)-1\r\n[ ] partial decoding (stream processing)\r\n[X] let the \"isFullyOpaque\" function check color keys and transparent palettes too\r\n[X] better name for the variables \"codes\", \"codesD\", \"codelengthcodes\", \"clcl\" and \"lldl\"\r\n[ ] don't stop decoding on errors like 69, 57, 58 (make warnings)\r\n[ ] make warnings like: oob palette, checksum fail, data after iend, wrong/unknown crit chunk, no null terminator in text, ...\r\n[ ] let the C++ wrapper catch exceptions coming from the standard library and return LodePNG error codes\r\n[ ] allow user to provide custom color conversion functions, e.g. for premultiplied alpha, padding bits or not, ...\r\n[ ] allow user to give data (void*) to custom allocator\r\n*/\r\n\r\n#endif /*LODEPNG_H inclusion guard*/\r\n\r\n/*\r\nLodePNG Documentation\r\n---------------------\r\n\r\n0. table of contents\r\n--------------------\r\n\r\n  1. about\r\n   1.1. supported features\r\n   1.2. features not supported\r\n  2. C and C++ version\r\n  3. security\r\n  4. decoding\r\n  5. encoding\r\n  6. color conversions\r\n    6.1. PNG color types\r\n    6.2. color conversions\r\n    6.3. padding bits\r\n    6.4. A note about 16-bits per channel and endianness\r\n  7. error values\r\n  8. chunks and PNG editing\r\n  9. compiler support\r\n  10. examples\r\n   10.1. decoder C++ example\r\n   10.2. decoder C example\r\n  11. state settings reference\r\n  12. changes\r\n  13. contact information\r\n\r\n\r\n1. about\r\n--------\r\n\r\nPNG is a file format to store raster images losslessly with good compression,\r\nsupporting different color types and alpha channel.\r\n\r\nLodePNG is a PNG codec according to the Portable Network Graphics (PNG)\r\nSpecification (Second Edition) - W3C Recommendation 10 November 2003.\r\n\r\nThe specifications used are:\r\n\r\n*) Portable Network Graphics (PNG) Specification (Second Edition):\r\n     http://www.w3.org/TR/2003/REC-PNG-20031110\r\n*) RFC 1950 ZLIB Compressed Data Format version 3.3:\r\n     http://www.gzip.org/zlib/rfc-zlib.html\r\n*) RFC 1951 DEFLATE Compressed Data Format Specification ver 1.3:\r\n     http://www.gzip.org/zlib/rfc-deflate.html\r\n\r\nThe most recent version of LodePNG can currently be found at\r\nhttp://lodev.org/lodepng/\r\n\r\nLodePNG works both in C (ISO C90) and C++, with a C++ wrapper that adds\r\nextra functionality.\r\n\r\nLodePNG exists out of two files:\r\n-lodepng.h: the header file for both C and C++\r\n-lodepng.c(pp): give it the name lodepng.c or lodepng.cpp (or .cc) depending on your usage\r\n\r\nIf you want to start using LodePNG right away without reading this doc, get the\r\nexamples from the LodePNG website to see how to use it in code, or check the\r\nsmaller examples in chapter 13 here.\r\n\r\nLodePNG is simple but only supports the basic requirements. To achieve\r\nsimplicity, the following design choices were made: There are no dependencies\r\non any external library. There are functions to decode and encode a PNG with\r\na single function call, and extended versions of these functions taking a\r\nLodePNGState struct allowing to specify or get more information. By default\r\nthe colors of the raw image are always RGB or RGBA, no matter what color type\r\nthe PNG file uses. To read and write files, there are simple functions to\r\nconvert the files to/from buffers in memory.\r\n\r\nThis all makes LodePNG suitable for loading textures in games, demos and small\r\nprograms, ... It's less suitable for full fledged image editors, loading PNGs\r\nover network (it requires all the image data to be available before decoding can\r\nbegin), life-critical systems, ...\r\n\r\n1.1. supported features\r\n-----------------------\r\n\r\nThe following features are supported by the decoder:\r\n\r\n*) decoding of PNGs with any color type, bit depth and interlace mode, to a 24- or 32-bit color raw image,\r\n   or the same color type as the PNG\r\n*) encoding of PNGs, from any raw image to 24- or 32-bit color, or the same color type as the raw image\r\n*) Adam7 interlace and deinterlace for any color type\r\n*) loading the image from harddisk or decoding it from a buffer from other sources than harddisk\r\n*) support for alpha channels, including RGBA color model, translucent palettes and color keying\r\n*) zlib decompression (inflate)\r\n*) zlib compression (deflate)\r\n*) CRC32 and ADLER32 checksums\r\n*) handling of unknown chunks, allowing making a PNG editor that stores custom and unknown chunks.\r\n*) the following chunks are supported (generated/interpreted) by both encoder and decoder:\r\n    IHDR: header information\r\n    PLTE: color palette\r\n    IDAT: pixel data\r\n    IEND: the final chunk\r\n    tRNS: transparency for palettized images\r\n    tEXt: textual information\r\n    zTXt: compressed textual information\r\n    iTXt: international textual information\r\n    bKGD: suggested background color\r\n    pHYs: physical dimensions\r\n    tIME: modification time\r\n\r\n1.2. features not supported\r\n---------------------------\r\n\r\nThe following features are _not_ supported:\r\n\r\n*) some features needed to make a conformant PNG-Editor might be still missing.\r\n*) partial loading/stream processing. All data must be available and is processed in one call.\r\n*) The following public chunks are not supported but treated as unknown chunks by LodePNG\r\n    cHRM, gAMA, iCCP, sRGB, sBIT, hIST, sPLT\r\n   Some of these are not supported on purpose: LodePNG wants to provide the RGB values\r\n   stored in the pixels, not values modified by system dependent gamma or color models.\r\n\r\n\r\n2. C and C++ version\r\n--------------------\r\n\r\nThe C version uses buffers allocated with alloc that you need to free()\r\nyourself. You need to use init and cleanup functions for each struct whenever\r\nusing a struct from the C version to avoid exploits and memory leaks.\r\n\r\nThe C++ version has extra functions with std::vectors in the interface and the\r\nlodepng::State class which is a LodePNGState with constructor and destructor.\r\n\r\nThese files work without modification for both C and C++ compilers because all\r\nthe additional C++ code is in \"#ifdef __cplusplus\" blocks that make C-compilers\r\nignore it, and the C code is made to compile both with strict ISO C90 and C++.\r\n\r\nTo use the C++ version, you need to rename the source file to lodepng.cpp\r\n(instead of lodepng.c), and compile it with a C++ compiler.\r\n\r\nTo use the C version, you need to rename the source file to lodepng.c (instead\r\nof lodepng.cpp), and compile it with a C compiler.\r\n\r\n\r\n3. Security\r\n-----------\r\n\r\nEven if carefully designed, it's always possible that LodePNG contains possible\r\nexploits. If you discover one, please let me know, and it will be fixed.\r\n\r\nWhen using LodePNG, care has to be taken with the C version of LodePNG, as well\r\nas the C-style structs when working with C++. The following conventions are used\r\nfor all C-style structs:\r\n\r\n-if a struct has a corresponding init function, always call the init function when making a new one\r\n-if a struct has a corresponding cleanup function, call it before the struct disappears to avoid memory leaks\r\n-if a struct has a corresponding copy function, use the copy function instead of \"=\".\r\n The destination must also be inited already.\r\n\r\n\r\n4. Decoding\r\n-----------\r\n\r\nDecoding converts a PNG compressed image to a raw pixel buffer.\r\n\r\nMost documentation on using the decoder is at its declarations in the header\r\nabove. For C, simple decoding can be done with functions such as\r\nlodepng_decode32, and more advanced decoding can be done with the struct\r\nLodePNGState and lodepng_decode. For C++, all decoding can be done with the\r\nvarious lodepng::decode functions, and lodepng::State can be used for advanced\r\nfeatures.\r\n\r\nWhen using the LodePNGState, it uses the following fields for decoding:\r\n*) LodePNGInfo info_png: it stores extra information about the PNG (the input) in here\r\n*) LodePNGColorMode info_raw: here you can say what color mode of the raw image (the output) you want to get\r\n*) LodePNGDecoderSettings decoder: you can specify a few extra settings for the decoder to use\r\n\r\nLodePNGInfo info_png\r\n--------------------\r\n\r\nAfter decoding, this contains extra information of the PNG image, except the actual\r\npixels, width and height because these are already gotten directly from the decoder\r\nfunctions.\r\n\r\nIt contains for example the original color type of the PNG image, text comments,\r\nsuggested background color, etc... More details about the LodePNGInfo struct are\r\nat its declaration documentation.\r\n\r\nLodePNGColorMode info_raw\r\n-------------------------\r\n\r\nWhen decoding, here you can specify which color type you want\r\nthe resulting raw image to be. If this is different from the colortype of the\r\nPNG, then the decoder will automatically convert the result. This conversion\r\nalways works, except if you want it to convert a color PNG to greyscale or to\r\na palette with missing colors.\r\n\r\nBy default, 32-bit color is used for the result.\r\n\r\nLodePNGDecoderSettings decoder\r\n------------------------------\r\n\r\nThe settings can be used to ignore the errors created by invalid CRC and Adler32\r\nchunks, and to disable the decoding of tEXt chunks.\r\n\r\nThere's also a setting color_convert, true by default. If false, no conversion\r\nis done, the resulting data will be as it was in the PNG (after decompression)\r\nand you'll have to puzzle the colors of the pixels together yourself using the\r\ncolor type information in the LodePNGInfo.\r\n\r\n\r\n5. Encoding\r\n-----------\r\n\r\nEncoding converts a raw pixel buffer to a PNG compressed image.\r\n\r\nMost documentation on using the encoder is at its declarations in the header\r\nabove. For C, simple encoding can be done with functions such as\r\nlodepng_encode32, and more advanced decoding can be done with the struct\r\nLodePNGState and lodepng_encode. For C++, all encoding can be done with the\r\nvarious lodepng::encode functions, and lodepng::State can be used for advanced\r\nfeatures.\r\n\r\nLike the decoder, the encoder can also give errors. However it gives less errors\r\nsince the encoder input is trusted, the decoder input (a PNG image that could\r\nbe forged by anyone) is not trusted.\r\n\r\nWhen using the LodePNGState, it uses the following fields for encoding:\r\n*) LodePNGInfo info_png: here you specify how you want the PNG (the output) to be.\r\n*) LodePNGColorMode info_raw: here you say what color type of the raw image (the input) has\r\n*) LodePNGEncoderSettings encoder: you can specify a few settings for the encoder to use\r\n\r\nLodePNGInfo info_png\r\n--------------------\r\n\r\nWhen encoding, you use this the opposite way as when decoding: for encoding,\r\nyou fill in the values you want the PNG to have before encoding. By default it's\r\nnot needed to specify a color type for the PNG since it's automatically chosen,\r\nbut it's possible to choose it yourself given the right settings.\r\n\r\nThe encoder will not always exactly match the LodePNGInfo struct you give,\r\nit tries as close as possible. Some things are ignored by the encoder. The\r\nencoder uses, for example, the following settings from it when applicable:\r\ncolortype and bitdepth, text chunks, time chunk, the color key, the palette, the\r\nbackground color, the interlace method, unknown chunks, ...\r\n\r\nWhen encoding to a PNG with colortype 3, the encoder will generate a PLTE chunk.\r\nIf the palette contains any colors for which the alpha channel is not 255 (so\r\nthere are translucent colors in the palette), it'll add a tRNS chunk.\r\n\r\nLodePNGColorMode info_raw\r\n-------------------------\r\n\r\nYou specify the color type of the raw image that you give to the input here,\r\nincluding a possible transparent color key and palette you happen to be using in\r\nyour raw image data.\r\n\r\nBy default, 32-bit color is assumed, meaning your input has to be in RGBA\r\nformat with 4 bytes (unsigned chars) per pixel.\r\n\r\nLodePNGEncoderSettings encoder\r\n------------------------------\r\n\r\nThe following settings are supported (some are in sub-structs):\r\n*) auto_convert: when this option is enabled, the encoder will\r\nautomatically choose the smallest possible color mode (including color key) that\r\ncan encode the colors of all pixels without information loss.\r\n*) btype: the block type for LZ77. 0 = uncompressed, 1 = fixed huffman tree,\r\n   2 = dynamic huffman tree (best compression). Should be 2 for proper\r\n   compression.\r\n*) use_lz77: whether or not to use LZ77 for compressed block types. Should be\r\n   true for proper compression.\r\n*) windowsize: the window size used by the LZ77 encoder (1 - 32768). Has value\r\n   2048 by default, but can be set to 32768 for better, but slow, compression.\r\n*) force_palette: if colortype is 2 or 6, you can make the encoder write a PLTE\r\n   chunk if force_palette is true. This can used as suggested palette to convert\r\n   to by viewers that don't support more than 256 colors (if those still exist)\r\n*) add_id: add text chunk \"Encoder: LodePNG <version>\" to the image.\r\n*) text_compression: default 1. If 1, it'll store texts as zTXt instead of tEXt chunks.\r\n  zTXt chunks use zlib compression on the text. This gives a smaller result on\r\n  large texts but a larger result on small texts (such as a single program name).\r\n  It's all tEXt or all zTXt though, there's no separate setting per text yet.\r\n\r\n\r\n6. color conversions\r\n--------------------\r\n\r\nAn important thing to note about LodePNG, is that the color type of the PNG, and\r\nthe color type of the raw image, are completely independent. By default, when\r\nyou decode a PNG, you get the result as a raw image in the color type you want,\r\nno matter whether the PNG was encoded with a palette, greyscale or RGBA color.\r\nAnd if you encode an image, by default LodePNG will automatically choose the PNG\r\ncolor type that gives good compression based on the values of colors and amount\r\nof colors in the image. It can be configured to let you control it instead as\r\nwell, though.\r\n\r\nTo be able to do this, LodePNG does conversions from one color mode to another.\r\nIt can convert from almost any color type to any other color type, except the\r\nfollowing conversions: RGB to greyscale is not supported, and converting to a\r\npalette when the palette doesn't have a required color is not supported. This is\r\nnot supported on purpose: this is information loss which requires a color\r\nreduction algorithm that is beyong the scope of a PNG encoder (yes, RGB to grey\r\nis easy, but there are multiple ways if you want to give some channels more\r\nweight).\r\n\r\nBy default, when decoding, you get the raw image in 32-bit RGBA or 24-bit RGB\r\ncolor, no matter what color type the PNG has. And by default when encoding,\r\nLodePNG automatically picks the best color model for the output PNG, and expects\r\nthe input image to be 32-bit RGBA or 24-bit RGB. So, unless you want to control\r\nthe color format of the images yourself, you can skip this chapter.\r\n\r\n6.1. PNG color types\r\n--------------------\r\n\r\nA PNG image can have many color types, ranging from 1-bit color to 64-bit color,\r\nas well as palettized color modes. After the zlib decompression and unfiltering\r\nin the PNG image is done, the raw pixel data will have that color type and thus\r\na certain amount of bits per pixel. If you want the output raw image after\r\ndecoding to have another color type, a conversion is done by LodePNG.\r\n\r\nThe PNG specification gives the following color types:\r\n\r\n0: greyscale, bit depths 1, 2, 4, 8, 16\r\n2: RGB, bit depths 8 and 16\r\n3: palette, bit depths 1, 2, 4 and 8\r\n4: greyscale with alpha, bit depths 8 and 16\r\n6: RGBA, bit depths 8 and 16\r\n\r\nBit depth is the amount of bits per pixel per color channel. So the total amount\r\nof bits per pixel is: amount of channels * bitdepth.\r\n\r\n6.2. color conversions\r\n----------------------\r\n\r\nAs explained in the sections about the encoder and decoder, you can specify\r\ncolor types and bit depths in info_png and info_raw to change the default\r\nbehaviour.\r\n\r\nIf, when decoding, you want the raw image to be something else than the default,\r\nyou need to set the color type and bit depth you want in the LodePNGColorMode,\r\nor the parameters colortype and bitdepth of the simple decoding function.\r\n\r\nIf, when encoding, you use another color type than the default in the raw input\r\nimage, you need to specify its color type and bit depth in the LodePNGColorMode\r\nof the raw image, or use the parameters colortype and bitdepth of the simple\r\nencoding function.\r\n\r\nIf, when encoding, you don't want LodePNG to choose the output PNG color type\r\nbut control it yourself, you need to set auto_convert in the encoder settings\r\nto false, and specify the color type you want in the LodePNGInfo of the\r\nencoder (including palette: it can generate a palette if auto_convert is true,\r\notherwise not).\r\n\r\nIf the input and output color type differ (whether user chosen or auto chosen),\r\nLodePNG will do a color conversion, which follows the rules below, and may\r\nsometimes result in an error.\r\n\r\nTo avoid some confusion:\r\n-the decoder converts from PNG to raw image\r\n-the encoder converts from raw image to PNG\r\n-the colortype and bitdepth in LodePNGColorMode info_raw, are those of the raw image\r\n-the colortype and bitdepth in the color field of LodePNGInfo info_png, are those of the PNG\r\n-when encoding, the color type in LodePNGInfo is ignored if auto_convert\r\n is enabled, it is automatically generated instead\r\n-when decoding, the color type in LodePNGInfo is set by the decoder to that of the original\r\n PNG image, but it can be ignored since the raw image has the color type you requested instead\r\n-if the color type of the LodePNGColorMode and PNG image aren't the same, a conversion\r\n between the color types is done if the color types are supported. If it is not\r\n supported, an error is returned. If the types are the same, no conversion is done.\r\n-even though some conversions aren't supported, LodePNG supports loading PNGs from any\r\n colortype and saving PNGs to any colortype, sometimes it just requires preparing\r\n the raw image correctly before encoding.\r\n-both encoder and decoder use the same color converter.\r\n\r\nNon supported color conversions:\r\n-color to greyscale: no error is thrown, but the result will look ugly because\r\nonly the red channel is taken\r\n-anything to palette when that palette does not have that color in it: in this\r\ncase an error is thrown\r\n\r\nSupported color conversions:\r\n-anything to 8-bit RGB, 8-bit RGBA, 16-bit RGB, 16-bit RGBA\r\n-any grey or grey+alpha, to grey or grey+alpha\r\n-anything to a palette, as long as the palette has the requested colors in it\r\n-removing alpha channel\r\n-higher to smaller bitdepth, and vice versa\r\n\r\nIf you want no color conversion to be done (e.g. for speed or control):\r\n-In the encoder, you can make it save a PNG with any color type by giving the\r\nraw color mode and LodePNGInfo the same color mode, and setting auto_convert to\r\nfalse.\r\n-In the decoder, you can make it store the pixel data in the same color type\r\nas the PNG has, by setting the color_convert setting to false. Settings in\r\ninfo_raw are then ignored.\r\n\r\nThe function lodepng_convert does the color conversion. It is available in the\r\ninterface but normally isn't needed since the encoder and decoder already call\r\nit.\r\n\r\n6.3. padding bits\r\n-----------------\r\n\r\nIn the PNG file format, if a less than 8-bit per pixel color type is used and the scanlines\r\nhave a bit amount that isn't a multiple of 8, then padding bits are used so that each\r\nscanline starts at a fresh byte. But that is NOT true for the LodePNG raw input and output.\r\nThe raw input image you give to the encoder, and the raw output image you get from the decoder\r\nwill NOT have these padding bits, e.g. in the case of a 1-bit image with a width\r\nof 7 pixels, the first pixel of the second scanline will the the 8th bit of the first byte,\r\nnot the first bit of a new byte.\r\n\r\n6.4. A note about 16-bits per channel and endianness\r\n----------------------------------------------------\r\n\r\nLodePNG uses unsigned char arrays for 16-bit per channel colors too, just like\r\nfor any other color format. The 16-bit values are stored in big endian (most\r\nsignificant byte first) in these arrays. This is the opposite order of the\r\nlittle endian used by x86 CPU's.\r\n\r\nLodePNG always uses big endian because the PNG file format does so internally.\r\nConversions to other formats than PNG uses internally are not supported by\r\nLodePNG on purpose, there are myriads of formats, including endianness of 16-bit\r\ncolors, the order in which you store R, G, B and A, and so on. Supporting and\r\nconverting to/from all that is outside the scope of LodePNG.\r\n\r\nThis may mean that, depending on your use case, you may want to convert the big\r\nendian output of LodePNG to little endian with a for loop. This is certainly not\r\nalways needed, many applications and libraries support big endian 16-bit colors\r\nanyway, but it means you cannot simply cast the unsigned char* buffer to an\r\nunsigned short* buffer on x86 CPUs.\r\n\r\n\r\n7. error values\r\n---------------\r\n\r\nAll functions in LodePNG that return an error code, return 0 if everything went\r\nOK, or a non-zero code if there was an error.\r\n\r\nThe meaning of the LodePNG error values can be retrieved with the function\r\nlodepng_error_text: given the numerical error code, it returns a description\r\nof the error in English as a string.\r\n\r\nCheck the implementation of lodepng_error_text to see the meaning of each code.\r\n\r\n\r\n8. chunks and PNG editing\r\n-------------------------\r\n\r\nIf you want to add extra chunks to a PNG you encode, or use LodePNG for a PNG\r\neditor that should follow the rules about handling of unknown chunks, or if your\r\nprogram is able to read other types of chunks than the ones handled by LodePNG,\r\nthen that's possible with the chunk functions of LodePNG.\r\n\r\nA PNG chunk has the following layout:\r\n\r\n4 bytes length\r\n4 bytes type name\r\nlength bytes data\r\n4 bytes CRC\r\n\r\n8.1. iterating through chunks\r\n-----------------------------\r\n\r\nIf you have a buffer containing the PNG image data, then the first chunk (the\r\nIHDR chunk) starts at byte number 8 of that buffer. The first 8 bytes are the\r\nsignature of the PNG and are not part of a chunk. But if you start at byte 8\r\nthen you have a chunk, and can check the following things of it.\r\n\r\nNOTE: none of these functions check for memory buffer boundaries. To avoid\r\nexploits, always make sure the buffer contains all the data of the chunks.\r\nWhen using lodepng_chunk_next, make sure the returned value is within the\r\nallocated memory.\r\n\r\nunsigned lodepng_chunk_length(const unsigned char* chunk):\r\n\r\nGet the length of the chunk's data. The total chunk length is this length + 12.\r\n\r\nvoid lodepng_chunk_type(char type[5], const unsigned char* chunk):\r\nunsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type):\r\n\r\nGet the type of the chunk or compare if it's a certain type\r\n\r\nunsigned char lodepng_chunk_critical(const unsigned char* chunk):\r\nunsigned char lodepng_chunk_private(const unsigned char* chunk):\r\nunsigned char lodepng_chunk_safetocopy(const unsigned char* chunk):\r\n\r\nCheck if the chunk is critical in the PNG standard (only IHDR, PLTE, IDAT and IEND are).\r\nCheck if the chunk is private (public chunks are part of the standard, private ones not).\r\nCheck if the chunk is safe to copy. If it's not, then, when modifying data in a critical\r\nchunk, unsafe to copy chunks of the old image may NOT be saved in the new one if your\r\nprogram doesn't handle that type of unknown chunk.\r\n\r\nunsigned char* lodepng_chunk_data(unsigned char* chunk):\r\nconst unsigned char* lodepng_chunk_data_const(const unsigned char* chunk):\r\n\r\nGet a pointer to the start of the data of the chunk.\r\n\r\nunsigned lodepng_chunk_check_crc(const unsigned char* chunk):\r\nvoid lodepng_chunk_generate_crc(unsigned char* chunk):\r\n\r\nCheck if the crc is correct or generate a correct one.\r\n\r\nunsigned char* lodepng_chunk_next(unsigned char* chunk):\r\nconst unsigned char* lodepng_chunk_next_const(const unsigned char* chunk):\r\n\r\nIterate to the next chunk. This works if you have a buffer with consecutive chunks. Note that these\r\nfunctions do no boundary checking of the allocated data whatsoever, so make sure there is enough\r\ndata available in the buffer to be able to go to the next chunk.\r\n\r\nunsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk):\r\nunsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,\r\n                              const char* type, const unsigned char* data):\r\n\r\nThese functions are used to create new chunks that are appended to the data in *out that has\r\nlength *outlength. The append function appends an existing chunk to the new data. The create\r\nfunction creates a new chunk with the given parameters and appends it. Type is the 4-letter\r\nname of the chunk.\r\n\r\n8.2. chunks in info_png\r\n-----------------------\r\n\r\nThe LodePNGInfo struct contains fields with the unknown chunk in it. It has 3\r\nbuffers (each with size) to contain 3 types of unknown chunks:\r\nthe ones that come before the PLTE chunk, the ones that come between the PLTE\r\nand the IDAT chunks, and the ones that come after the IDAT chunks.\r\nIt's necessary to make the distionction between these 3 cases because the PNG\r\nstandard forces to keep the ordering of unknown chunks compared to the critical\r\nchunks, but does not force any other ordering rules.\r\n\r\ninfo_png.unknown_chunks_data[0] is the chunks before PLTE\r\ninfo_png.unknown_chunks_data[1] is the chunks after PLTE, before IDAT\r\ninfo_png.unknown_chunks_data[2] is the chunks after IDAT\r\n\r\nThe chunks in these 3 buffers can be iterated through and read by using the same\r\nway described in the previous subchapter.\r\n\r\nWhen using the decoder to decode a PNG, you can make it store all unknown chunks\r\nif you set the option settings.remember_unknown_chunks to 1. By default, this\r\noption is off (0).\r\n\r\nThe encoder will always encode unknown chunks that are stored in the info_png.\r\nIf you need it to add a particular chunk that isn't known by LodePNG, you can\r\nuse lodepng_chunk_append or lodepng_chunk_create to the chunk data in\r\ninfo_png.unknown_chunks_data[x].\r\n\r\nChunks that are known by LodePNG should not be added in that way. E.g. to make\r\nLodePNG add a bKGD chunk, set background_defined to true and add the correct\r\nparameters there instead.\r\n\r\n\r\n9. compiler support\r\n-------------------\r\n\r\nNo libraries other than the current standard C library are needed to compile\r\nLodePNG. For the C++ version, only the standard C++ library is needed on top.\r\nAdd the files lodepng.c(pp) and lodepng.h to your project, include\r\nlodepng.h where needed, and your program can read/write PNG files.\r\n\r\nIt is compatible with C90 and up, and C++03 and up.\r\n\r\nIf performance is important, use optimization when compiling! For both the\r\nencoder and decoder, this makes a large difference.\r\n\r\nMake sure that LodePNG is compiled with the same compiler of the same version\r\nand with the same settings as the rest of the program, or the interfaces with\r\nstd::vectors and std::strings in C++ can be incompatible.\r\n\r\nCHAR_BITS must be 8 or higher, because LodePNG uses unsigned chars for octets.\r\n\r\n*) gcc and g++\r\n\r\nLodePNG is developed in gcc so this compiler is natively supported. It gives no\r\nwarnings with compiler options \"-Wall -Wextra -pedantic -ansi\", with gcc and g++\r\nversion 4.7.1 on Linux, 32-bit and 64-bit.\r\n\r\n*) Clang\r\n\r\nFully supported and warning-free.\r\n\r\n*) Mingw\r\n\r\nThe Mingw compiler (a port of gcc for Windows) should be fully supported by\r\nLodePNG.\r\n\r\n*) Visual Studio and Visual C++ Express Edition\r\n\r\nLodePNG should be warning-free with warning level W4. Two warnings were disabled\r\nwith pragmas though: warning 4244 about implicit conversions, and warning 4996\r\nwhere it wants to use a non-standard function fopen_s instead of the standard C\r\nfopen.\r\n\r\nVisual Studio may want \"stdafx.h\" files to be included in each source file and\r\ngive an error \"unexpected end of file while looking for precompiled header\".\r\nThis is not standard C++ and will not be added to the stock LodePNG. You can\r\ndisable it for lodepng.cpp only by right clicking it, Properties, C/C++,\r\nPrecompiled Headers, and set it to Not Using Precompiled Headers there.\r\n\r\nNOTE: Modern versions of VS should be fully supported, but old versions, e.g.\r\nVS6, are not guaranteed to work.\r\n\r\n*) Compilers on Macintosh\r\n\r\nLodePNG has been reported to work both with gcc and LLVM for Macintosh, both for\r\nC and C++.\r\n\r\n*) Other Compilers\r\n\r\nIf you encounter problems on any compilers, feel free to let me know and I may\r\ntry to fix it if the compiler is modern and standards complient.\r\n\r\n\r\n10. examples\r\n------------\r\n\r\nThis decoder example shows the most basic usage of LodePNG. More complex\r\nexamples can be found on the LodePNG website.\r\n\r\n10.1. decoder C++ example\r\n-------------------------\r\n\r\n#include \"lodepng.h\"\r\n#include <iostream>\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n  const char* filename = argc > 1 ? argv[1] : \"test.png\";\r\n\r\n  //load and decode\r\n  std::vector<unsigned char> image;\r\n  unsigned width, height;\r\n  unsigned error = lodepng::decode(image, width, height, filename);\r\n\r\n  //if there's an error, display it\r\n  if(error) std::cout << \"decoder error \" << error << \": \" << lodepng_error_text(error) << std::endl;\r\n\r\n  //the pixels are now in the vector \"image\", 4 bytes per pixel, ordered RGBARGBA..., use it as texture, draw it, ...\r\n}\r\n\r\n10.2. decoder C example\r\n-----------------------\r\n\r\n#include \"lodepng.h\"\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n  unsigned error;\r\n  unsigned char* image;\r\n  size_t width, height;\r\n  const char* filename = argc > 1 ? argv[1] : \"test.png\";\r\n\r\n  error = lodepng_decode32_file(&image, &width, &height, filename);\r\n\r\n  if(error) printf(\"decoder error %u: %s\\n\", error, lodepng_error_text(error));\r\n\r\n  / * use image here * /\r\n\r\n  free(image);\r\n  return 0;\r\n}\r\n\r\n11. state settings reference\r\n----------------------------\r\n\r\nA quick reference of some settings to set on the LodePNGState\r\n\r\nFor decoding:\r\n\r\nstate.decoder.zlibsettings.ignore_adler32: ignore ADLER32 checksums\r\nstate.decoder.zlibsettings.custom_...: use custom inflate function\r\nstate.decoder.ignore_crc: ignore CRC checksums\r\nstate.decoder.color_convert: convert internal PNG color to chosen one\r\nstate.decoder.read_text_chunks: whether to read in text metadata chunks\r\nstate.decoder.remember_unknown_chunks: whether to read in unknown chunks\r\nstate.info_raw.colortype: desired color type for decoded image\r\nstate.info_raw.bitdepth: desired bit depth for decoded image\r\nstate.info_raw....: more color settings, see struct LodePNGColorMode\r\nstate.info_png....: no settings for decoder but ouput, see struct LodePNGInfo\r\n\r\nFor encoding:\r\n\r\nstate.encoder.zlibsettings.btype: disable compression by setting it to 0\r\nstate.encoder.zlibsettings.use_lz77: use LZ77 in compression\r\nstate.encoder.zlibsettings.windowsize: tweak LZ77 windowsize\r\nstate.encoder.zlibsettings.minmatch: tweak min LZ77 length to match\r\nstate.encoder.zlibsettings.nicematch: tweak LZ77 match where to stop searching\r\nstate.encoder.zlibsettings.lazymatching: try one more LZ77 matching\r\nstate.encoder.zlibsettings.custom_...: use custom deflate function\r\nstate.encoder.auto_convert: choose optimal PNG color type, if 0 uses info_png\r\nstate.encoder.filter_palette_zero: PNG filter strategy for palette\r\nstate.encoder.filter_strategy: PNG filter strategy to encode with\r\nstate.encoder.force_palette: add palette even if not encoding to one\r\nstate.encoder.add_id: add LodePNG identifier and version as a text chunk\r\nstate.encoder.text_compression: use compressed text chunks for metadata\r\nstate.info_raw.colortype: color type of raw input image you provide\r\nstate.info_raw.bitdepth: bit depth of raw input image you provide\r\nstate.info_raw: more color settings, see struct LodePNGColorMode\r\nstate.info_png.color.colortype: desired color type if auto_convert is false\r\nstate.info_png.color.bitdepth: desired bit depth if auto_convert is false\r\nstate.info_png.color....: more color settings, see struct LodePNGColorMode\r\nstate.info_png....: more PNG related settings, see struct LodePNGInfo\r\n\r\n\r\n12. changes\r\n-----------\r\n\r\nThe version number of LodePNG is the date of the change given in the format\r\nyyyymmdd.\r\n\r\nSome changes aren't backwards compatible. Those are indicated with a (!)\r\nsymbol.\r\n\r\n*) 27 nov 2016: grey+alpha auto color model detection bugfix\r\n*) 18 apr 2016: Changed qsort to custom stable sort (for platforms w/o qsort).\r\n*) 09 apr 2016: Fixed colorkey usage detection, and better file loading (within\r\n   the limits of pure C90).\r\n*) 08 dec 2015: Made load_file function return error if file can't be opened.\r\n*) 24 okt 2015: Bugfix with decoding to palette output.\r\n*) 18 apr 2015: Boundary PM instead of just package-merge for faster encoding.\r\n*) 23 aug 2014: Reduced needless memory usage of decoder.\r\n*) 28 jun 2014: Removed fix_png setting, always support palette OOB for\r\n    simplicity. Made ColorProfile public.\r\n*) 09 jun 2014: Faster encoder by fixing hash bug and more zeros optimization.\r\n*) 22 dec 2013: Power of two windowsize required for optimization.\r\n*) 15 apr 2013: Fixed bug with LAC_ALPHA and color key.\r\n*) 25 mar 2013: Added an optional feature to ignore some PNG errors (fix_png).\r\n*) 11 mar 2013 (!): Bugfix with custom free. Changed from \"my\" to \"lodepng_\"\r\n    prefix for the custom allocators and made it possible with a new #define to\r\n    use custom ones in your project without needing to change lodepng's code.\r\n*) 28 jan 2013: Bugfix with color key.\r\n*) 27 okt 2012: Tweaks in text chunk keyword length error handling.\r\n*) 8 okt 2012 (!): Added new filter strategy (entropy) and new auto color mode.\r\n    (no palette). Better deflate tree encoding. New compression tweak settings.\r\n    Faster color conversions while decoding. Some internal cleanups.\r\n*) 23 sep 2012: Reduced warnings in Visual Studio a little bit.\r\n*) 1 sep 2012 (!): Removed #define's for giving custom (de)compression functions\r\n    and made it work with function pointers instead.\r\n*) 23 jun 2012: Added more filter strategies. Made it easier to use custom alloc\r\n    and free functions and toggle #defines from compiler flags. Small fixes.\r\n*) 6 may 2012 (!): Made plugging in custom zlib/deflate functions more flexible.\r\n*) 22 apr 2012 (!): Made interface more consistent, renaming a lot. Removed\r\n    redundant C++ codec classes. Reduced amount of structs. Everything changed,\r\n    but it is cleaner now imho and functionality remains the same. Also fixed\r\n    several bugs and shrunk the implementation code. Made new samples.\r\n*) 6 nov 2011 (!): By default, the encoder now automatically chooses the best\r\n    PNG color model and bit depth, based on the amount and type of colors of the\r\n    raw image. For this, autoLeaveOutAlphaChannel replaced by auto_choose_color.\r\n*) 9 okt 2011: simpler hash chain implementation for the encoder.\r\n*) 8 sep 2011: lz77 encoder lazy matching instead of greedy matching.\r\n*) 23 aug 2011: tweaked the zlib compression parameters after benchmarking.\r\n    A bug with the PNG filtertype heuristic was fixed, so that it chooses much\r\n    better ones (it's quite significant). A setting to do an experimental, slow,\r\n    brute force search for PNG filter types is added.\r\n*) 17 aug 2011 (!): changed some C zlib related function names.\r\n*) 16 aug 2011: made the code less wide (max 120 characters per line).\r\n*) 17 apr 2011: code cleanup. Bugfixes. Convert low to 16-bit per sample colors.\r\n*) 21 feb 2011: fixed compiling for C90. Fixed compiling with sections disabled.\r\n*) 11 dec 2010: encoding is made faster, based on suggestion by Peter Eastman\r\n    to optimize long sequences of zeros.\r\n*) 13 nov 2010: added LodePNG_InfoColor_hasPaletteAlpha and\r\n    LodePNG_InfoColor_canHaveAlpha functions for convenience.\r\n*) 7 nov 2010: added LodePNG_error_text function to get error code description.\r\n*) 30 okt 2010: made decoding slightly faster\r\n*) 26 okt 2010: (!) changed some C function and struct names (more consistent).\r\n     Reorganized the documentation and the declaration order in the header.\r\n*) 08 aug 2010: only changed some comments and external samples.\r\n*) 05 jul 2010: fixed bug thanks to warnings in the new gcc version.\r\n*) 14 mar 2010: fixed bug where too much memory was allocated for char buffers.\r\n*) 02 sep 2008: fixed bug where it could create empty tree that linux apps could\r\n    read by ignoring the problem but windows apps couldn't.\r\n*) 06 jun 2008: added more error checks for out of memory cases.\r\n*) 26 apr 2008: added a few more checks here and there to ensure more safety.\r\n*) 06 mar 2008: crash with encoding of strings fixed\r\n*) 02 feb 2008: support for international text chunks added (iTXt)\r\n*) 23 jan 2008: small cleanups, and #defines to divide code in sections\r\n*) 20 jan 2008: support for unknown chunks allowing using LodePNG for an editor.\r\n*) 18 jan 2008: support for tIME and pHYs chunks added to encoder and decoder.\r\n*) 17 jan 2008: ability to encode and decode compressed zTXt chunks added\r\n    Also various fixes, such as in the deflate and the padding bits code.\r\n*) 13 jan 2008: Added ability to encode Adam7-interlaced images. Improved\r\n    filtering code of encoder.\r\n*) 07 jan 2008: (!) changed LodePNG to use ISO C90 instead of C++. A\r\n    C++ wrapper around this provides an interface almost identical to before.\r\n    Having LodePNG be pure ISO C90 makes it more portable. The C and C++ code\r\n    are together in these files but it works both for C and C++ compilers.\r\n*) 29 dec 2007: (!) changed most integer types to unsigned int + other tweaks\r\n*) 30 aug 2007: bug fixed which makes this Borland C++ compatible\r\n*) 09 aug 2007: some VS2005 warnings removed again\r\n*) 21 jul 2007: deflate code placed in new namespace separate from zlib code\r\n*) 08 jun 2007: fixed bug with 2- and 4-bit color, and small interlaced images\r\n*) 04 jun 2007: improved support for Visual Studio 2005: crash with accessing\r\n    invalid std::vector element [0] fixed, and level 3 and 4 warnings removed\r\n*) 02 jun 2007: made the encoder add a tag with version by default\r\n*) 27 may 2007: zlib and png code separated (but still in the same file),\r\n    simple encoder/decoder functions added for more simple usage cases\r\n*) 19 may 2007: minor fixes, some code cleaning, new error added (error 69),\r\n    moved some examples from here to lodepng_examples.cpp\r\n*) 12 may 2007: palette decoding bug fixed\r\n*) 24 apr 2007: changed the license from BSD to the zlib license\r\n*) 11 mar 2007: very simple addition: ability to encode bKGD chunks.\r\n*) 04 mar 2007: (!) tEXt chunk related fixes, and support for encoding\r\n    palettized PNG images. Plus little interface change with palette and texts.\r\n*) 03 mar 2007: Made it encode dynamic Huffman shorter with repeat codes.\r\n    Fixed a bug where the end code of a block had length 0 in the Huffman tree.\r\n*) 26 feb 2007: Huffman compression with dynamic trees (BTYPE 2) now implemented\r\n    and supported by the encoder, resulting in smaller PNGs at the output.\r\n*) 27 jan 2007: Made the Adler-32 test faster so that a timewaste is gone.\r\n*) 24 jan 2007: gave encoder an error interface. Added color conversion from any\r\n    greyscale type to 8-bit greyscale with or without alpha.\r\n*) 21 jan 2007: (!) Totally changed the interface. It allows more color types\r\n    to convert to and is more uniform. See the manual for how it works now.\r\n*) 07 jan 2007: Some cleanup & fixes, and a few changes over the last days:\r\n    encode/decode custom tEXt chunks, separate classes for zlib & deflate, and\r\n    at last made the decoder give errors for incorrect Adler32 or Crc.\r\n*) 01 jan 2007: Fixed bug with encoding PNGs with less than 8 bits per channel.\r\n*) 29 dec 2006: Added support for encoding images without alpha channel, and\r\n    cleaned out code as well as making certain parts faster.\r\n*) 28 dec 2006: Added \"Settings\" to the encoder.\r\n*) 26 dec 2006: The encoder now does LZ77 encoding and produces much smaller files now.\r\n    Removed some code duplication in the decoder. Fixed little bug in an example.\r\n*) 09 dec 2006: (!) Placed output parameters of public functions as first parameter.\r\n    Fixed a bug of the decoder with 16-bit per color.\r\n*) 15 okt 2006: Changed documentation structure\r\n*) 09 okt 2006: Encoder class added. It encodes a valid PNG image from the\r\n    given image buffer, however for now it's not compressed.\r\n*) 08 sep 2006: (!) Changed to interface with a Decoder class\r\n*) 30 jul 2006: (!) LodePNG_InfoPng , width and height are now retrieved in different\r\n    way. Renamed decodePNG to decodePNGGeneric.\r\n*) 29 jul 2006: (!) Changed the interface: image info is now returned as a\r\n    struct of type LodePNG::LodePNG_Info, instead of a vector, which was a bit clumsy.\r\n*) 28 jul 2006: Cleaned the code and added new error checks.\r\n    Corrected terminology \"deflate\" into \"inflate\".\r\n*) 23 jun 2006: Added SDL example in the documentation in the header, this\r\n    example allows easy debugging by displaying the PNG and its transparency.\r\n*) 22 jun 2006: (!) Changed way to obtain error value. Added\r\n    loadFile function for convenience. Made decodePNG32 faster.\r\n*) 21 jun 2006: (!) Changed type of info vector to unsigned.\r\n    Changed position of palette in info vector. Fixed an important bug that\r\n    happened on PNGs with an uncompressed block.\r\n*) 16 jun 2006: Internally changed unsigned into unsigned where\r\n    needed, and performed some optimizations.\r\n*) 07 jun 2006: (!) Renamed functions to decodePNG and placed them\r\n    in LodePNG namespace. Changed the order of the parameters. Rewrote the\r\n    documentation in the header. Renamed files to lodepng.cpp and lodepng.h\r\n*) 22 apr 2006: Optimized and improved some code\r\n*) 07 sep 2005: (!) Changed to std::vector interface\r\n*) 12 aug 2005: Initial release (C++, decoder only)\r\n\r\n\r\n13. contact information\r\n-----------------------\r\n\r\nFeel free to contact me with suggestions, problems, comments, ... concerning\r\nLodePNG. If you encounter a PNG image that doesn't work properly with this\r\ndecoder, feel free to send it and I'll use it to find and fix the problem.\r\n\r\nMy email address is (puzzle the account and domain together with an @ symbol):\r\nDomain: gmail dot com.\r\nAccount: lode dot vandevenne.\r\n\r\n\r\nCopyright (c) 2005-2016 Lode Vandevenne\r\n*/\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <exception>\r\n#include <memory>\r\n#include <string>\r\n#include <string.h>\r\n//#include \"png.h\"\r\n#include \"guetzli/jpeg_data.h\"\r\n#include \"guetzli/jpeg_data_reader.h\"\r\n#include \"guetzli/processor.cc\"\r\n#include \"guetzli/quality.cc\"\r\n#include \"guetzli/stats.h\"\r\n#include \"butteraugli/butteraugli.cc\"\r\n#include \"lodepng/lodepng.cpp\"\r\n\r\n#define LODEPNG_NO_COMPILE_ENCODER\r\n\r\nnamespace {\r\n\r\nconstexpr int kDefaultJPEGQuality = 95;\r\n\r\n// An upper estimate of memory usage of Guetzli. The bound is\r\n// max(kLowerMemusaeMB * 1<<20, pixel_count * kBytesPerPixel)\r\nconstexpr int kBytesPerPixel = 300;\r\nconstexpr int kLowestMemusageMB = 100; // in MB\r\n\r\nconstexpr int kDefaultMemlimitMB = 6000; // in MB\r\n\r\ninline uint8_t BlendOnBlack(const uint8_t val, const uint8_t alpha) {\r\n  return (static_cast<int>(val) * static_cast<int>(alpha) + 128) / 255;\r\n}\r\n/*\r\nbool ReadPNG(FILE* f, int* xsize, int* ysize,\r\n             std::vector<uint8_t>* rgb) {\r\n  png_structp png_ptr =\r\n      png_create_read_struct(PNG_LIBPNG_VER_STRING, nullptr, nullptr, nullptr);\r\n  if (!png_ptr) {\r\n    return false;\r\n  }\r\n\r\n  png_infop info_ptr = png_create_info_struct(png_ptr);\r\n  if (!info_ptr) {\r\n    png_destroy_read_struct(&png_ptr, nullptr, nullptr);\r\n    return false;\r\n  }\r\n\r\n  if (setjmp(png_jmpbuf(png_ptr)) != 0) {\r\n    // Ok we are here because of the setjmp.\r\n    png_destroy_read_struct(&png_ptr, &info_ptr, nullptr);\r\n    return false;\r\n  }\r\n\r\n  rewind(f);\r\n  png_init_io(png_ptr, f);\r\n\r\n  // The png_transforms flags are as follows:\r\n  // packing == convert 1,2,4 bit images,\r\n  // strip == 16 -> 8 bits / channel,\r\n  // shift == use sBIT dynamics, and\r\n  // expand == palettes -> rgb, grayscale -> 8 bit images, tRNS -> alpha.\r\n  const unsigned int png_transforms =\r\n      PNG_TRANSFORM_PACKING | PNG_TRANSFORM_EXPAND | PNG_TRANSFORM_STRIP_16;\r\n\r\n  png_read_png(png_ptr, info_ptr, png_transforms, nullptr);\r\n\r\n  png_bytep* row_pointers = png_get_rows(png_ptr, info_ptr);\r\n\r\n  *xsize = png_get_image_width(png_ptr, info_ptr);\r\n  *ysize = png_get_image_height(png_ptr, info_ptr);\r\n  rgb->resize(3 * (*xsize) * (*ysize));\r\n\r\n  const int components = png_get_channels(png_ptr, info_ptr);\r\n  switch (components) {\r\n    case 1: {\r\n      // GRAYSCALE\r\n      for (int y = 0; y < *ysize; ++y) {\r\n        const uint8_t* row_in = row_pointers[y];\r\n        uint8_t* row_out = &(*rgb)[3 * y * (*xsize)];\r\n        for (int x = 0; x < *xsize; ++x) {\r\n          const uint8_t gray = row_in[x];\r\n          row_out[3 * x + 0] = gray;\r\n          row_out[3 * x + 1] = gray;\r\n          row_out[3 * x + 2] = gray;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case 2: {\r\n      // GRAYSCALE + ALPHA\r\n      for (int y = 0; y < *ysize; ++y) {\r\n        const uint8_t* row_in = row_pointers[y];\r\n        uint8_t* row_out = &(*rgb)[3 * y * (*xsize)];\r\n        for (int x = 0; x < *xsize; ++x) {\r\n          const uint8_t gray = BlendOnBlack(row_in[2 * x], row_in[2 * x + 1]);\r\n          row_out[3 * x + 0] = gray;\r\n          row_out[3 * x + 1] = gray;\r\n          row_out[3 * x + 2] = gray;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case 3: {\r\n      // RGB\r\n      for (int y = 0; y < *ysize; ++y) {\r\n        const uint8_t* row_in = row_pointers[y];\r\n        uint8_t* row_out = &(*rgb)[3 * y * (*xsize)];\r\n        memcpy(row_out, row_in, 3 * (*xsize));\r\n      }\r\n      break;\r\n    }\r\n    case 4: {\r\n      // RGBA\r\n      for (int y = 0; y < *ysize; ++y) {\r\n        const uint8_t* row_in = row_pointers[y];\r\n        uint8_t* row_out = &(*rgb)[3 * y * (*xsize)];\r\n        for (int x = 0; x < *xsize; ++x) {\r\n          const uint8_t alpha = row_in[4 * x + 3];\r\n          row_out[3 * x + 0] = BlendOnBlack(row_in[4 * x + 0], alpha);\r\n          row_out[3 * x + 1] = BlendOnBlack(row_in[4 * x + 1], alpha);\r\n          row_out[3 * x + 2] = BlendOnBlack(row_in[4 * x + 2], alpha);\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n      png_destroy_read_struct(&png_ptr, &info_ptr, nullptr);\r\n      return false;\r\n  }\r\n  png_destroy_read_struct(&png_ptr, &info_ptr, nullptr);\r\n  return true;\r\n}\r\n*/\r\nstd::string ReadFileOrDie(FILE* f) {\r\n  if (fseek(f, 0, SEEK_END) != 0) {\r\n    perror(\"fseek\");\r\n    exit(1);\r\n  }\r\n  off_t size = ftell(f);\r\n  if (size < 0) {\r\n    perror(\"ftell\");\r\n    exit(1);\r\n  }\r\n  if (fseek(f, 0, SEEK_SET) != 0) {\r\n    perror(\"fseek\");\r\n    exit(1);\r\n  }\r\n  std::unique_ptr<char[]> buf(new char[size]);\r\n  if (fread(buf.get(), 1, size, f) != (size_t)size) {\r\n    perror(\"fread\");\r\n    exit(1);\r\n  }\r\n  std::string result(buf.get(), size);\r\n  return result;\r\n}\r\n\r\nvoid WriteFileOrDie(FILE* f, const std::string& contents) {\r\n  if (fwrite(contents.data(), 1, contents.size(), f) != contents.size()) {\r\n    perror(\"fwrite\");\r\n    exit(1);\r\n  }\r\n  if (fclose(f) < 0) {\r\n    perror(\"fclose\");\r\n    exit(1);\r\n  }\r\n}\r\n\r\nvoid TerminateHandler() {\r\n  fprintf(stderr, \"Unhandled exception. Most likely insufficient memory available.\\n\"\r\n          \"Make sure that there is 300MB/MPix of memory available.\\n\");\r\n  exit(1);\r\n}\r\n\r\nvoid Usage() {\r\n  fprintf(stderr,\r\n      \"Guetzli JPEG compressor. Usage: \\n\"\r\n      \"guetzli [flags] input_filename output_filename\\n\"\r\n      \"\\n\"\r\n      \"Flags:\\n\"\r\n      \"  --verbose    - Print a verbose trace of all attempts to standard output.\\n\"\r\n      \"  --quality Q  - Visual quality to aim for, expressed as a JPEG quality value.\\n\"\r\n      \"                 Default value is %d.\\n\"\r\n      \"  --memlimit M - Memory limit in MB. Guetzli will fail if unable to stay under\\n\"\r\n      \"                 the limit. Default limit is %d MB.\\n\"\r\n      \"  --nomemlimit - Do not limit memory usage.\\n\", kDefaultJPEGQuality, kDefaultMemlimitMB);\r\n  exit(1);\r\n}\r\n\r\n}  // namespace\r\n\r\nint main(int argc, char** argv) {\r\n  std::set_terminate(TerminateHandler);\r\n\r\n  int verbose = 0;\r\n  int quality = kDefaultJPEGQuality;\r\n  int memlimit_mb = kDefaultMemlimitMB;\r\n\r\n  int opt_idx = 1;\r\n  for(;opt_idx < argc;opt_idx++) {\r\n    if (argv[opt_idx][0] != '-')\r\n      break;\r\n    if (!strcmp(argv[opt_idx], \"--verbose\")) {\r\n      verbose = 1;\r\n    } else if (!strcmp(argv[opt_idx], \"--quality\")) {\r\n      opt_idx++;\r\n      quality = atoi(argv[opt_idx]);\r\n    } else if (!strcmp(argv[opt_idx], \"--memlimit\")) {\r\n      opt_idx++;\r\n      memlimit_mb = atoi(argv[opt_idx]);\r\n    } else if (!strcmp(argv[opt_idx], \"--nomemlimit\")) {\r\n      memlimit_mb = -1;\r\n    } else {\r\n      fprintf(stderr, \"Unknown commandline flag: %s\\n\", argv[opt_idx]);\r\n      Usage();\r\n    }\r\n  }\r\n\r\n  if (argc - opt_idx != 2) {\r\n    Usage();\r\n  }\r\n\r\n  FILE* fin = fopen(argv[opt_idx], \"rb\");\r\n  if (!fin) {\r\n    fprintf(stderr, \"Can't open input file\\n\");\r\n    return 1;\r\n  }\r\n\r\n  std::string in_data = ReadFileOrDie(fin);\r\n  std::string out_data;\r\n\r\n  guetzli::Params params;\r\n  params.butteraugli_target =\r\n      guetzli::ButteraugliScoreForQuality(quality);\r\n\r\n  guetzli::ProcessStats stats;\r\n\r\n  if (verbose) {\r\n    stats.debug_output_file = stdout;\r\n  }\r\n\r\n  static const unsigned char kPNGMagicBytes[] = {\r\n      0x89, 'P', 'N', 'G', '\\r', '\\n', 0x1a, '\\n',\r\n  };\r\n  if (in_data.size() >= 8 &&\r\n      memcmp(in_data.data(), kPNGMagicBytes, sizeof(kPNGMagicBytes)) == 0) {\r\n    unsigned xsize, ysize;\r\n    std::vector<uint8_t> rgb;\r\n\tif (lodepng::decode(rgb, xsize, ysize, argv[opt_idx], LCT_RGB, 8)) { /*!ReadPNG(fin, &xsize, &ysize, &rgb)*/\r\n      fprintf(stderr, \"Error reading PNG data from input file\\n\");\r\n      return 1;\r\n    }\r\n    int pixels = xsize * ysize;\r\n    if (memlimit_mb != -1\r\n        && (pixels * kBytesPerPixel / (1 << 20) > memlimit_mb\r\n            || memlimit_mb < kLowestMemusageMB)) {\r\n      fprintf(stderr, \"Memory limit would be exceeded. Failing.\\n\");\r\n      return 1;\r\n    }\r\n    if (!guetzli::Process(params, &stats, rgb, xsize, ysize, &out_data)) {\r\n      fprintf(stderr, \"Guetzli processing failed\\n\");\r\n      return 1;\r\n    }\r\n  } else {\r\n    guetzli::JPEGData jpg_header;\r\n    if (!guetzli::ReadJpeg(in_data, guetzli::JPEG_READ_HEADER, &jpg_header)) {\r\n      fprintf(stderr, \"Error reading JPG data from input file\\n\");\r\n      return 1;\r\n    }\r\n    int pixels = jpg_header.width * jpg_header.height;\r\n    if (memlimit_mb != -1\r\n        && (pixels * kBytesPerPixel / (1 << 20) > memlimit_mb\r\n            || memlimit_mb < kLowestMemusageMB)) {\r\n      fprintf(stderr, \"Memory limit would be exceeded. Failing.\\n\");\r\n      return 1;\r\n    }\r\n    if (!guetzli::Process(params, &stats, in_data, &out_data)) {\r\n      fprintf(stderr, \"Guetzli processing failed\\n\");\r\n      return 1;\r\n    }\r\n  }\r\n\r\n  fclose(fin);\r\n\r\n  FILE* fout = fopen(argv[opt_idx + 1], \"wb\");\r\n  if (!fout) {\r\n    fprintf(stderr, \"Can't open output file for writing\\n\");\r\n    return 1;\r\n  }\r\n\r\n  WriteFileOrDie(fout, out_data);\r\n  return 0;\r\n}\r\n\r\n\r\nextern \"C\" {\r\nint Guetzli_encodeRGBA(const char* rgba, unsigned int xsize, unsigned int ysize, unsigned int quality, int verbose) {\r\n\t//int verbose = 1;\r\n\t//int quality = kDefaultJPEGQuality;\r\n\tint memlimit_mb = kDefaultMemlimitMB;\r\n\r\n\t//std::string in_data;// = ReadFileOrDie(fin);\r\n\tstd::string out_data;\r\n\r\n\tguetzli::Params params;\r\n\tparams.butteraugli_target =\r\n\t\tguetzli::ButteraugliScoreForQuality(quality);//FLAGS_quality\r\n\r\n\tguetzli::ProcessStats stats;\r\n\r\n\tif (verbose) {\r\n\t\tstats.debug_output_file = stdout;\r\n\t}\r\n\r\n\t//int xsize, ysize;\r\n\tstd::vector<uint8_t> rgb;\r\n\trgb.resize(3 * (xsize) * (ysize));\r\n\tfor (int y = 0; y < ysize; ++y) {\r\n\t\tconst uint8_t* row_in = (uint8_t*)rgba + 4 * xsize * y;\r\n\t\tuint8_t* row_out = &(rgb)[3 * y * (xsize)];\r\n\t\tfor (int x = 0; x < xsize; ++x) {\r\n\t\t\tconst uint8_t alpha = row_in[4 * x + 3];\r\n\t\t\trow_out[3 * x + 0] = BlendOnBlack(row_in[4 * x + 0], alpha);\r\n\t\t\trow_out[3 * x + 1] = BlendOnBlack(row_in[4 * x + 1], alpha);\r\n\t\t\trow_out[3 * x + 2] = BlendOnBlack(row_in[4 * x + 2], alpha);\r\n\t\t}\r\n\t}\r\n\tint size = rgb.size();\r\n\tint pixels = xsize * ysize;\r\n\tif (memlimit_mb != -1\r\n\t\t&& (pixels * kBytesPerPixel / (1 << 20) > memlimit_mb\r\n\t\t\t|| memlimit_mb < kLowestMemusageMB)) {\r\n\t\tfprintf(stderr, \"Memory limit would be exceeded. Failing.\\n\");\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tif (!Process(params, &stats, rgb, xsize, ysize, &out_data)) {\r\n      fprintf(stderr, \"Guetzli processing failed\\n\");\r\n      return 1;\r\n    }\r\n\tFILE* fout = fopen(\"out.jpg\", \"wb\");\r\n\tif (!fout) {\r\n\t\tfprintf(stderr, \"Can't open output file for writing\\n\");\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tWriteFileOrDie(fout, out_data);\r\n\treturn 0;\r\n\tsize = out_data.size();\r\n\t//*out = out_data.c_str();\r\n\t//return size;// 1;\r\n}\r\nint Guetzli_encode(unsigned int quality, int verbose) {\r\n\t//int verbose = 1;\r\n\t//int quality = kDefaultJPEGQuality;\r\n\tint memlimit_mb = kDefaultMemlimitMB;\r\n\r\n\tFILE* fin = fopen(\"in.ext\", \"rb\");\r\n\tif (!fin) {\r\n\t\tfprintf(stderr, \"Can't open input file\\n\");\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tstd::string in_data = ReadFileOrDie(fin);\r\n\tstd::string out_data;\r\n\r\n\tguetzli::Params params;\r\n\tparams.butteraugli_target =\r\n\t\tguetzli::ButteraugliScoreForQuality(quality);\r\n\r\n\tguetzli::ProcessStats stats;\r\n\r\n\tif (verbose) {\r\n\t\tstats.debug_output_file = stdout;\r\n\t}\r\n\r\n\tstatic const unsigned char kPNGMagicBytes[] = {\r\n\t\t0x89, 'P', 'N', 'G', '\\r', '\\n', 0x1a, '\\n',\r\n\t};\r\n\tif (in_data.size() >= 8 &&\r\n\t\tmemcmp(in_data.data(), kPNGMagicBytes, sizeof(kPNGMagicBytes)) == 0) {\r\n\t\tunsigned xsize, ysize;\r\n\t\tstd::vector<uint8_t> rgb;\r\n\t\tif (lodepng::decode(rgb, xsize, ysize, \"in.ext\", LCT_RGB, 8)) { /*!ReadPNG(fin, &xsize, &ysize, &rgb)*/\r\n\t\t\tfprintf(stderr, \"Error reading PNG data from input file\\n\");\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tint pixels = xsize * ysize;\r\n\t\tif (memlimit_mb != -1\r\n\t\t\t&& (pixels * kBytesPerPixel / (1 << 20) > memlimit_mb\r\n\t\t\t\t|| memlimit_mb < kLowestMemusageMB)) {\r\n\t\t\tfprintf(stderr, \"Memory limit would be exceeded. Failing.\\n\");\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (!guetzli::Process(params, &stats, rgb, xsize, ysize, &out_data)) {\r\n\t\t\tfprintf(stderr, \"Guetzli processing failed\\n\");\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tguetzli::JPEGData jpg_header;\r\n\t\tif (!guetzli::ReadJpeg(in_data, guetzli::JPEG_READ_HEADER, &jpg_header)) {\r\n\t\t\tfprintf(stderr, \"Error reading JPG data from input file\\n\");\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tint pixels = jpg_header.width * jpg_header.height;\r\n\t\tif (memlimit_mb != -1\r\n\t\t\t&& (pixels * kBytesPerPixel / (1 << 20) > memlimit_mb\r\n\t\t\t\t|| memlimit_mb < kLowestMemusageMB)) {\r\n\t\t\tfprintf(stderr, \"Memory limit would be exceeded. Failing.\\n\");\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (!guetzli::Process(params, &stats, in_data, &out_data)) {\r\n\t\t\tfprintf(stderr, \"Guetzli processing failed\\n\");\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\r\n\tfclose(fin);\r\n\r\n\tFILE* fout = fopen(\"out.jpg\", \"wb\");\r\n\tif (!fout) {\r\n\t\tfprintf(stderr, \"Can't open output file for writing\\n\");\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tWriteFileOrDie(fout, out_data);\r\n\treturn 0;\r\n\r\n}\r\n}\r\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#ifndef GUETZLI_BUTTERAUGLI_COMPARATOR_H_\r\n#define GUETZLI_BUTTERAUGLI_COMPARATOR_H_\r\n\r\n#include <vector>\r\n\r\n#include \"butteraugli/butteraugli.h\"\r\n#include \"guetzli/comparator.h\"\r\n#include \"guetzli/jpeg_data.h\"\r\n#include \"guetzli/output_image.h\"\r\n#include \"guetzli/stats.h\"\r\n\r\nnamespace guetzli {\r\n\r\nconstexpr int kButteraugliStep = 3;\r\n\r\nclass ButteraugliComparator : public Comparator {\r\n public:\r\n  ButteraugliComparator(const int width, const int height,\r\n                        const std::vector<uint8_t>& rgb,\r\n                        const float target_distance, ProcessStats* stats);\r\n\r\n  void Compare(const OutputImage& img) override;\r\n\r\n  double CompareBlock(const OutputImage& img,\r\n                      int block_x, int block_y) const override;\r\n\r\n  double ScoreOutputSize(int size) const override;\r\n\r\n  bool DistanceOK(double target_mul) const override {\r\n    return distance_ <= target_mul * target_distance_;\r\n  }\r\n\r\n  const std::vector<float> distmap() const override { return distmap_; }\r\n  float distmap_aggregate() const override { return distance_; }\r\n\r\n  float BlockErrorLimit() const override;\r\n\r\n  void ComputeBlockErrorAdjustmentWeights(\r\n      int direction, int max_block_dist, double target_mul, int factor_x,\r\n      int factor_y, const std::vector<float>& distmap,\r\n      std::vector<float>* block_weight) override;\r\n\r\n private:\r\n  const int width_;\r\n  const int height_;\r\n  const float target_distance_;\r\n  std::vector<::butteraugli::ImageF> rgb_linear_pregamma_;\r\n  std::vector<std::vector<float>> mask_xyz_;\r\n  std::vector<std::vector<std::vector<float>>> per_block_pregamma_;\r\n  ::butteraugli::ButteraugliComparator comparator_;\r\n  float distance_;\r\n  std::vector<float> distmap_;\r\n  ProcessStats* stats_;\r\n};\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_BUTTERAUGLI_COMPARATOR_H_\r\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(__alloc_rr& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_allocator(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","/*\r\n * Copyright 2016 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n#ifndef GUETZLI_JPEG_BIT_WRITER_H_\r\n#define GUETZLI_JPEG_BIT_WRITER_H_\r\n\r\n#include <stdint.h>\r\n#include <memory>\r\n\r\nnamespace guetzli {\r\n\r\n// Returns non-zero if and only if x has a zero byte, i.e. one of\r\n// x & 0xff, x & 0xff00, ..., x & 0xff00000000000000 is zero.\r\ninline uint64_t HasZeroByte(uint64_t x) {\r\n  return (x - 0x0101010101010101ULL) & ~x & 0x8080808080808080ULL;\r\n}\r\n\r\n// Handles the packing of bits into output bytes.\r\nstruct BitWriter {\r\n  explicit BitWriter(size_t length) : len(length),\r\n                                      data(new uint8_t[len]),\r\n                                      pos(0),\r\n                                      put_buffer(0),\r\n                                      put_bits(64),\r\n                                      overflow(false) {}\r\n\r\n  void WriteBits(int nbits, uint64_t bits) {\r\n    put_bits -= nbits;\r\n    put_buffer |= (bits << put_bits);\r\n    if (put_bits <= 16) {\r\n      // At this point we are ready to emit the most significant 6 bytes of\r\n      // put_buffer_ to the output.\r\n      // The JPEG format requires that after every 0xff byte in the entropy\r\n      // coded section, there is a zero byte, therefore we first check if any of\r\n      // the 6 most significant bytes of put_buffer_ is 0xff.\r\n      if (HasZeroByte(~put_buffer | 0xffff)) {\r\n        // We have a 0xff byte somewhere, examine each byte and append a zero\r\n        // byte if necessary.\r\n        EmitByte((put_buffer >> 56) & 0xff);\r\n        EmitByte((put_buffer >> 48) & 0xff);\r\n        EmitByte((put_buffer >> 40) & 0xff);\r\n        EmitByte((put_buffer >> 32) & 0xff);\r\n        EmitByte((put_buffer >> 24) & 0xff);\r\n        EmitByte((put_buffer >> 16) & 0xff);\r\n      } else if (pos + 6 < len) {\r\n        // We don't have any 0xff bytes, output all 6 bytes without checking.\r\n        data[pos] = (put_buffer >> 56) & 0xff;\r\n        data[pos + 1] = (put_buffer >> 48) & 0xff;\r\n        data[pos + 2] = (put_buffer >> 40) & 0xff;\r\n        data[pos + 3] = (put_buffer >> 32) & 0xff;\r\n        data[pos + 4] = (put_buffer >> 24) & 0xff;\r\n        data[pos + 5] = (put_buffer >> 16) & 0xff;\r\n        pos += 6;\r\n      } else {\r\n        overflow = true;\r\n      }\r\n      put_buffer <<= 48;\r\n      put_bits += 48;\r\n    }\r\n  }\r\n\r\n  // Writes the given byte to the output, writes an extra zero if byte is 0xff.\r\n  void EmitByte(int byte) {\r\n    if (pos < len) {\r\n      data[pos++] = byte;\r\n    } else {\r\n      overflow = true;\r\n    }\r\n    if (byte == 0xff) {\r\n      EmitByte(0);\r\n    }\r\n  }\r\n\r\n  void JumpToByteBoundary() {\r\n    while (put_bits <= 56) {\r\n      int c = (put_buffer >> 56) & 0xff;\r\n      EmitByte(c);\r\n      put_buffer <<= 8;\r\n      put_bits += 8;\r\n    }\r\n    if (put_bits < 64) {\r\n      int padmask = 0xff >> (64 - put_bits);\r\n      int c = ((put_buffer >> 56) & ~padmask) | padmask;\r\n      EmitByte(c);\r\n    }\r\n    put_buffer = 0;\r\n    put_bits = 64;\r\n  }\r\n\r\n  size_t len;\r\n  std::unique_ptr<uint8_t[]> data;\r\n  int pos;\r\n  uint64_t put_buffer;\r\n  int put_bits;\r\n  bool overflow;\r\n};\r\n\r\n}  // namespace guetzli\r\n\r\n#endif  // GUETZLI_JPEG_BIT_WRITER_H_\r\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> constexpr add_const<T>_t& as_const(T& t) noexcept;      // C++17\ntemplate <class T>                      void as_const(const T&&) = delete; // C++17\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(is_nothrow_swappable_v<T1> &&\n                                is_nothrow_swappable_v<T2>);\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&\n    get(pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&\n    get(const pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&&\n    get(pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&&\n    get(const pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T2, T1>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T2, T1>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T> \n    T exchange(T& obj, U&& new_value);\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n#include <initializer_list>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, (void) ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\n// forward declared in <type_traits>\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp> constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }\ntemplate <class _Tp>                        void as_const(const _Tp&&) = delete;\n#endif\n\nstruct _LIBCPP_TYPE_VIS_ONLY piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TYPE_VIS_ONLY pair\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n    // pair(const pair&) = default;\n    // pair(pair&&) = default;\n\n#ifndef _LIBCPP_HAS_NO_DEFAULT_FUNCTION_TEMPLATE_ARGS\n    template <bool _Dummy = true, class = typename enable_if<\n        __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&\n        __dependent_type<is_default_constructible<_T2>, _Dummy>::value\n      >::type>\n#endif\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(const _T1& __x, const _T2& __y)\n        : first(__x), second(__y) {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(const pair<_U1, _U2>& __p\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n                 ,typename enable_if<is_convertible<const _U1&, _T1>::value &&\n                                    is_convertible<const _U2&, _T2>::value>::type* = 0\n#endif\n                                      )\n            : first(__p.first), second(__p.second) {}\n\n#if !defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && _LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p) = default;\n#elif !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) || !_LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__p.first),\n          second(__p.second)\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _U1, class _U2,\n              class = typename enable_if<is_convertible<_U1, first_type>::value &&\n                                         is_convertible<_U2, second_type>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_U1&& __u1, _U2&& __u2)\n            : first(_VSTD::forward<_U1>(__u1)),\n              second(_VSTD::forward<_U2>(__u2))\n            {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(pair<_U1, _U2>&& __p,\n                 typename enable_if<is_convertible<_U1, _T1>::value &&\n                                    is_convertible<_U2, _T2>::value>::type* = 0)\n            : first(_VSTD::forward<_U1>(__p.first)),\n              second(_VSTD::forward<_U2>(__p.second)) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) _NOEXCEPT_(is_nothrow_move_constructible<first_type>::value &&\n                                is_nothrow_move_constructible<second_type>::value)\n        : first(_VSTD::forward<first_type>(__p.first)),\n          second(_VSTD::forward<second_type>(__p.second))\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair&\n    operator=(pair&& __p) _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                                     is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class _Tuple,\n             class = typename enable_if<__tuple_convertible<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_Tuple&& __p)\n            : first(_VSTD::forward<typename tuple_element<0,\n                                  typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<0>(__p))),\n              second(_VSTD::forward<typename tuple_element<1,\n                                   typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<1>(__p)))\n            {}\n\n\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                    tuple<_Args2...> __second_args)\n            : pair(__pc, __first_args, __second_args,\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if<__tuple_assignable<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair&\n        operator=(_Tuple&& __p)\n        {\n            typedef typename __make_tuple_types<_Tuple>::type _TupleRef;\n            typedef typename tuple_element<0, _TupleRef>::type _U0;\n            typedef typename tuple_element<1, _TupleRef>::type _U1;\n            first  = _VSTD::forward<_U0>(_VSTD::get<0>(__p));\n            second = _VSTD::forward<_U1>(_VSTD::get<1>(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        using _VSTD::swap;\n        swap(first,  __p.first);\n        swap(second, __p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(const pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T1, _T2> const&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T2, _T1> const&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TYPE_VIS_ONLY integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\n#if __has_builtin(__make_integer_seq) && !defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    typedef __make_integer_seq<integer_sequence, _Tp, _Ep> type;\n};\n\n#else\n\nnamespace __detail {\n\ntemplate<typename _Tp, size_t ..._Extra> struct __repeat;\ntemplate<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<integer_sequence<_Tp, _Np...>, _Extra...> {\n  typedef integer_sequence<_Tp,\n                           _Np...,\n                           sizeof...(_Np) + _Np...,\n                           2 * sizeof...(_Np) + _Np...,\n                           3 * sizeof...(_Np) + _Np...,\n                           4 * sizeof...(_Np) + _Np...,\n                           5 * sizeof...(_Np) + _Np...,\n                           6 * sizeof...(_Np) + _Np...,\n                           7 * sizeof...(_Np) + _Np...,\n                           _Extra...> type;\n};\n\ntemplate<size_t _Np> struct __parity;\ntemplate<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};\n\ntemplate<> struct __make<0> { typedef integer_sequence<size_t> type; };\ntemplate<> struct __make<1> { typedef integer_sequence<size_t, 0> type; };\ntemplate<> struct __make<2> { typedef integer_sequence<size_t, 0, 1> type; };\ntemplate<> struct __make<3> { typedef integer_sequence<size_t, 0, 1, 2> type; };\ntemplate<> struct __make<4> { typedef integer_sequence<size_t, 0, 1, 2, 3> type; };\ntemplate<> struct __make<5> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4> type; };\ntemplate<> struct __make<6> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };\ntemplate<> struct __make<7> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };\n\ntemplate<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };\ntemplate<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };\ntemplate<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\n\ntemplate<typename _Tp, typename _Up> struct __convert {\n  template<typename> struct __result;\n  template<_Tp ..._Np> struct __result<integer_sequence<_Tp, _Np...> > { typedef integer_sequence<_Up, _Np...> type; };\n};\ntemplate<typename _Tp> struct __convert<_Tp, _Tp> { template<typename _Up> struct __result { typedef _Up type; }; };\n\n}\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__convert<size_t, _Tp>::template __result<typename __detail::__make<_Np>::type>::type;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence must have a non-negative sequence length\");\n    // Workaround GCC bug by preventing bad installations when 0 <= _Ep\n    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68929\n    typedef __make_integer_sequence_unchecked<_Tp, 0 <= _Ep ? _Ep : 0> type;\n};\n\n#endif\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = typename __make_integer_sequence<_Tp, _Np>::type;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n  \n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}    \n#endif  // _LIBCPP_STD_VER > 11\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","// -*- C++ -*-\n//===---------------------------- set -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SET\n#define _LIBCPP_SET\n\n/*\n\n    set synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass set\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    set()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit set(const value_compare& comp);\n    set(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last,\n            const value_compare& comp = value_compare());\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const value_compare& comp,\n            const allocator_type& a);\n    set(const set& s);\n    set(set&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit set(const allocator_type& a);\n    set(const set& s, const allocator_type& a);\n    set(set&& s, const allocator_type& a);\n    set(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    set(initializer_list<value_type> il, const value_compare& comp,\n        const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    set(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~set();\n\n    set& operator=(const set& s);\n    set& operator=(set&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    set& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator,bool> insert(const value_type& v);\n    pair<iterator,bool> insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(set& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(set<Key, Compare, Allocator>& x, set<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass multiset\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    multiset()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multiset(const value_compare& comp);\n    multiset(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp = value_compare());\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp, const allocator_type& a);\n    multiset(const multiset& s);\n    multiset(multiset&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multiset(const allocator_type& a);\n    multiset(const multiset& s, const allocator_type& a);\n    multiset(multiset&& s, const allocator_type& a);\n    multiset(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    multiset(initializer_list<value_type> il, const value_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    multiset(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~multiset();\n\n    multiset& operator=(const multiset& s);\n    multiset& operator=(multiset&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multiset& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    iterator insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position);  // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multiset& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(multiset<Key, Compare, Allocator>& x, multiset<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <functional>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TYPE_VIS_ONLY set\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                 key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    set()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(value_compare()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l,\n            const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l, const value_compare& __comp,\n            const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY \n        set(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : set(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s)\n        : __tree_(__s.__tree_)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(const set& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    set(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const allocator_type& __a)\n        : __tree_(__a) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    set(set&& __s, const allocator_type& __a);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    set(initializer_list<value_type> __il, const allocator_type& __a)\n        : set(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> emplace(_Args&&... __args)\n            {return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_unique(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(const value_type& __v)\n        {return __tree_.__insert_unique(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(value_type&& __v)\n        {return __tree_.__insert_unique(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_unique(__p, __v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_unique(__p, _VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_unique(__e, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(set& __s) _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                  {return __tree_.__count_unique(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\nset<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\n// specialized algorithms:\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(set<_Key, _Compare, _Allocator>& __x,\n     set<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TYPE_VIS_ONLY multiset\n{\npublic:\n    // types:\n    typedef _Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                                allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    multiset()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(value_compare()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY \n        multiset(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : multiset(__f, __l, key_compare(), __a) {}\n#endif\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s)\n        : __tree_(__s.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc()))\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(const multiset& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const allocator_type& __a)\n        : __tree_(__a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    multiset(multiset&& __s, const allocator_type& __a);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multiset(initializer_list<value_type> __il, const allocator_type& __a)\n        : multiset(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace(_Args&&... __args)\n            {return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_multi(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v)\n        {return __tree_.__insert_multi(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_multi(__p, __v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multiset& __s)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                  {return __tree_.__count_multi(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\nmultiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multiset<_Key, _Compare, _Allocator>& __x,\n     multiset<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SET\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TREE\n#define _LIBCPP___TREE\n\n#include <__config>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Compare, class _Allocator> class __tree;\ntemplate <class _Tp, class _NodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_iterator;\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n\ntemplate <class _Pointer> class __tree_end_node;\ntemplate <class _VoidPtr> class __tree_node_base;\ntemplate <class _Tp, class _VoidPtr> class __tree_node;\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Value>\nunion __value_type;\n#else\ntemplate <class _Key, class _Value>\nstruct __value_type;\n#endif\n\ntemplate <class _Allocator> class __map_node_destructor;\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n\n/*\n\n_NodePtr algorithms\n\nThe algorithms taking _NodePtr are red black tree algorithms.  Those\nalgorithms taking a parameter named __root should assume that __root\npoints to a proper red black tree (unless otherwise specified).\n\nEach algorithm herein assumes that __root->__parent_ points to a non-null\nstructure which has a member __left_ which points back to __root.  No other\nmember is read or written to at __root->__parent_.\n\n__root->__parent_ will be referred to below (in comments only) as end_node.\nend_node->__left_ is an externably accessible lvalue for __root, and can be\nchanged by node insertion and removal (without explicit reference to end_node).\n\nAll nodes (with the exception of end_node), even the node referred to as\n__root, have a non-null __parent_ field.\n\n*/\n\n// Returns:  true if __x is a left child of its parent, else false\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__tree_is_left_child(_NodePtr __x) _NOEXCEPT\n{\n    return __x == __x->__parent_->__left_;\n}\n\n// Determintes if the subtree rooted at __x is a proper red black subtree.  If\n//    __x is a proper subtree, returns the black height (null counts as 1).  If\n//    __x is an improper subtree, returns 0.\ntemplate <class _NodePtr>\nunsigned\n__tree_sub_invariant(_NodePtr __x)\n{\n    if (__x == nullptr)\n        return 1;\n    // parent consistency checked by caller\n    // check __x->__left_ consistency\n    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)\n        return 0;\n    // check __x->__right_ consistency\n    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)\n        return 0;\n    // check __x->__left_ != __x->__right_ unless both are nullptr\n    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)\n        return 0;\n    // If this is red, neither child can be red\n    if (!__x->__is_black_)\n    {\n        if (__x->__left_ && !__x->__left_->__is_black_)\n            return 0;\n        if (__x->__right_ && !__x->__right_->__is_black_)\n            return 0;\n    }\n    unsigned __h = __tree_sub_invariant(__x->__left_);\n    if (__h == 0)\n        return 0;  // invalid left subtree\n    if (__h != __tree_sub_invariant(__x->__right_))\n        return 0;  // invalid or different height right subtree\n    return __h + __x->__is_black_;  // return black height of this node\n}\n\n// Determintes if the red black tree rooted at __root is a proper red black tree.\n//    __root == nullptr is a proper tree.  Returns true is __root is a proper\n//    red black tree, else returns false.\ntemplate <class _NodePtr>\nbool\n__tree_invariant(_NodePtr __root)\n{\n    if (__root == nullptr)\n        return true;\n    // check __x->__parent_ consistency\n    if (__root->__parent_ == nullptr)\n        return false;\n    if (!__tree_is_left_child(__root))\n        return false;\n    // root must be black\n    if (!__root->__is_black_)\n        return false;\n    // do normal node checks\n    return __tree_sub_invariant(__root) != 0;\n}\n\n// Returns:  pointer to the left-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_min(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__left_ != nullptr)\n        __x = __x->__left_;\n    return __x;\n}\n\n// Returns:  pointer to the right-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_max(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__right_ != nullptr)\n        __x = __x->__right_;\n    return __x;\n}\n\n// Returns:  pointer to the next in-order node after __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_next(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return __tree_min(__x->__right_);\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to the previous in-order node before __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_prev(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__left_ != nullptr)\n        return __tree_max(__x->__left_);\n    while (__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to a node which has no children\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_leaf(_NodePtr __x) _NOEXCEPT\n{\n    while (true)\n    {\n        if (__x->__left_ != nullptr)\n        {\n            __x = __x->__left_;\n            continue;\n        }\n        if (__x->__right_ != nullptr)\n        {\n            __x = __x->__right_;\n            continue;\n        }\n        break;\n    }\n    return __x;\n}\n\n// Effects:  Makes __x->__right_ the subtree root with __x as its left child\n//           while preserving in-order order.\n// Precondition:  __x->__right_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_left_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__right_;\n    __x->__right_ = __y->__left_;\n    if (__x->__right_ != nullptr)\n        __x->__right_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__left_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Makes __x->__left_ the subtree root with __x as its right child\n//           while preserving in-order order.\n// Precondition:  __x->__left_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_right_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__left_;\n    __x->__left_ = __y->__right_;\n    if (__x->__left_ != nullptr)\n        __x->__left_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__right_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Rebalances __root after attaching __x to a leaf.\n// Precondition:  __root != nulptr && __x != nullptr.\n//                __x has no children.\n//                __x == __root or == a direct or indirect child of __root.\n//                If __x were to be unlinked from __root (setting __root to\n//                  nullptr if __root == __x), __tree_invariant(__root) == true.\n// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT\n{\n    __x->__is_black_ = __x == __root;\n    while (__x != __root && !__x->__parent_->__is_black_)\n    {\n        // __x->__parent_ != __root because __x->__parent_->__is_black == false\n        if (__tree_is_left_child(__x->__parent_))\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__right_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (!__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_left_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_right_rotate(__x);\n                break;\n            }\n        }\n        else\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__left_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_right_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_left_rotate(__x);\n                break;\n            }\n        }\n    }\n}\n\n// Precondition:  __root != nullptr && __z != nullptr.\n//                __tree_invariant(__root) == true.\n//                __z == __root or == a direct or indirect child of __root.\n// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.\n// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_\n//                nor any of its children refer to __z.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT\n{\n    // __z will be removed from the tree.  Client still needs to destruct/deallocate it\n    // __y is either __z, or if __z has two children, __tree_next(__z).\n    // __y will have at most one child.\n    // __y will be the initial hole in the tree (make the hole at a leaf)\n    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?\n                    __z : __tree_next(__z);\n    // __x is __y's possibly null single child\n    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;\n    // __w is __x's possibly null uncle (will become __x's sibling)\n    _NodePtr __w = nullptr;\n    // link __x to __y's parent, and find __w\n    if (__x != nullptr)\n        __x->__parent_ = __y->__parent_;\n    if (__tree_is_left_child(__y))\n    {\n        __y->__parent_->__left_ = __x;\n        if (__y != __root)\n            __w = __y->__parent_->__right_;\n        else\n            __root = __x;  // __w == nullptr\n    }\n    else\n    {\n        __y->__parent_->__right_ = __x;\n        // __y can't be root if it is a right child\n        __w = __y->__parent_->__left_;\n    }\n    bool __removed_black = __y->__is_black_;\n    // If we didn't remove __z, do so now by splicing in __y for __z,\n    //    but copy __z's color.  This does not impact __x or __w.\n    if (__y != __z)\n    {\n        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr\n        __y->__parent_ = __z->__parent_;\n        if (__tree_is_left_child(__z))\n            __y->__parent_->__left_ = __y;\n        else\n            __y->__parent_->__right_ = __y;\n        __y->__left_ = __z->__left_;\n        __y->__left_->__parent_ = __y;\n        __y->__right_ = __z->__right_;\n        if (__y->__right_ != nullptr)\n            __y->__right_->__parent_ = __y;\n        __y->__is_black_ = __z->__is_black_;\n        if (__root == __z)\n            __root = __y;\n    }\n    // There is no need to rebalance if we removed a red, or if we removed\n    //     the last node.\n    if (__removed_black && __root != nullptr)\n    {\n        // Rebalance:\n        // __x has an implicit black color (transferred from the removed __y)\n        //    associated with it, no matter what its color is.\n        // If __x is __root (in which case it can't be null), it is supposed\n        //    to be black anyway, and if it is doubly black, then the double\n        //    can just be ignored.\n        // If __x is red (in which case it can't be null), then it can absorb\n        //    the implicit black just by setting its color to black.\n        // Since __y was black and only had one child (which __x points to), __x\n        //   is either red with no children, else null, otherwise __y would have\n        //   different black heights under left and right pointers.\n        // if (__x == __root || __x != nullptr && !__x->__is_black_)\n        if (__x != nullptr)\n            __x->__is_black_ = true;\n        else\n        {\n            //  Else __x isn't root, and is \"doubly black\", even though it may\n            //     be null.  __w can not be null here, else the parent would\n            //     see a black height >= 2 on the __x side and a black height\n            //     of 1 on the __w side (__w must be a non-null black or a red\n            //     with a non-null black child).\n            while (true)\n            {\n                if (!__tree_is_left_child(__w))  // if x is left child\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_left_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__left_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__left_->__right_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (__x == __root || !__x->__is_black_)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)\n                        {\n                            // __w left child is non-null and red\n                            __w->__left_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_right_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a right red child, left child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__right_->__is_black_ = true;\n                        __tree_left_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n                else\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_right_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__right_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__right_->__left_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (!__x->__is_black_ || __x == __root)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)\n                        {\n                            // __w right child is non-null and red\n                            __w->__right_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_left_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a left red child, right child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__left_->__is_black_ = true;\n                        __tree_right_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// node traits\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nstruct __is_tree_value_type_imp : false_type {};\n\ntemplate <class _Key, class _Value>\nstruct __is_tree_value_type_imp<__value_type<_Key, _Value>> : true_type {};\n\ntemplate <class ..._Args>\nstruct __is_tree_value_type : false_type {};\n\ntemplate <class _One>\nstruct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};\n#endif\n\ntemplate <class _Tp>\nstruct __tree_key_value_types {\n  typedef _Tp key_type;\n  typedef _Tp __node_value_type;\n  typedef _Tp __container_value_type;\n  static const bool __is_map = false;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const& __get_key(_Tp const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const& __get_value(__node_value_type const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n);\n  }\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static  __container_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v);\n  }\n#endif\n};\n\ntemplate <class _Key, class _Tp>\nstruct __tree_key_value_types<__value_type<_Key, _Tp> > {\n  typedef _Key                                         key_type;\n  typedef _Tp                                          mapped_type;\n  typedef __value_type<_Key, _Tp>                      __node_value_type;\n  typedef pair<const _Key, _Tp>                        __container_value_type;\n  typedef pair<_Key, _Tp>                              __nc_value_type;\n  typedef __container_value_type                       __map_value_type;\n  static const bool __is_map = true;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const&\n  __get_key(__node_value_type const& __t) {\n    return __t.__cc.first;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      key_type const&>::type\n  __get_key(_Up& __t) {\n    return __t.first;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const&\n  __get_value(__node_value_type const& __t) {\n    return __t.__cc;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      __container_value_type const&>::type\n  __get_value(_Up& __t) {\n    return __t;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n.__cc);\n  }\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static  __nc_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v.__nc);\n  }\n#endif\n};\n\ntemplate <class _VoidPtr>\nstruct __tree_node_base_types {\n  typedef _VoidPtr                                               __void_pointer;\n\n  typedef __tree_node_base<__void_pointer>                      __node_base_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type\n                                                             __node_base_pointer;\n\n  typedef __tree_end_node<__node_base_pointer>                  __end_node_type;\n  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type\n                                                             __end_node_pointer;\nprivate:\n  static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),\n                  \"_VoidPtr does not point to unqualified void type\");\n};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,\n         bool = _KVTypes::__is_map>\nstruct __tree_map_pointer_types {};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes>\nstruct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {\n  typedef typename _KVTypes::__map_value_type   _Mv;\n  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type\n                                                       __map_value_type_pointer;\n  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type\n                                                 __const_map_value_type_pointer;\n};\n\ntemplate <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>\nstruct __tree_node_types;\n\ntemplate <class _NodePtr, class _Tp, class _VoidPtr>\nstruct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >\n    : public __tree_node_base_types<_VoidPtr>,\n             __tree_key_value_types<_Tp>,\n             __tree_map_pointer_types<_Tp, _VoidPtr>\n{\n  typedef __tree_node_base_types<_VoidPtr> __base;\n  typedef __tree_key_value_types<_Tp>      __key_base;\n  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;\npublic:\n\n  typedef typename pointer_traits<_NodePtr>::element_type       __node_type;\n  typedef _NodePtr                                              __node_pointer;\n\n  typedef _Tp                                                 __node_value_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type\n                                                      __node_value_type_pointer;\n  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type\n                                                __const_node_value_type_pointer;\nprivate:\n    static_assert(!is_const<__node_type>::value,\n                \"_NodePtr should never be a pointer to const\");\n    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,\n                          _NodePtr>::value), \"_VoidPtr does not rebind to _NodePtr.\");\n};\n\ntemplate <class _ValueTp, class _VoidPtr>\nstruct __make_tree_node_types {\n  typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type\n                                                                        _NodePtr;\n  typedef __tree_node_types<_NodePtr> type;\n};\n\n// node\n\ntemplate <class _Pointer>\nclass __tree_end_node\n{\npublic:\n    typedef _Pointer pointer;\n    pointer __left_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_end_node() _NOEXCEPT : __left_() {}\n};\n\ntemplate <class _VoidPtr>\nclass __tree_node_base\n    : public __tree_node_base_types<_VoidPtr>::__end_node_type\n{\n    typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;\n\npublic:\n    typedef typename _NodeBaseTypes::__node_base_pointer pointer;\n\n    pointer __right_;\n    pointer __parent_;\n    bool __is_black_;\n\nprivate:\n  ~__tree_node_base() _LIBCPP_EQUAL_DELETE;\n  __tree_node_base(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;\n  __tree_node_base& operator=(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass __tree_node\n    : public __tree_node_base<_VoidPtr>\n{\npublic:\n    typedef _Tp __node_value_type;\n\n    __node_value_type __value_;\n\nprivate:\n  ~__tree_node() _LIBCPP_EQUAL_DELETE;\n  __tree_node(__tree_node const&) _LIBCPP_EQUAL_DELETE;\n  __tree_node& operator=(__tree_node const&) _LIBCPP_EQUAL_DELETE;\n};\n\n\ntemplate <class _Allocator>\nclass __tree_node_destructor\n{\n    typedef _Allocator                                      allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n    typedef __tree_node_types<pointer> _NodeTypes;\n    allocator_type& __na_;\n\n    __tree_node_destructor& operator=(const __tree_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node_destructor(allocator_type& __na, bool __val = false) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(__val)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __map_node_destructor;\n};\n\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_iterator\n{\n    typedef __tree_node_types<_NodePtr>                     _NodeTypes;\n    typedef _NodePtr                                        __node_pointer;\n    typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;\n    typedef pointer_traits<__node_pointer> __pointer_traits;\n\n    __node_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag                     iterator_category;\n    typedef _Tp                                            value_type;\n    typedef _DiffType                                      difference_type;\n    typedef value_type&                                    reference;\n    typedef typename _NodeTypes::__node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator++() {\n      __ptr_ = static_cast<__node_pointer>(\n          __tree_next(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator++(int)\n        {__tree_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator--() {\n      __ptr_ = static_cast<__node_pointer>(\n          __tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator--(int)\n        {__tree_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY \n        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n};\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator\n{\n    typedef __tree_node_types<_NodePtr>                     _NodeTypes;\n    typedef typename _NodeTypes::__node_pointer             __node_pointer;\n    typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;\n    typedef pointer_traits<__node_pointer> __pointer_traits;\n\n    __node_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef _Tp                                                  value_type;\n    typedef _DiffType                                            difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\nprivate:\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>\n                                                           __non_const_iterator;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator++() {\n      __ptr_ = static_cast<__node_pointer>(\n          __tree_next(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator++(int)\n        {__tree_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator--() {\n      __ptr_ = static_cast<__node_pointer>(\n          __tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator--(int)\n        {__tree_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nclass __tree\n{\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Compare                                 value_compare;\n    typedef _Allocator                               allocator_type;\n\nprivate:\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __make_tree_node_types<value_type,\n        typename __alloc_traits::void_pointer>::type\n                                                    _NodeTypes;\n    typedef typename _NodeTypes::key_type           key_type;\npublic:\n    typedef typename _NodeTypes::__node_value_type      __node_value_type;\n    typedef typename _NodeTypes::__container_value_type __container_value_type;\n\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\npublic:\n    typedef typename _NodeTypes::__void_pointer        __void_pointer;\n\n    typedef typename _NodeTypes::__node_type           __node;\n    typedef typename _NodeTypes::__node_pointer        __node_pointer;\n\n    typedef typename _NodeTypes::__node_base_type      __node_base;\n    typedef typename _NodeTypes::__node_base_pointer   __node_base_pointer;\n\n    typedef typename _NodeTypes::__end_node_type       __end_node_t;\n    typedef typename _NodeTypes::__end_node_pointer    __end_node_ptr;\n\n    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;\n    typedef allocator_traits<__node_allocator>         __node_traits;\n\nprivate:\n    // check for sane allocator pointer rebinding semantics. Rebinding the\n    // allocator for a new pointer type should be exactly the same as rebinding\n    // the pointer using 'pointer_traits'.\n    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),\n                  \"Allocator does not rebind pointers in a sane manner.\");\n    typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type\n        __node_base_allocator;\n    typedef allocator_traits<__node_base_allocator> __node_base_traits;\n    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),\n                 \"Allocator does not rebind pointers in a sane manner.\");\n\nprivate:\n    __node_pointer                                     __begin_node_;\n    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;\n    __compressed_pair<size_type, value_compare>        __pair3_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __end_node() _NOEXCEPT\n    {\n        return static_cast<__node_pointer>(\n                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())\n        );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __end_node() const _NOEXCEPT\n    {\n        return static_cast<__node_pointer>(\n            pointer_traits<__end_node_ptr>::pointer_to(\n                const_cast<__end_node_t&>(__pair1_.first())\n            )\n        );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __pair1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type __alloc() const _NOEXCEPT\n        {return allocator_type(__node_alloc());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& size() _NOEXCEPT {return __pair3_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __pair3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          value_compare& value_comp() _NOEXCEPT {return __pair3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_compare& value_comp() const _NOEXCEPT\n        {return __pair3_.second();}\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __root() const _NOEXCEPT\n        {return static_cast<__node_pointer>(__end_node()->__left_);}\n\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;\n    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;\n\n    explicit __tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value);\n    explicit __tree(const allocator_type& __a);\n    __tree(const value_compare& __comp, const allocator_type& __a);\n    __tree(const __tree& __t);\n    __tree& operator=(const __tree& __t);\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __tree(__tree&& __t)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<value_compare>::value);\n    __tree(__tree&& __t, const allocator_type& __a);\n    __tree& operator=(__tree&& __t)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<value_compare>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~__tree();\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin()  _NOEXCEPT {return       iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return       iterator(__end_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__end_node());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return __node_traits::max_size(__node_alloc());}\n\n    void clear() _NOEXCEPT;\n\n    void swap(__tree& __t)\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value\n#if _LIBCPP_STD_VER <= 11\n            && (!__node_traits::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<__node_allocator>::value)\n#endif\n            );\n\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Key, class ..._Args>\n    pair<iterator, bool>\n    __emplace_unique_key_args(_Key const&, _Args&&... __args);\n    template <class _Key, class ..._Args>\n    iterator\n    __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);\n\n    template <class... _Args>\n    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_multi(_Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Pp&& __x) {\n        return __emplace_unique_extract_key(_VSTD::forward<_Pp>(__x),\n                                            __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        pair<iterator, bool>\n    >::type __emplace_unique(_First&& __f, _Second&& __s) {\n        return __emplace_unique_key_args(__f, _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Args&&... __args) {\n        return __emplace_unique_impl(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_unique_impl(_VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {\n      return __emplace_unique_key_args(__x, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {\n      return __emplace_unique_key_args(__x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {\n        return __emplace_hint_unique_extract_key(__p, _VSTD::forward<_Pp>(__x),\n                                            __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        iterator\n    >::type __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {\n        return __emplace_hint_unique_key_args(__p, __f,\n                                              _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {\n        return __emplace_hint_unique_impl(__p, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_hint_unique_impl(__p, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {\n      return __emplace_hint_unique_key_args(__p, __x, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {\n      return __emplace_hint_unique_key_args(__p, __x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n#else\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args& __args);\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(const __container_value_type& __v) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {\n        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v);\n    }\n\n#ifdef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const __container_value_type& __v);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, const __container_value_type& __v);\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(__container_value_type&& __v) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), _VSTD::move(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {\n        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), _VSTD::move(__v));\n    }\n\n    template <class _Vp, class = typename enable_if<\n            !is_same<typename __unconstref<_Vp>::type,\n                     __container_value_type\n            >::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(_Vp&& __v) {\n        return __emplace_unique(_VSTD::forward<_Vp>(__v));\n    }\n\n    template <class _Vp, class = typename enable_if<\n            !is_same<typename __unconstref<_Vp>::type,\n                     __container_value_type\n            >::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, _Vp&& __v) {\n        return __emplace_hint_unique(__p, _VSTD::forward<_Vp>(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(__container_value_type&& __v) {\n        return __emplace_multi(_VSTD::move(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, __container_value_type&& __v) {\n        return __emplace_hint_multi(__p, _VSTD::move(__v));\n    }\n\n    template <class _Vp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(_Vp&& __v) {\n        return __emplace_multi(_VSTD::forward<_Vp>(__v));\n    }\n\n    template <class _Vp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, _Vp&& __v) {\n        return __emplace_hint_multi(__p, _VSTD::forward<_Vp>(__v));\n    }\n\n#endif // !_LIBCPP_CXX03_LANG\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_unique(const_iterator __p,\n                                              __node_pointer __nd);\n\n    iterator __node_insert_multi(__node_pointer __nd);\n    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n\n    void __insert_node_at(__node_base_pointer __parent,\n                          __node_base_pointer& __child,\n                          __node_base_pointer __new_node);\n\n    template <class _Key>\n        iterator find(const _Key& __v);\n    template <class _Key>\n        const_iterator find(const _Key& __v) const;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator lower_bound(const _Key& __v)\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __lower_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator lower_bound(const _Key& __v) const\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __lower_bound(const _Key& __v,\n                                     __node_pointer __root,\n                                     __node_pointer __result) const;\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator upper_bound(const _Key& __v)\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __upper_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator upper_bound(const _Key& __v) const\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __upper_bound(const _Key& __v,\n                                     __node_pointer __root,\n                                     __node_pointer __result) const;\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    typedef __tree_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\nprivate:\n    typename __node_base::pointer&\n        __find_leaf_low(typename __node_base::pointer& __parent, const key_type& __v);\n    typename __node_base::pointer&\n        __find_leaf_high(typename __node_base::pointer& __parent, const key_type& __v);\n    typename __node_base::pointer&\n        __find_leaf(const_iterator __hint,\n                    typename __node_base::pointer& __parent, const key_type& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(typename __node_base::pointer& __parent, const _Key& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(const_iterator __hint, typename __node_base::pointer& __parent,\n                     const _Key& __v);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    __node_holder __construct_node(_Args&& ...__args);\n#else\n    __node_holder __construct_node(const __container_value_type& __v);\n#endif\n\n    void destroy(__node_pointer __nd) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t)\n        {__copy_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, true_type)\n        {__node_alloc() = __t.__node_alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, false_type) {}\n\n    void __move_assign(__tree& __t, false_type);\n    void __move_assign(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n                   is_nothrow_move_assignable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {__node_alloc() = _VSTD::move(__t.__node_alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, false_type) _NOEXCEPT {}\n\n    __node_pointer __detach();\n    static __node_pointer __detach(__node_pointer);\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value)\n    : __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_allocator(__a)),\n      __pair3_(0)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,\n                                           const allocator_type& __a)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_allocator(__a)),\n      __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\n// Precondition:  size() != 0\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach()\n{\n    __node_pointer __cache = __begin_node();\n    __begin_node() = __end_node();\n    __end_node()->__left_->__parent_ = nullptr;\n    __end_node()->__left_ = nullptr;\n    size() = 0;\n    // __cache->__left_ == nullptr\n    if (__cache->__right_ != nullptr)\n        __cache = static_cast<__node_pointer>(__cache->__right_);\n    // __cache->__left_ == nullptr\n    // __cache->__right_ == nullptr\n    return __cache;\n}\n\n// Precondition:  __cache != nullptr\n//    __cache->left_ == nullptr\n//    __cache->right_ == nullptr\n//    This is no longer a red-black tree\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)\n{\n    if (__cache->__parent_ == nullptr)\n        return nullptr;\n    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))\n    {\n        __cache->__parent_->__left_ = nullptr;\n        __cache = static_cast<__node_pointer>(__cache->__parent_);\n        if (__cache->__right_ == nullptr)\n            return __cache;\n        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));\n    }\n    // __cache is right child\n    __cache->__parent_->__right_ = nullptr;\n    __cache = static_cast<__node_pointer>(__cache->__parent_);\n    if (__cache->__left_ == nullptr)\n        return __cache;\n    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)\n{\n    if (this != &__t)\n    {\n        value_comp() = __t.value_comp();\n        __copy_assign_alloc(__t);\n        __assign_multi(__t.begin(), __t.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value),\n                  \"__assign_unique may only be called with the containers value type\");\n\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value ||\n                  is_same<_ItValueType, __node_value_type>::value),\n                  \"__assign_multi may only be called with the containers value type\"\n                  \" or the nodes value type\");\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(_NodeTypes::__get_value(*__first));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),\n      __pair3_(0, __t.value_comp())\n{\n    __begin_node() = __end_node();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)\n    _NOEXCEPT_(\n        is_nothrow_move_constructible<__node_allocator>::value &&\n        is_nothrow_move_constructible<value_compare>::value)\n    : __begin_node_(_VSTD::move(__t.__begin_node_)),\n      __pair1_(_VSTD::move(__t.__pair1_)),\n      __pair3_(_VSTD::move(__t.__pair3_))\n{\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __pair3_(0, _VSTD::move(__t.value_comp()))\n{\n    if (__a == __t.__alloc())\n    {\n        if (__t.size() == 0)\n            __begin_node() = __end_node();\n        else\n        {\n            __begin_node() = __t.__begin_node();\n            __end_node()->__left_ = __t.__end_node()->__left_;\n            __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n            size() = __t.size();\n            __t.__begin_node() = __t.__end_node();\n            __t.__end_node()->__left_ = nullptr;\n            __t.size() = 0;\n        }\n    }\n    else\n    {\n        __begin_node() = __end_node();\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n               is_nothrow_move_assignable<__node_allocator>::value)\n{\n    destroy(static_cast<__node_pointer>(__end_node()->__left_));\n    __begin_node_ = __t.__begin_node_;\n    __pair1_.first() = __t.__pair1_.first();\n    __move_assign_alloc(__t);\n    __pair3_ = _VSTD::move(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)\n{\n    if (__node_alloc() == __t.__node_alloc())\n        __move_assign(__t, true_type());\n    else\n    {\n        value_comp() = _VSTD::move(__t.value_comp());\n        const_iterator __e = end();\n        if (size() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (__cache != nullptr && __t.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);\n                    __node_pointer __next = __detach(__cache);\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__cache != nullptr)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n            }\n        }\n        while (__t.size() != 0)\n            __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<value_compare>::value &&\n        is_nothrow_move_assignable<__node_allocator>::value)\n        \n{\n    __move_assign(__t, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::~__tree()\n{\n    destroy(__root());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT\n{\n    if (__nd != nullptr)\n    {\n        destroy(static_cast<__node_pointer>(__nd->__left_));\n        destroy(static_cast<__node_pointer>(__nd->__right_));\n        __node_allocator& __na = __node_alloc();\n        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));\n        __node_traits::deallocate(__na, __nd, 1);\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value\n#if _LIBCPP_STD_VER <= 11\n            && (!__node_traits::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<__node_allocator>::value)\n#endif\n            )\n{\n    using _VSTD::swap;\n    swap(__begin_node_, __t.__begin_node_);\n    swap(__pair1_.first(), __t.__pair1_.first());\n    __swap_allocator(__node_alloc(), __t.__node_alloc());\n    __pair3_.swap(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n    if (__t.size() == 0)\n        __t.__begin_node() = __t.__end_node();\n    else\n        __t.__end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__t.__end_node());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT\n{\n    destroy(__root());\n    size() = 0;\n    __begin_node() = __end_node();\n    __end_node()->__left_ = nullptr;\n}\n\n// Find lower_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(typename __node_base::pointer& __parent,\n                                                   const key_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find upper_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(typename __node_base::pointer& __parent,\n                                                    const key_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find leaf place to insert closest to __hint\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,\n                                               typename __node_base::pointer& __parent,\n                                               const key_type& __v)\n{\n    if (__hint == end() || !value_comp()(*__hint, __v))  // check before\n    {\n        // __v <= *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || !value_comp()(__v, *--__prior))\n        {\n            // *prev(__hint) <= __v <= *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v < *prev(__hint)\n        return __find_leaf_high(__parent, __v);\n    }\n    // else __v > *__hint\n    return __find_leaf_low(__parent, __v);\n}\n\n// Find place to insert if __v doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find place to insert if __v doesn't exist\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,\n                                                typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    if (__hint == end() || value_comp()(__v, *__hint))  // check before\n    {\n        // __v < *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || value_comp()(*--__prior, __v))\n        {\n            // *prev(__hint) < __v < *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v <= *prev(__hint)\n        return __find_equal(__parent, __v);\n    }\n    else if (value_comp()(*__hint, __v))  // check after\n    {\n        // *__hint < __v\n        const_iterator __next = _VSTD::next(__hint);\n        if (__next == end() || value_comp()(__v, *__next))\n        {\n            // *__hint < __v < *_VSTD::next(__hint)\n            if (__hint.__ptr_->__right_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__right_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__next.__ptr_);\n                return __parent->__left_;\n            }\n        }\n        // *next(__hint) <= __v\n        return __find_equal(__parent, __v);\n    }\n    // else __v == *__hint\n    __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n    return __parent;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__node_base_pointer __parent,\n                                                    __node_base_pointer& __child,\n                                                    __node_base_pointer __new_node)\n{\n    __new_node->__left_   = nullptr;\n    __new_node->__right_  = nullptr;\n    __new_node->__parent_ = __parent;\n    // __new_node->__is_black_ is initialized in __tree_balance_after_insert\n    __child = __new_node;\n    if (__begin_node()->__left_ != nullptr)\n        __begin_node() = static_cast<__node_pointer>(__begin_node()->__left_);\n    __tree_balance_after_insert(__end_node()->__left_, __child);\n    ++size();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args& __args)\n#endif\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node(__args);\n#endif\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(\n    const_iterator __p, _Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(\n    const_iterator __p, _Key const& __k, _Args& __args)\n#endif\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node(__args);\n#endif\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)\n{\n    static_assert(!__is_tree_value_type<_Args...>::value,\n                  \"Cannot construct from __value_type\");\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    return __h;\n}\n\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,\n                                                        _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(const __container_value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#ifdef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const __container_value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__v));\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const __container_value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__v));\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n#endif\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,\n                                                        __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,\n                                                       __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__ptr_;\n    iterator __r(__np);\n    ++__r;\n    if (__begin_node() == __np)\n        __begin_node() = __r.__ptr_;\n    --size();\n    __node_allocator& __na = __node_alloc();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    __node_traits::destroy(__na, _NodeTypes::__get_ptr(\n        const_cast<__node_value_type&>(*__p)));\n    __node_traits::deallocate(__na, __np, 1);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    while (__f != __l)\n        __f = erase(__f);\n    return iterator(__l.__ptr_);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)\n{\n    pair<iterator, iterator> __p = __equal_range_multi(__k);\n    size_type __r = 0;\n    for (; __p.first != __p.second; ++__r)\n        __p.first = erase(__p.first);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)\n{\n    iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const\n{\n    const_iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const\n{\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const\n{\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _VSTD::distance(\n                __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result)\n            );\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(iterator(__rt),\n                      iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(const_iterator(__rt),\n                      const_iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT\n{\n    __node_pointer __np = __p.__ptr_;\n    if (__begin_node() == __np)\n    {\n        if (__np->__right_ != nullptr)\n            __begin_node() = static_cast<__node_pointer>(__np->__right_);\n        else\n            __begin_node() = static_cast<__node_pointer>(__np->__parent_);\n    }\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    return __node_holder(__np, _Dp(__node_alloc(), true));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__tree<_Tp, _Compare, _Allocator>& __x,\n     __tree<_Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___TREE\n","// -*- C++ -*-\n//===--------------------------- tuple ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TUPLE\n#define _LIBCPP_TUPLE\n\n/*\n    tuple synopsis\n\nnamespace std\n{\n\ntemplate <class... T>\nclass tuple {\npublic:\n    constexpr tuple();\n    explicit tuple(const T&...);  // constexpr in C++14\n    template <class... U>\n        explicit tuple(U&&...);  // constexpr in C++14\n    tuple(const tuple&) = default;\n    tuple(tuple&&) = default;\n    template <class... U>\n        tuple(const tuple<U...>&);  // constexpr in C++14\n    template <class... U>\n        tuple(tuple<U...>&&);  // constexpr in C++14\n    template <class U1, class U2>\n        tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14\n    template <class U1, class U2>\n        tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14\n\n    // allocator-extended constructors\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const T&...);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, U&&...);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const tuple&);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, tuple&&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);\n\n    tuple& operator=(const tuple&);\n    tuple&\n        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));\n    template <class... U>\n        tuple& operator=(const tuple<U...>&);\n    template <class... U>\n        tuple& operator=(tuple<U...>&&);\n    template <class U1, class U2>\n        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2\n    template <class U1, class U2>\n        tuple& operator=(pair<U1, U2>&&); //iffsizeof...(T) == 2\n\n    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));\n};\n\nconst unspecified ignore;\n\ntemplate <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14\ntemplate <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14\ntemplate <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14\ntemplate <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14\n  \n// 20.4.1.4, tuple helper classes:\ntemplate <class T> class tuple_size; // undefined\ntemplate <class... T> class tuple_size<tuple<T...>>;\ntemplate <size_t I, class T> class tuple_element; // undefined\ntemplate <size_t I, class... T> class tuple_element<I, tuple<T...>>;\ntemplate <size_t I, class T>\n  using tuple_element_t = typename tuple_element <I, T>::type; // C++14\n\n// 20.4.1.5, element access:\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&\n    get(tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&\n    get(const tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&&\n    get(tuple<T...>&&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&&\n    get(const tuple<T...>&&) noexcept; // constexpr in C++14\n\ntemplate <class T1, class... T>\n    constexpr T1& get(tuple<T...>&) noexcept;  // C++14\ntemplate <class T1, class... T>\n    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14\n\n// 20.4.1.6, relational operators:\ntemplate<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\n\ntemplate <class... Types, class Alloc>\n  struct uses_allocator<tuple<Types...>, Alloc>;\n\ntemplate <class... Types>\n  void\n  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <cstddef>\n#include <type_traits>\n#include <__functional_base>\n#include <utility>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// tuple_size\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_size<tuple<_Tp...> >\n    : public integral_constant<size_t, sizeof...(_Tp)>\n{\n};\n\n// tuple_element\n\ntemplate <size_t _Ip, class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, tuple<_Tp...> >\n{\npublic:\n    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Ip, class ..._Tp>\nusing tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;\n#endif\n\n// __tuple_leaf\n\ntemplate <size_t _Ip, class _Hp,\n          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value\n         >\nclass __tuple_leaf;\n\ntemplate <size_t _Ip, class _Hp, bool _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)\n{\n    swap(__x.get(), __y.get());\n}\n\ntemplate <size_t _Ip, class _Hp, bool>\nclass __tuple_leaf\n{\n    _Hp value;\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : value()\n       {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)\n            : value()\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : value(allocator_arg_t(), __a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : value(__a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                      __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                    , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)) ||\n                        (is_rvalue_reference<_Hp>::value &&\n                         !is_lvalue_reference<_Tp>::value),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : value(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t), __a)\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    __tuple_leaf(const __tuple_leaf& __t) = default;\n    __tuple_leaf(__tuple_leaf&& __t) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            value = _VSTD::forward<_Tp>(__t);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return value;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return value;}\n};\n\ntemplate <size_t _Ip, class _Hp>\nclass __tuple_leaf<_Ip, _Hp, true>\n    : private _Hp\n{\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : _Hp(allocator_arg_t(), __a) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : _Hp(__a) {}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                        __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                      , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}\n\n    __tuple_leaf(__tuple_leaf const &) = default;\n    __tuple_leaf(__tuple_leaf &&) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            _Hp::operator=(_VSTD::forward<_Tp>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int\n    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}\n};\n\ntemplate <class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swallow(_Tp&&...) _NOEXCEPT {}\n\ntemplate <bool ..._Pred>\nstruct __all\n    : is_same<__all<_Pred...>, __all<(_Pred, true)...>>\n{ };\n\ntemplate <class ..._Tp>\nstruct __lazy_all : __all<_Tp::value...> {};\n\ntemplate <class _Tp>\nstruct __all_default_constructible;\n\ntemplate <class ..._Tp>\nstruct __all_default_constructible<__tuple_types<_Tp...>>\n    : __all<is_default_constructible<_Tp>::value...>\n{ };\n\n// __tuple_impl\n\ntemplate<class _Indx, class ..._Tp> struct __tuple_impl;\n\ntemplate<size_t ..._Indx, class ..._Tp>\nstruct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>\n    : public __tuple_leaf<_Indx, _Tp>...\n{\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR __tuple_impl()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u)\n                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&\n                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :\n            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>()...\n            {}\n\n    template <class _Alloc, size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        __tuple_impl(allocator_arg_t, const _Alloc& __a,\n                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u) :\n            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,\n            _VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,\n                                       _VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Tuple>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,\n            __tuple_impl&\n        >::type\n        operator=(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n        {\n            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...);\n            return *this;\n        }\n\n    __tuple_impl(const __tuple_impl&) = default;\n    __tuple_impl(__tuple_impl&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(const __tuple_impl& __t) _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(__tuple_impl&& __t) _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(__tuple_impl& __t)\n        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);\n    }\n};\n\ntemplate <bool _IsTuple, class _SizeTrait, size_t _Expected>\nstruct __tuple_like_with_size_imp : false_type {};\n\ntemplate <class _SizeTrait, size_t _Expected>\nstruct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>\n    : integral_constant<bool, _SizeTrait::value == _Expected> {};\n\ntemplate <class _Tuple, size_t _ExpectedSize,\n          class _RawTuple = typename __uncvref<_Tuple>::type>\nusing __tuple_like_with_size = __tuple_like_with_size_imp<\n                                   __tuple_like<_RawTuple>::value,\n                                   tuple_size<_RawTuple>, _ExpectedSize\n                              >;\n\n\nstruct _LIBCPP_TYPE_VIS __check_tuple_constructor_fail {\n    template <class ...>\n    static constexpr bool __enable_explicit() { return false; }\n    template <class ...>\n    static constexpr bool __enable_implicit() { return false; }\n};\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple\n{\n    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> base;\n\n    base base_;\n\n    template <class ..._Args>\n    struct _PackExpandsToThisTuple : false_type {};\n\n    template <class _Arg>\n    struct _PackExpandsToThisTuple<_Arg>\n        : is_same<typename __uncvref<_Arg>::type, tuple> {};\n\n    template <bool _MaybeEnable, class _Dummy = void>\n    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckArgsConstructor<true, _Dummy>\n    {\n        template <class ..._Args>\n        static constexpr bool __enable_explicit() {\n            return\n                __tuple_constructible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                !__tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n\n        template <class ..._Args>\n        static constexpr bool __enable_implicit() {\n            return\n                __tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n    };\n\n    template <bool _MaybeEnable,\n              bool = sizeof...(_Tp) == 1,\n              class _Dummy = void>\n    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, false, _Dummy>\n    {\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __tuple_convertible<_Tuple, tuple>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __tuple_constructible<_Tuple, tuple>::value\n               && !__tuple_convertible<_Tuple, tuple>::value;\n        }\n    };\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, true, _Dummy>\n    {\n        // This trait is used to disable the tuple-like constructor when\n        // the UTypes... constructor should be selected instead.\n        // See LWG issue #2549.\n        template <class _Tuple>\n        using _PreferTupleLikeConstructor = __lazy_or<\n            // Don't attempt the two checks below if the tuple we are given\n            // has the same type as this tuple.\n            is_same<typename __uncvref<_Tuple>::type, tuple>,\n            __lazy_and<\n                __lazy_not<is_constructible<_Tp..., _Tuple>>,\n                __lazy_not<is_convertible<_Tuple, _Tp...>>\n            >\n        >;\n\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __lazy_and<\n                __tuple_convertible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>\n            >::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __lazy_and<\n                __tuple_constructible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>,\n                __lazy_not<__tuple_convertible<_Tuple, tuple>>\n            >::value;\n        }\n    };\n\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) _NOEXCEPT;\npublic:\n\n    template <bool _Dummy = true, class = typename enable_if<\n        __all<__dependent_type<is_default_constructible<_Tp>, _Dummy>::value...>::value\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <class _AllocArgT, class _Alloc, bool _Dummy = true, class = typename enable_if<\n        __lazy_and<\n            is_base_of<allocator_arg_t, _AllocArgT>,\n            __lazy_all<__dependent_type<is_default_constructible<_Tp>, _Dummy>...>\n       >::value\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    tuple(_AllocArgT, _Alloc const& __a)\n      : base_(allocator_arg_t(), __a,\n                    __tuple_indices<>(), __tuple_types<>(),\n                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),\n                    __tuple_types<_Tp...>()) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      explicit\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) <= sizeof...(_Tp)\n                             && !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) <= sizeof...(_Tp)\n                             && !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_assignable<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple&\n        operator=(_Tuple&& __t) _NOEXCEPT_((is_nothrow_assignable<base&, _Tuple>::value))\n        {\n            base_.operator=(_VSTD::forward<_Tuple>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n        {base_.swap(__t.base_);}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY tuple<>\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple() _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(array<_Up, 0>) _NOEXCEPT {}\n    template <class _Alloc, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple&) _NOEXCEPT {}\n};\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __all<__is_swappable<_Tp>::value...>::value,\n    void\n>::type\nswap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)\n                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {__t.swap(__u);}\n\n// get\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<__tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(const tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<type&&>(\n             static_cast<__tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(const tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const type&&>(\n             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\n#if _LIBCPP_STD_VER > 11\n// get by type\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_helper;\n\n// -- find exactly one\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_checker {\n    static constexpr size_t value = _Idx;\n//  Check the rest of the list to make sure there's only one\n    static_assert ( __find_exactly_one_t_helper<_T1, 0, _Args...>::value == -1, \"type can only occur once in type list\" );\n    };\n\n\ntemplate <typename _T1, size_t _Idx>\nstruct __find_exactly_one_t_helper <_T1, _Idx> {\n    static constexpr size_t value = -1;\n    };\n\ntemplate <typename _T1, size_t _Idx, typename _Head, typename... _Args>\nstruct __find_exactly_one_t_helper <_T1, _Idx, _Head, _Args...> {\n    static constexpr size_t value =\n        std::conditional<\n            std::is_same<_T1, _Head>::value,\n            __find_exactly_one_t_checker<_T1, _Idx,   _Args...>,\n            __find_exactly_one_t_helper <_T1, _Idx+1, _Args...>\n        >::type::value;\n    };\n\ntemplate <typename _T1, typename... _Args>\nstruct __find_exactly_one_t {\n    static constexpr size_t value = __find_exactly_one_t_helper<_T1, 0, _Args...>::value;\n    static_assert ( value != -1, \"type not found in type list\" );\n    };\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1& get(tuple<_Args...>& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1&& get(tuple<_Args...>&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\n#endif\n\n// tie\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&...>\ntie(_Tp&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&...>(__t...);\n}\n\ntemplate <class _Up>\nstruct __ignore_t\n{\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        const __ignore_t& operator=(_Tp&&) const {return *this;}\n};\n\nnamespace { const __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>(); }\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl<reference_wrapper<_Tp> >\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return\n{\n    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<typename __make_tuple_return<_Tp>::type...>\nmake_tuple(_Tp&&... __t)\n{\n    return tuple<typename __make_tuple_return<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&&...>\nforward_as_tuple(_Tp&&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_equal\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);\n    }\n};\n\ntemplate <>\nstruct __tuple_equal<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return true;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_less\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        const size_t __idx = tuple_size<_Tp>::value - _Ip;\n        if (_VSTD::get<__idx>(__x) < _VSTD::get<__idx>(__y))\n            return true;\n        if (_VSTD::get<__idx>(__y) < _VSTD::get<__idx>(__x))\n            return false;\n        return __tuple_less<_Ip-1>()(__x, __y);\n    }\n};\n\ntemplate <>\nstruct __tuple_less<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return false;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_less<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__y < __x);\n}\n\n// tuple_cat\n\ntemplate <class _Tp, class _Up> struct __tuple_cat_type;\n\ntemplate <class ..._Ttypes, class ..._Utypes>\nstruct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >\n{\n    typedef tuple<_Ttypes..., _Utypes...> type;\n};\n\ntemplate <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>\nstruct __tuple_cat_return_1\n{\n};\n\ntemplate <class ..._Types, class _Tuple0>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>\n{\n    typedef typename __tuple_cat_type<tuple<_Types...>,\n            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type\n                                                                           type;\n};\n\ntemplate <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_1<\n                 typename __tuple_cat_type<\n                     tuple<_Types...>,\n                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type\n                 >::type,\n                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,\n                 _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class ..._Tuples> struct __tuple_cat_return;\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return<_Tuple0, _Tuples...>\n    : public __tuple_cat_return_1<tuple<>,\n         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,\n                                                                     _Tuples...>\n{\n};\n\ntemplate <>\nstruct __tuple_cat_return<>\n{\n    typedef tuple<> type;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<>\ntuple_cat()\n{\n    return tuple<>();\n}\n\ntemplate <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp;\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    typedef tuple<_Types..., typename __apply_cv<_Tuple0,\n                          typename tuple_element<_I0, _T0>::type>::type&&...> type;\n};\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,\n                                  _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_ref_imp<\n         tuple<_Types..., typename __apply_cv<_Tuple0,\n               typename tuple_element<_I0,\n                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,\n         typename __make_tuple_indices<tuple_size<typename\n                                 remove_reference<_Tuple1>::type>::value>::type,\n         _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref\n    : public __tuple_cat_return_ref_imp<tuple<>,\n               typename __make_tuple_indices<\n                        tuple_size<typename remove_reference<_Tuple0>::type>::value\n               >::type, _Tuple0, _Tuples...>\n{\n};\n\ntemplate <class _Types, class _I0, class _J0>\nstruct __tuple_cat;\n\ntemplate <class ..._Types, size_t ..._I0, size_t ..._J0>\nstruct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >\n{\n    template <class _Tuple0>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0)\n    {\n        return forward_as_tuple(_VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                                      _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);\n    }\n\n    template <class _Tuple0, class _Tuple1, class ..._Tuples>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)\n    {\n        typedef typename remove_reference<_Tuple0>::type _T0;\n        typedef typename remove_reference<_Tuple1>::type _T1;\n        return __tuple_cat<\n           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,\n           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,\n           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()\n                           (forward_as_tuple(\n                              _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                              _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...\n                            ),\n                            _VSTD::forward<_Tuple1>(__t1),\n                            _VSTD::forward<_Tuples>(__tpls)...);\n    }\n};\n\ntemplate <class _Tuple0, class... _Tuples>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename __tuple_cat_return<_Tuple0, _Tuples...>::type\ntuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    return __tuple_cat<tuple<>, __tuple_indices<>,\n                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()\n                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),\n                                            _VSTD::forward<_Tuples>(__tpls)...);\n}\n\ntemplate <class ..._Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator<tuple<_Tp...>, _Alloc>\n    : true_type {};\n\ntemplate <class _T1, class _T2>\ntemplate <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1, _T2>::pair(piecewise_construct_t,\n                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)\n    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),\n      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n{\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TUPLE\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less<void>\n{\n    template <class _T1, class _T2> \n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n#endif // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\n#else // defined(_LIBCPP_CXX03_LANG)\n\n#include <__functional_base_03>\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n\ntemplate <class _Ret>\nstruct __invoke_void_return_wrapper\n{\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class ..._Args>\n    static _Ret __call(_Args&&... __args) {\n        return __invoke(_VSTD::forward<_Args>(__args)...);\n    }\n#else\n    template <class _Fn>\n    static _Ret __call(_Fn __f) {\n        return __invoke(__f);\n    }\n\n    template <class _Fn, class _A0>\n    static _Ret __call(_Fn __f, _A0& __a0) {\n        return __invoke(__f, __a0);\n    }\n\n    template <class _Fn, class _A0, class _A1>\n    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1) {\n        return __invoke(__f, __a0, __a1);\n    }\n\n    template <class _Fn, class _A0, class _A1, class _A2>\n    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2){\n        return __invoke(__f, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate <>\nstruct __invoke_void_return_wrapper<void>\n{\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class ..._Args>\n    static void __call(_Args&&... __args) {\n        __invoke(_VSTD::forward<_Args>(__args)...);\n    }\n#else\n    template <class _Fn>\n    static void __call(_Fn __f) {\n        __invoke(__f);\n    }\n\n    template <class _Fn, class _A0>\n    static void __call(_Fn __f, _A0& __a0) {\n        __invoke(__f, __a0);\n    }\n\n    template <class _Fn, class _A0, class _A1>\n    static void __call(_Fn __f, _A0& __a0, _A1& __a1) {\n        __invoke(__f, __a0, __a1);\n    }\n\n    template <class _Fn, class _A0, class _A1, class _A2>\n    static void __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2) {\n        __invoke(__f, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    // invoke\n    template <class... _ArgTypes>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_of<type&, _ArgTypes...>::type\n    operator() (_ArgTypes&&... __args) const {\n        return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n    }\n#else\n\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return<type>::type\n    operator() () const {\n        return __invoke(get());\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0>::type\n    operator() (_A0& __a0) const {\n        return __invoke(get(), __a0);\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0 const>::type\n    operator() (_A0 const& __a0) const {\n        return __invoke(get(), __a0);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1>::type\n    operator() (_A0& __a0, _A1& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1>::type\n    operator() (_A0 const& __a0, _A1& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1 const>::type\n    operator() (_A0& __a0, _A1 const& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2>::type\n    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2 const>::type\n    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n#endif // _LIBCPP_HAS_NO_VARIADICS\n};\n\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&);// = delete;\ntemplate <class _Tp> void cref(const _Tp&&);// = delete;\n\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp1, class _Tp2 = void>\nstruct __is_transparent\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_transparent* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp1>(0)) == 1;\n};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_arg_t { };\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)\nextern const allocator_arg_t allocator_arg;\n#else\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)\n{ \n    __user_alloc_construct_impl( \n             __uses_alloc_ctor<_Tp, _Allocator>(), \n             __storage, __a, _VSTD::forward<_Args>(__args)...\n        );\n}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n"]}